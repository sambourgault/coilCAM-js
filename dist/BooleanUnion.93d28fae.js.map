{"version":3,"sources":["node_modules/@flatten-js/core/dist/main.mjs","coilcam-functions/boolean/BooleanUnion.js","../../../usr/local/lib/node_modules/parcel-bundler/src/builtins/hmr-runtime.js"],"names":["CCW","exports","CW","ORIENTATION","NOT_ORIENTABLE","PIx2","Math","PI","INSIDE$2","INSIDE","OUTSIDE$1","OUTSIDE","BOUNDARY$1","BOUNDARY","CONTAINS","INTERLACE","OVERLAP_SAME$1","OVERLAP_SAME","OVERLAP_OPPOSITE$1","OVERLAP_OPPOSITE","NOT_VERTEX$1","START_VERTEX$1","END_VERTEX$1","Constants","Object","freeze","__proto__","END_VERTEX","NOT_VERTEX","START_VERTEX","DP_TOL","setTolerance","tolerance","getTolerance","DECIMALS","EQ_0","x","EQ","y","GT","GE","LT","LE","Utils$1","Utils","Flatten","default","Errors","undefined","Matrix","Planar_set","Point","Vector","Line","Circle","Segment","Arc","Box","Edge","Face","Ray","Ray_shooting","Multiline","Polygon","Distance","Inversion","c","defineProperty","get","set","value","ILLEGAL_PARAMETERS","ReferenceError","ZERO_DIVISION","Error","UNRESOLVED_BOUNDARY_CONFLICT","INFINITE_LOOP","CANNOT_COMPLETE_BOOLEAN_OPERATION","CANNOT_INVOKE_ABSTRACT_METHOD","OPERATION_IS_NOT_SUPPORTED","LinkedList","constructor","first","last","Symbol","iterator","next","done","size","counter","edge","toArray","start","end","elements","from","to","element","push","append","isEmpty","prev","insert","newElement","elementBefore","elementAfter","remove","testInfiniteLoop","controlEdge","addToIntPoints","pt","int_points","id","length","shapes","shape","split","len","is_vertex","arc_length","Infinity","coord","edge_before","edge_after","face","sortIntersections","intersections","int_points1_sorted","getSortedArray","int_points1","int_points2_sorted","int_points2","faceMap","Map","ip","has","faceId","int_points_sorted","slice","sort","compareFn","ip1","ip2","filterDuplicatedIntersections","do_squeeze","int_point_ref1","int_point_ref2","int_point_cur1","int_point_cur2","i","j","filter","int_point","forEach","index","initializeInclusionFlags","bvStart","bvEnd","bv","overlap","calculateInclusionFlags","polygon","setInclusion","setOverlappingFlags","cur_face","first_int_point_in_face_id","next_int_point1","num_int_points","cur_int_point1","int_points_cur_pool_start","int_points_cur_pool_num","intPointsPoolCount","next_int_point_id","int_points_next_pool_num","next_int_point1_tmp","edge_from1","edge_to1","cur_int_point2","next_int_point2","edge_from2","edge_to2","setOverlap","cur_int_point_num","int_point_current","int_point_next","int_points_pool_num","equalTo","splitByIntersections","newEdge","addVertex","insertBetweenIntPoints","int_point1","int_point2","new_edges","smart_intersections","SmartIntersections","INSIDE$1","BOOLEAN_UNION","BOOLEAN_INTERSECT","BOOLEAN_SUBTRACT","unify","polygon1","polygon2","res_poly","wrk_poly","booleanOpBinary","subtract","polygon2_tmp","clone","polygon2_reversed","reverse","intersect$1","innerClip","clip_shapes1","faces","edges","map","clip_shapes2","outerClip","calculateIntersections","getIntersections","ip_sorted1","ip_sorted2","filterNotRelevantEdges","op","notIntersectedFacesRes","getNotIntersectedFaces","notIntersectedFacesWrk","calcInclusionForNotIntersectedFaces","fixBoundaryConflicts","removeNotRelevantChains","removeNotRelevantNotIntersectedFaces","swapLinksAndRestore","copyWrkToRes","swapLinks","removeOldFaces","restoreFaces","restore","edge1","resp","search","box","edge2","intersect","poly","notIntersected","find","notIntersectedFaces","poly2","poly1","iterate_more","edge_tmp","new_bv","dist","segment","distanceTo","ps","newEdge1","findEdgeByPoint","pe","int_point2_edge_after","newEdge2","is_res_polygon","first_int_point_in_face_num","int_points_from_pull_start","int_points_from_pull_num","next_int_point_num","int_points_to_pull_start","int_points_to_pull_num","edge_from","edge_to","removeChain","k","res_polygon","wrk_polygon","add","addFace","delete","other_int_points","error","int_point_tmp","rel","deleteFace","BooleanOperations","EQUAL","RegExp","INTERSECT","TOUCH","COVERED","DE9IM","m","Array","fill","I2I","geom","I2B","I2E","B2I","B2B","B2E","E2I","E2B","E2E","toString","e","join","equal","test","touch","inside","covered","intersectLine2Line","line1","line2","A1","B1","C1","standard","A2","B2","C2","det","detX","detY","intersectLine2Circle","line","circle","prj","pc","projectionOn","r","delta","sqrt","v_trans","norm","rotate90CCW","multiply","translate","rotate90CW","intersectLine2Box","ips","seg","toSegments","ips_tmp","intersectSegment2Line","ptInIntPoints","intersectLine2Arc","arc","ip_tmp","on","isZeroLength","leftTo","intersectSegment2Segment","seg1","seg2","not_intersect","incidentTo","new_ip","isPointInSegmentBox","point","xmax","xmin","ymax","ymin","intersectSegment2Circle","_","intersectSegment2Arc","intersectSegment2Box","intersectCircle2Circle","circle1","circle2","vec","r1","r2","abs","a","mid_pt","h","intersectCircle2Box","intersectArc2Arc","arc1","arc2","intersectArc2Circle","intersectArc2Box","intersectEdge2Segment","isSegment","intersectEdge2Arc","intersectEdge2Line","intersectEdge2Ray","ray","intersectRay2Segment","intersectRay2Arc","intersectEdge2Circle","intersectSegment2Polygon","intersectArc2Polygon","intersectLine2Polygon","sortPoints","intersectCircle2Polygon","intersectEdge2Edge","isArc","isLine","isRay","intersectEdge2Polygon","resp_edges","resp_edge","intersectPolygon2Polygon","intersectShape2Polygon","new_pt","some","createLineFromRay","contains","intersectRay2Circle","intersectRay2Box","intersectRay2Line","intersectRay2Ray","ray1","ray2","intersectRay2Polygon","defaultAttributes","stroke","SVGAttributes","args","property","toAttributesString","keys","reduce","acc","key","toAttrString","SVGKey","convertCamelToKebabCase","concat","str","match","toLowerCase","convertToString","attrs","every","setArcLength","merge","vertices","v","toShapes","setOneEdgeArcLength","edgeBefore","getChain","edgeFrom","edgeTo","edgeFound","rotate","angle","center","transform","matrix","toJSON","svg","svgStr","multiline","ray_shoot","searchBox","i1","i2","intersection","prev_edge","prev_tangent","tangentInEnd","prev_point","cur_tangent","tangentInStart","cur_point","prev_on_the_left","cur_on_the_left","next_edge","next_tangent","next_point","next_on_the_left","shape1","shape2","relate","disjoint","contain","cover","relateLine2Line","relateLine2Circle","relateLine2Box","relateLine2Polygon","relateShape2Polygon","relatePolygon2Polygon","denim","ip_sorted","splitShapes","toArc","cutWithLine","boolean_intersection","boolean_difference1","boolean_difference2","inner_clip_shapes1","inner_clip_shapes2","outer_clip_shapes1","outer_clip_shapes2","Relations","b","d","tx","ty","vector","other_matrix","isNaN","centerX","centerY","cos","sin","scale","sx","sy","Interval","low","high","max","less_than","other_interval","equal_to","min","output","comparable_max","interval1","interval2","comparable_less_than","val1","val2","RB_TREE_COLOR_RED","RB_TREE_COLOR_BLACK","Node","left","right","parent","color","item","Number","isNil","_value_less_than","other_node","_value_equal","copy_data","update_max","not_intersect_left_subtree","search_node","not_intersect_right_subtree","IntervalTree","root","nil_node","count","tree_walk","res","node","values","items","clear","insert_node","tree_insert","recalc_max","exist","tree_search","delete_node","tree_delete","interval","outputMapperFn","resp_nodes","tree_search_interval","intersect_any","found","tree_find_any_interval","visitor","callback","tree","node_current","current_node","parent_node","insert_fixup","uncle_node","rotate_left","rotate_right","cut_node","fix_node","tree_successor","delete_fixup","brother_node","local_minimum","node_min","local_maximum","node_max","node_successor","action","testRedBlackProperty","testBlackHeightProperty","height","heightLeft","heightRight","PlanarSet","Set","entry","deleted","hit","svgcontent","Shape","name","assign","Point$1","arr","lessThan","cross","dot","proj_vec","onLeftSemiPlane","dx","dy","point2line","point2circle","point2segment","point2arc","point2polygon","shape2planarSet","Vector$1","a1","a2","slope","atan2","scalar","normalize","invert","angleTo","norm1","norm2","n","vector$1","coords","distanceToPoint","shortest_segment","segment2circle","segment2line","segment2segment","segment2arc","shape2polygon","middle","pointAtLength","factor","rest","definiteIntegral","dy1","dy2","pts","Line$1","points2norm","POSITIVE_INFINITY","NEGATIVE_INFINITY","A","B","C","parallelTo","other_line","distance","circle2line","arc2line","sorted_points","pt1","pt2","unit","Circle$1","counterclockwise","circle2circle","arc2circle","startAngle","endAngle","counterClockwise","sweep","p0","func_arcs","breakToFunctional","test_arc","chordHeight","arc2arc","func_arcs_array","angles","test_arcs","prev_arc","new_arc","newStart","newEnd","newCenter","newDirection","arcSE","f_arcs","area","circularSegmentDefiniteIntegral","onLeftSide","areaTrapez","areaCircularSegment","circularSegmentArea","slope1","slope2","largeArcFlag","sweepFlag","width","other_box","box1","box2","toPoints","transformed_points","new_box","vertex","bvMiddle","flag","sign","halfArc1","halfArc2","CircularLinkedList","setCircularLinks","_box","_orientation","segments","points2segments","shapes2face","points","flattenShapes","flattenShape","perimeter","merge_with_next_edge","orientation","signedArea","sArea","isSimple","getSelfIntersections","exitOnFirst","toPolygon","arguments","argsArray","loop","el","loop1","isValid","valid","recreateFaces","unassignedEdgeFound","removeEndVertex","edge_next","cut","newPoly","int_point1_prev","int_point1_curr","newEdges","splitToIslands","polygons","newPolygons","islandPolygon","min_dist_and_segment","min_stop","newPolygon","fillRule","inversion_circle","inversePoint","k2","len2","reflected_point","inverseCircle","s","inverseLine","inverse","inversion","point2point","closest_point","dist2center","shortest_dist","v_seg","v_ps2pt","v_pe2pt","start_sp","end_sp","v_unit","dist_and_segment","dist_tmp","shortest_segment_tmp","dist_from_start","shortest_segment_from_start","dist_from_end","shortest_segment_from_end","dist_from_center","shortest_segment_from_center","dist_from_projection","shortest_segment_from_projection","segment_tmp","polygon2polygon","box2box_minmax","mindist_x","mindist_y","mindist","maxdist","minmax_tree_process_level","level","new_level_left","new_level_right","new_level","minmax_tree","squared_min_stop","minmax_tree_calc_distance","min_dist_and_segment_new","stop","d1","d2","_core","_interopRequireDefault","require","obj","__esModule","polygon4","console","log","boolcall","getNumLayers","path0","path1","layers0","layers1","p","union","radius","path","_loop","layer","points0","points1","polygon0","combinedPolygon","filletedPolygon","fillet","combinedLayerPoints","OVERLAY_ID","OldModule","module","bundle","Module","moduleName","call","hot","data","hotData","_acceptCallbacks","_disposeCallbacks","accept","fn","dispose","checkedAssets","assetsToAccept","isParcelRequire","WebSocket","hostname","location","protocol","ws","onmessage","event","JSON","parse","type","handled","assets","asset","isNew","didAccept","hmrAcceptCheck","global","parcelRequire","generated","js","hmrApply","hmrAcceptRun","reload","close","onclose","removeErrorOverlay","message","stack","overlay","createErrorOverlay","document","body","appendChild","getElementById","createElement","stackTrace","innerText","innerHTML","getParents","modules","parents","dep","isArray","Function","deps","cached","cache","cb"],"mappings":"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","file":"BooleanUnion.93d28fae.js","sourceRoot":"..","sourcesContent":["/**\n * Global constant CCW defines counterclockwise direction of arc\n * @type {boolean}\n */\nconst CCW = true;\n\n/**\n * Global constant CW defines clockwise direction of arc\n * @type {boolean}\n */\nconst CW = false;\n\n/**\n * Defines orientation for face of the polygon: clockwise, counterclockwise\n * or not orientable in the case of self-intersection\n * @type {{CW: number, CCW: number, NOT_ORIENTABLE: number}}\n */\nconst ORIENTATION = {CCW:-1, CW:1, NOT_ORIENTABLE: 0};\n\nconst PIx2 = 2 * Math.PI;\n\nconst INSIDE$2 = 1;\nconst OUTSIDE$1 = 0;\nconst BOUNDARY$1 = 2;\nconst CONTAINS = 3;\nconst INTERLACE = 4;\n\nconst OVERLAP_SAME$1 = 1;\nconst OVERLAP_OPPOSITE$1 = 2;\n\nconst NOT_VERTEX$1 = 0;\nconst START_VERTEX$1 = 1;\nconst END_VERTEX$1 = 2;\n\nvar Constants = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    BOUNDARY: BOUNDARY$1,\n    CCW: CCW,\n    CONTAINS: CONTAINS,\n    CW: CW,\n    END_VERTEX: END_VERTEX$1,\n    INSIDE: INSIDE$2,\n    INTERLACE: INTERLACE,\n    NOT_VERTEX: NOT_VERTEX$1,\n    ORIENTATION: ORIENTATION,\n    OUTSIDE: OUTSIDE$1,\n    OVERLAP_OPPOSITE: OVERLAP_OPPOSITE$1,\n    OVERLAP_SAME: OVERLAP_SAME$1,\n    PIx2: PIx2,\n    START_VERTEX: START_VERTEX$1\n});\n\n/**\n * Created by Alex Bol on 2/18/2017.\n */\n\n/**\n * Floating point comparison tolerance.\n * Default value is 0.000001 (10e-6)\n * @type {number}\n */\nlet DP_TOL = 0.000001;\n\n/**\n * Set new floating point comparison tolerance\n * @param {number} tolerance\n */\nfunction setTolerance(tolerance) {DP_TOL = tolerance;}\n\n/**\n * Get floating point comparison tolerance\n * @returns {number}\n */\nfunction getTolerance() {return DP_TOL;}\n\nconst DECIMALS = 3;\n\n/**\n * Returns *true* if value comparable to zero\n * @param {number} x\n * @param {number} y\n * @return {boolean}\n */\nfunction EQ_0(x) {\n    return (x < DP_TOL && x > -DP_TOL);\n}\n\n/**\n * Returns *true* if two values are equal up to DP_TOL\n * @param {number} x\n * @param {number} y\n * @return {boolean}\n */\nfunction EQ(x, y) {\n    return (x - y < DP_TOL && x - y > -DP_TOL);\n}\n\n/**\n * Returns *true* if first argument greater than second argument up to DP_TOL\n * @param {number} x\n * @param {number} y\n * @return {boolean}\n */\nfunction GT(x, y) {\n    return (x - y > DP_TOL);\n}\n\n/**\n * Returns *true* if first argument greater than or equal to second argument up to DP_TOL\n * @param {number} x\n * @param {number} y\n * @returns {boolean}\n */\nfunction GE(x, y) {\n    return (x - y > -DP_TOL);\n}\n\n/**\n * Returns *true* if first argument less than second argument up to DP_TOL\n * @param {number} x\n * @param {number} y\n * @return {boolean}\n */\nfunction LT(x, y) {\n    return (x - y < -DP_TOL)\n}\n\n/**\n * Returns *true* if first argument less than or equal to second argument up to DP_TOL\n * @param {number} x\n * @param {number} y\n * @return {boolean}\n */\nfunction LE(x, y) {\n    return (x - y < DP_TOL);\n}\n\nvar Utils$1 = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    DECIMALS: DECIMALS,\n    EQ: EQ,\n    EQ_0: EQ_0,\n    GE: GE,\n    GT: GT,\n    LE: LE,\n    LT: LT,\n    getTolerance: getTolerance,\n    setTolerance: setTolerance\n});\n\nlet Flatten = {\n    Utils: Utils$1,\n    Errors: undefined,\n    Matrix: undefined,\n    Planar_set: undefined,\n    Point: undefined,\n    Vector: undefined,\n    Line: undefined,\n    Circle: undefined,\n    Segment: undefined,\n    Arc: undefined,\n    Box: undefined,\n    Edge: undefined,\n    Face: undefined,\n    Ray: undefined,\n    Ray_shooting: undefined,\n    Multiline: undefined,\n    Polygon: undefined,\n    Distance: undefined,\n    Inversion: undefined\n};\n\nfor (let c in Constants) {Flatten[c] = Constants[c];}\n\nObject.defineProperty(Flatten, 'DP_TOL', {\n    get:function(){return getTolerance()}, \n    set:function(value){setTolerance(value);}\n});\n\n/**\n * Created by Alex Bol on 2/19/2017.\n */\n\n\n/**\n * Class of system errors\n */\nclass Errors {\n    /**\n     * Throw error ILLEGAL_PARAMETERS when cannot instantiate from given parameter\n     * @returns {ReferenceError}\n     */\n    static get ILLEGAL_PARAMETERS() {\n        return new ReferenceError('Illegal Parameters');\n    }\n\n    /**\n     * Throw error ZERO_DIVISION to catch situation of zero division\n     * @returns {Error}\n     */\n    static get ZERO_DIVISION() {\n        return new Error('Zero division');\n    }\n\n    /**\n     * Error to throw from BooleanOperations module in case when fixBoundaryConflicts not capable to fix it\n     * @returns {Error}\n     */\n    static get UNRESOLVED_BOUNDARY_CONFLICT() {\n        return new Error('Unresolved boundary conflict in boolean operation');\n    }\n\n    /**\n     * Error to throw from LinkedList:testInfiniteLoop static method\n     * in case when circular loop detected in linked list\n     * @returns {Error}\n     */\n    static get INFINITE_LOOP() {\n        return new Error('Infinite loop');\n    }\n\n    static get CANNOT_COMPLETE_BOOLEAN_OPERATION() {\n        return new Error('Cannot complete boolean operation')\n    }\n\n    static get CANNOT_INVOKE_ABSTRACT_METHOD() {\n        return new Error('Abstract method cannot be invoked');\n    }\n\n    static get OPERATION_IS_NOT_SUPPORTED() {\n        return new Error('Operation is not supported')\n    }\n}\n\nFlatten.Errors = Errors;\n\n/**\n * Class implements bidirectional non-circular linked list. <br/>\n * LinkedListElement - object of any type that has properties next and prev.\n */\nclass LinkedList {\n    constructor(first, last) {\n        this.first = first;\n        this.last = last || this.first;\n    }\n\n    [Symbol.iterator]() {\n        let value = undefined;\n        return {\n            next: () => {\n                value = value ? value.next : this.first;\n                return {value: value, done: value === undefined};\n            }\n        };\n    };\n\n    /**\n     * Return number of elements in the list\n     * @returns {number}\n     */\n    get size() {\n        let counter = 0;\n        for (let edge of this) {\n            counter++;\n        }\n        return counter;\n    }\n\n    /**\n     * Return array of elements from start to end,\n     * If start or end not defined, take first as start, last as end\n     * @returns {Array}\n     */\n    toArray(start=undefined, end=undefined) {\n        let elements = [];\n        let from = start || this.first;\n        let to = end || this.last;\n        let element = from;\n        if (element === undefined) return elements;\n        do {\n            elements.push(element);\n            element = element.next;\n        } while (element !== to.next);\n        return elements;\n    }\n\n\n    /**\n     * Append new element to the end of the list\n     * @param {LinkedListElement} element\n     * @returns {LinkedList}\n     */\n    append(element) {\n        if (this.isEmpty()) {\n            this.first = element;\n        } else {\n            element.prev = this.last;\n            this.last.next = element;\n        }\n\n        // update edge to be last\n        this.last = element;\n\n        // nullify non-circular links\n        this.last.next = undefined;\n        this.first.prev = undefined;\n        return this;\n    }\n\n    /**\n     * Insert new element to the list after elementBefore\n     * @param {LinkedListElement} newElement\n     * @param {LinkedListElement} elementBefore\n     * @returns {LinkedList}\n     */\n    insert(newElement, elementBefore) {\n        if (this.isEmpty()) {\n            this.first = newElement;\n            this.last = newElement;\n        }\n        else if (elementBefore === null || elementBefore === undefined) {\n            newElement.next = this.first;\n            this.first.prev = newElement;\n            this.first = newElement;\n        }\n        else {\n            /* set links to new element */\n            let elementAfter = elementBefore.next;\n            elementBefore.next = newElement;\n            if (elementAfter) elementAfter.prev = newElement;\n\n            /* set links from new element */\n            newElement.prev = elementBefore;\n            newElement.next = elementAfter;\n\n            /* extend list if new element added after the last element */\n            if (this.last === elementBefore)\n                this.last = newElement;\n        }\n        // nullify non-circular links\n        this.last.next = undefined;\n        this.first.prev = undefined;\n        return this;\n    }\n\n    /**\n     * Remove element from the list\n     * @param {LinkedListElement} element\n     * @returns {LinkedList}\n     */\n    remove(element) {\n        // special case if last edge removed\n        if (element === this.first && element === this.last) {\n            this.first = undefined;\n            this.last = undefined;\n        } else {\n            // update linked list\n            if (element.prev) element.prev.next = element.next;\n            if (element.next) element.next.prev = element.prev;\n            // update first if need\n            if (element === this.first) {\n                this.first = element.next;\n            }\n            // update last if need\n            if (element === this.last) {\n                this.last = element.prev;\n            }\n        }\n        return this;\n    }\n\n    /**\n     * Return true if list is empty\n     * @returns {boolean}\n     */\n    isEmpty() {\n        return this.first === undefined;\n    }\n\n    /**\n     * Throw an error if circular loop detected in the linked list\n     * @param {LinkedListElement} first element to start iteration\n     * @throws {Errors.INFINITE_LOOP}\n     */\n    static testInfiniteLoop(first) {\n        let edge = first;\n        let controlEdge = first;\n        do {\n            if (edge != first && edge === controlEdge) {\n                throw Errors.INFINITE_LOOP;  // new Error(\"Infinite loop\")\n            }\n            edge = edge.next;\n            controlEdge = controlEdge.next.next;\n        } while (edge != first)\n    }\n}\n\n/*\n    Smart intersections describe intersection points that refers to the edges they intersect\n    This function are supposed for internal usage by morphing and relation methods between\n */\n\nfunction addToIntPoints(edge, pt, int_points)\n{\n    let id = int_points.length;\n    let shapes = edge.shape.split(pt);\n\n    // if (shapes.length < 2) return;\n    if (shapes.length === 0) return;     // Point does not belong to edge ?\n\n    let len = 0;\n    if (shapes[0] === null) {   // point incident to edge start vertex\n        len = 0;\n    }\n    else if (shapes[1] === null) {   // point incident to edge end vertex\n        len = edge.shape.length;\n    }\n    else {                             // Edge was split into to edges\n        len = shapes[0].length;\n    }\n\n    let is_vertex = NOT_VERTEX$1;\n    if (EQ(len, 0)) {\n        is_vertex |= START_VERTEX$1;\n    }\n    if (EQ(len, edge.shape.length)) {\n        is_vertex |= END_VERTEX$1;\n    }\n    // Fix intersection point which is end point of the last edge\n    let arc_length;\n    if (len === Infinity) {\n        arc_length = shapes[0].coord(pt);\n    }\n    else {\n        arc_length = (is_vertex & END_VERTEX$1) && edge.next && edge.next.arc_length === 0 ?\n            0 :\n            edge.arc_length + len;\n    }\n\n    int_points.push({\n        id: id,\n        pt: pt,\n        arc_length: arc_length,\n        edge_before: edge,\n        edge_after: undefined,\n        face: edge.face,\n        is_vertex: is_vertex\n    });\n}\n\nfunction sortIntersections(intersections)\n{\n    // if (intersections.int_points1.length === 0) return;\n\n    // augment intersections with new sorted arrays\n    // intersections.int_points1_sorted = intersections.int_points1.slice().sort(compareFn);\n    // intersections.int_points2_sorted = intersections.int_points2.slice().sort(compareFn);\n    intersections.int_points1_sorted = getSortedArray(intersections.int_points1);\n    intersections.int_points2_sorted = getSortedArray(intersections.int_points2);\n}\n\nfunction getSortedArray(int_points)\n{\n    let faceMap = new Map;\n    let id = 0;\n    // Create integer id's for faces\n    for (let ip of int_points) {\n        if (!faceMap.has(ip.face)) {\n            faceMap.set(ip.face, id);\n            id++;\n        }\n    }\n    // Augment intersection points with face id's\n    for (let ip of int_points) {\n        ip.faceId = faceMap.get(ip.face);\n    }\n    // Clone and sort\n    let int_points_sorted = int_points.slice().sort(compareFn);\n    return int_points_sorted;\n}\n\nfunction compareFn(ip1, ip2)\n{\n    // compare face id's\n    if (ip1.faceId < ip2.faceId) {\n        return -1;\n    }\n    if (ip1.faceId > ip2.faceId) {\n        return 1;\n    }\n    // same face - compare arc_length\n    if (ip1.arc_length < ip2.arc_length) {\n        return -1;\n    }\n    if (ip1.arc_length > ip2.arc_length) {\n        return 1;\n    }\n    return 0;\n}\n\n// export function getSortedArrayOnLine(line, int_points) {\n//     return int_points.slice().sort( (int_point1, int_point2) => {\n//         if (line.coord(int_point1.pt) < line.coord(int_point2.pt)) {\n//             return -1;\n//         }\n//         if (line.coord(int_point1.pt) > line.coord(int_point2.pt)) {\n//             return 1;\n//         }\n//         return 0;\n//     })\n// }\n\nfunction filterDuplicatedIntersections(intersections)\n{\n    if (intersections.int_points1.length < 2) return;\n\n    let do_squeeze = false;\n\n    let int_point_ref1;\n    let int_point_ref2;\n    let int_point_cur1;\n    let int_point_cur2;\n    for (let i = 0; i < intersections.int_points1_sorted.length; i++) {\n\n        if (intersections.int_points1_sorted[i].id === -1)\n            continue;\n\n        int_point_ref1 = intersections.int_points1_sorted[i];\n        int_point_ref2 = intersections.int_points2[int_point_ref1.id];\n\n        for (let j=i+1; j < intersections.int_points1_sorted.length; j++) {\n            int_point_cur1 = intersections.int_points1_sorted[j];\n            if (!EQ(int_point_cur1.arc_length, int_point_ref1.arc_length)) {\n                break;\n            }\n            if (int_point_cur1.id === -1)\n                continue;\n            int_point_cur2 = intersections.int_points2[int_point_cur1.id];\n            if (int_point_cur2.id === -1)\n                continue;\n            if (int_point_cur1.edge_before === int_point_ref1.edge_before &&\n                int_point_cur1.edge_after === int_point_ref1.edge_after &&\n                int_point_cur2.edge_before === int_point_ref2.edge_before &&\n                int_point_cur2.edge_after === int_point_ref2.edge_after) {\n                int_point_cur1.id = -1;\n                /* to be deleted */\n                int_point_cur2.id = -1;\n                /* to be deleted */\n                do_squeeze = true;\n            }\n        }\n    }\n\n    int_point_ref2 = intersections.int_points2_sorted[0];\n    int_point_ref1 = intersections.int_points1[int_point_ref2.id];\n    for (let i = 1; i < intersections.int_points2_sorted.length; i++) {\n        let int_point_cur2 = intersections.int_points2_sorted[i];\n\n        if (int_point_cur2.id === -1) continue;\n        /* already deleted */\n\n        if (int_point_ref2.id === -1 || /* can't be reference if already deleted */\n            !(EQ(int_point_cur2.arc_length, int_point_ref2.arc_length))) {\n            int_point_ref2 = int_point_cur2;\n            int_point_ref1 = intersections.int_points1[int_point_ref2.id];\n            continue;\n        }\n\n        let int_point_cur1 = intersections.int_points1[int_point_cur2.id];\n        if (int_point_cur1.edge_before === int_point_ref1.edge_before &&\n            int_point_cur1.edge_after === int_point_ref1.edge_after &&\n            int_point_cur2.edge_before === int_point_ref2.edge_before &&\n            int_point_cur2.edge_after === int_point_ref2.edge_after) {\n            int_point_cur1.id = -1;\n            /* to be deleted */\n            int_point_cur2.id = -1;\n            /* to be deleted */\n            do_squeeze = true;\n        }\n    }\n\n    if (do_squeeze) {\n        intersections.int_points1 = intersections.int_points1.filter((int_point) => int_point.id >= 0);\n        intersections.int_points2 = intersections.int_points2.filter((int_point) => int_point.id >= 0);\n\n        // update id's\n        intersections.int_points1.forEach((int_point, index) => int_point.id = index);\n        intersections.int_points2.forEach((int_point, index) => int_point.id = index);\n    }\n}\n\nfunction initializeInclusionFlags(int_points)\n{\n    for (let int_point of int_points) {\n        if (int_point.edge_before) {\n            int_point.edge_before.bvStart = undefined;\n            int_point.edge_before.bvEnd = undefined;\n            int_point.edge_before.bv = undefined;\n            int_point.edge_before.overlap = undefined;\n        }\n\n        if (int_point.edge_after) {\n            int_point.edge_after.bvStart = undefined;\n            int_point.edge_after.bvEnd = undefined;\n            int_point.edge_after.bv = undefined;\n            int_point.edge_after.overlap = undefined;\n        }\n    }\n\n    for (let int_point of int_points) {\n        if (int_point.edge_before) int_point.edge_before.bvEnd = BOUNDARY$1;\n        if (int_point.edge_after) int_point.edge_after.bvStart = BOUNDARY$1;\n    }\n}\n\nfunction calculateInclusionFlags(int_points, polygon)\n{\n    for (let int_point of int_points) {\n        if (int_point.edge_before) int_point.edge_before.setInclusion(polygon);\n        if (int_point.edge_after) int_point.edge_after.setInclusion(polygon);\n    }\n}\n\nfunction setOverlappingFlags(intersections)\n{\n    let cur_face = undefined;\n    let first_int_point_in_face_id = undefined;\n    let next_int_point1 = undefined;\n    let num_int_points = intersections.int_points1.length;\n\n    for (let i = 0; i < num_int_points; i++) {\n        let cur_int_point1 = intersections.int_points1_sorted[i];\n\n        // Find boundary chain in the polygon1\n        if (cur_int_point1.face !== cur_face) {                               // next chain started\n            first_int_point_in_face_id = i; // cur_int_point1;\n            cur_face = cur_int_point1.face;\n        }\n\n        // Skip duplicated points with same <x,y> in \"cur_int_point1\" pool\n        let int_points_cur_pool_start = i;\n        let int_points_cur_pool_num = intPointsPoolCount(intersections.int_points1_sorted, i, cur_face);\n        let next_int_point_id;\n        if (int_points_cur_pool_start + int_points_cur_pool_num < num_int_points &&\n            intersections.int_points1_sorted[int_points_cur_pool_start + int_points_cur_pool_num].face === cur_face) {\n            next_int_point_id = int_points_cur_pool_start + int_points_cur_pool_num;\n        } else {                                         // get first point from the same face\n            next_int_point_id = first_int_point_in_face_id;\n        }\n\n        // From all points with same ,x,y. in 'next_int_point1' pool choose one that\n        // has same face both in res_poly and in wrk_poly\n        let int_points_next_pool_num = intPointsPoolCount(intersections.int_points1_sorted, next_int_point_id, cur_face);\n        next_int_point1 = null;\n        for (let j=next_int_point_id; j < next_int_point_id + int_points_next_pool_num; j++) {\n            let next_int_point1_tmp = intersections.int_points1_sorted[j];\n            if (next_int_point1_tmp.face === cur_face &&\n                intersections.int_points2[next_int_point1_tmp.id].face === intersections.int_points2[cur_int_point1.id].face) {\n                next_int_point1 = next_int_point1_tmp;\n                break;\n            }\n        }\n        if (next_int_point1 === null)\n            continue;\n\n        let edge_from1 = cur_int_point1.edge_after;\n        let edge_to1 = next_int_point1.edge_before;\n\n        if (!(edge_from1.bv === BOUNDARY$1 && edge_to1.bv === BOUNDARY$1))      // not a boundary chain - skip\n            continue;\n\n        if (edge_from1 !== edge_to1)                    //  one edge chain    TODO: support complex case\n            continue;\n\n        /* Find boundary chain in polygon2 between same intersection points */\n        let cur_int_point2 = intersections.int_points2[cur_int_point1.id];\n        let next_int_point2 = intersections.int_points2[next_int_point1.id];\n\n        let edge_from2 = cur_int_point2.edge_after;\n        let edge_to2 = next_int_point2.edge_before;\n\n        /* if [edge_from2..edge_to2] is not a boundary chain, invert it */\n        /* check also that chain consist of one or two edges */\n        if (!(edge_from2.bv === BOUNDARY$1 && edge_to2.bv === BOUNDARY$1 && edge_from2 === edge_to2)) {\n            cur_int_point2 = intersections.int_points2[next_int_point1.id];\n            next_int_point2 = intersections.int_points2[cur_int_point1.id];\n\n            edge_from2 = cur_int_point2.edge_after;\n            edge_to2 = next_int_point2.edge_before;\n        }\n\n        if (!(edge_from2.bv === BOUNDARY$1 && edge_to2.bv === BOUNDARY$1 && edge_from2 === edge_to2))\n            continue;                           // not an overlapping chain - skip   TODO: fix boundary conflict\n\n        // Set overlapping flag - one-to-one case\n        edge_from1.setOverlap(edge_from2);\n    }\n}\n\nfunction intPointsPoolCount(int_points, cur_int_point_num, cur_face)\n{\n    let int_point_current;\n    let int_point_next;\n\n    let int_points_pool_num = 1;\n\n    if (int_points.length === 1) return 1;\n\n    int_point_current = int_points[cur_int_point_num];\n\n    for (let i = cur_int_point_num + 1; i < int_points.length; i++) {\n        if (int_point_current.face !== cur_face) {      /* next face started */\n            break;\n        }\n\n        int_point_next = int_points[i];\n\n        if (!(int_point_next.pt.equalTo(int_point_current.pt) &&\n            int_point_next.edge_before === int_point_current.edge_before &&\n            int_point_next.edge_after === int_point_current.edge_after)) {\n            break;         /* next point is different - break and exit */\n        }\n\n        int_points_pool_num++;     /* duplicated intersection point - increase counter */\n    }\n    return int_points_pool_num;\n}\n\nfunction splitByIntersections(polygon, int_points)\n{\n    if (!int_points) return;\n    for (let int_point of int_points) {\n        let edge = int_point.edge_before;\n\n        // recalculate vertex flag: it may be changed after previous split\n        int_point.is_vertex = NOT_VERTEX$1;\n        if (edge.shape.start && edge.shape.start.equalTo(int_point.pt)) {\n            int_point.is_vertex |= START_VERTEX$1;\n        }\n        if (edge.shape.end && edge.shape.end.equalTo(int_point.pt)) {\n            int_point.is_vertex |= END_VERTEX$1;\n        }\n\n        if (int_point.is_vertex & START_VERTEX$1) {  // nothing to split\n            if (edge.prev) {\n                int_point.edge_before = edge.prev;           // polygon\n                int_point.is_vertex = END_VERTEX$1;\n            }\n            else {                                           // multiline start vertex\n                int_point.edge_after = int_point.edge_before;\n                int_point.edge_before = edge.prev;\n            }\n            continue;\n        }\n        if (int_point.is_vertex & END_VERTEX$1) {    // nothing to split\n            continue;\n        }\n\n        let newEdge = polygon.addVertex(int_point.pt, edge);\n        int_point.edge_before = newEdge;\n    }\n\n    for (let int_point of int_points) {\n        if (int_point.edge_before) {\n            int_point.edge_after = int_point.edge_before.next;\n        }\n    }\n}\n\nfunction insertBetweenIntPoints(int_point1, int_point2, new_edges) {\n    const edge_before = int_point1.edge_before;\n    const edge_after = int_point2.edge_after;\n    const len = new_edges.length;\n    edge_before.next = new_edges[0];\n    new_edges[0].prev = edge_before;\n\n    new_edges[len-1].next = edge_after;\n    edge_after.prev = new_edges[len-1];\n}\n\nvar smart_intersections = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    addToIntPoints: addToIntPoints,\n    calculateInclusionFlags: calculateInclusionFlags,\n    filterDuplicatedIntersections: filterDuplicatedIntersections,\n    getSortedArray: getSortedArray,\n    initializeInclusionFlags: initializeInclusionFlags,\n    insertBetweenIntPoints: insertBetweenIntPoints,\n    intPointsPoolCount: intPointsPoolCount,\n    setOverlappingFlags: setOverlappingFlags,\n    sortIntersections: sortIntersections,\n    splitByIntersections: splitByIntersections\n});\n\n/**\n * Created by Alex Bol on 12/02/2018.\n */\n/**\n * @module BooleanOperations\n */\n\nconst {INSIDE: INSIDE$1, OUTSIDE, BOUNDARY, OVERLAP_SAME, OVERLAP_OPPOSITE} = Constants;\nconst {NOT_VERTEX, START_VERTEX, END_VERTEX} = Constants;\n\nconst BOOLEAN_UNION = 1;\nconst BOOLEAN_INTERSECT = 2;\nconst BOOLEAN_SUBTRACT = 3;\n\n\n/**\n * Unify two polygons polygons and returns new polygon. <br/>\n * Point belongs to the resulted polygon if it belongs to the first OR to the second polygon\n * @param {Polygon} polygon1 - first operand\n * @param {Polygon} polygon2 - second operand\n * @returns {Polygon}\n */\nfunction unify(polygon1, polygon2) {\n    let [res_poly, wrk_poly] = booleanOpBinary(polygon1, polygon2, BOOLEAN_UNION, true);\n    return res_poly;\n}\n\n/**\n * Subtract second polygon from the first and returns new polygon\n * Point belongs to the resulted polygon if it belongs to the first polygon AND NOT to the second polygon\n * @param {Polygon} polygon1 - first operand\n * @param {Polygon} polygon2 - second operand\n * @returns {Polygon}\n */\nfunction subtract(polygon1, polygon2) {\n    let polygon2_tmp = polygon2.clone();\n    let polygon2_reversed = polygon2_tmp.reverse();\n    let [res_poly, wrk_poly] = booleanOpBinary(polygon1, polygon2_reversed, BOOLEAN_SUBTRACT, true);\n    return res_poly;\n}\n\n/**\n * Intersect two polygons and returns new polygon\n * Point belongs to the resulted polygon is it belongs to the first AND to the second polygon\n * @param {Polygon} polygon1 - first operand\n * @param {Polygon} polygon2 - second operand\n * @returns {Polygon}\n */\nfunction intersect$1(polygon1, polygon2) {\n    let [res_poly, wrk_poly] = booleanOpBinary(polygon1, polygon2, BOOLEAN_INTERSECT, true);\n    return res_poly;\n}\n\n/**\n * Returns boundary of intersection between two polygons as two arrays of shapes (Segments/Arcs) <br/>\n * The first array are shapes from the first polygon, the second array are shapes from the second\n * @param {Polygon} polygon1 - first operand\n * @param {Polygon} polygon2 - second operand\n * @returns {Shape[][]}\n */\nfunction innerClip(polygon1, polygon2) {\n    let [res_poly, wrk_poly] = booleanOpBinary(polygon1, polygon2, BOOLEAN_INTERSECT, false);\n\n    let clip_shapes1 = [];\n    for (let face of res_poly.faces) {\n        clip_shapes1 = [...clip_shapes1, ...[...face.edges].map(edge => edge.shape)];\n    }\n    let clip_shapes2 = [];\n    for (let face of wrk_poly.faces) {\n        clip_shapes2 = [...clip_shapes2, ...[...face.edges].map(edge => edge.shape)];\n    }\n    return [clip_shapes1, clip_shapes2];\n}\n\n/**\n * Returns boundary of subtraction of the second polygon from first polygon as array of shapes\n * @param {Polygon} polygon1 - first operand\n * @param {Polygon} polygon2 - second operand\n * @returns {Shape[]}\n */\nfunction outerClip(polygon1, polygon2) {\n    let [res_poly, wrk_poly] = booleanOpBinary(polygon1, polygon2, BOOLEAN_SUBTRACT, false);\n\n    let clip_shapes1 = [];\n    for (let face of res_poly.faces) {\n        clip_shapes1 = [...clip_shapes1, ...[...face.edges].map(edge => edge.shape)];\n    }\n\n    return clip_shapes1;\n}\n\n/**\n * Returns intersection points between boundaries of two polygons as two array of points <br/>\n * Points in the first array belong to first polygon, points from the second - to the second.\n * Points in each array are ordered according to the direction of the correspondent polygon\n * @param {Polygon} polygon1 - first operand\n * @param {Polygon} polygon2 - second operand\n * @returns {Point[][]}\n */\nfunction calculateIntersections(polygon1, polygon2) {\n    let res_poly = polygon1.clone();\n    let wrk_poly = polygon2.clone();\n\n    // get intersection points\n    let intersections = getIntersections(res_poly, wrk_poly);\n\n    // sort intersection points\n    sortIntersections(intersections);\n\n    // split by intersection points\n    splitByIntersections(res_poly, intersections.int_points1_sorted);\n    splitByIntersections(wrk_poly, intersections.int_points2_sorted);\n\n    // filter duplicated intersection points\n    filterDuplicatedIntersections(intersections);\n\n    // sort intersection points again after filtering\n    sortIntersections(intersections);\n\n    let ip_sorted1 = intersections.int_points1_sorted.map( int_point => int_point.pt);\n    let ip_sorted2 = intersections.int_points2_sorted.map( int_point => int_point.pt);\n    return [ip_sorted1, ip_sorted2];\n}\n\nfunction filterNotRelevantEdges(res_poly, wrk_poly, intersections, op) {\n    // keep not intersected faces for further remove and merge\n    let notIntersectedFacesRes = getNotIntersectedFaces(res_poly, intersections.int_points1);\n    let notIntersectedFacesWrk = getNotIntersectedFaces(wrk_poly, intersections.int_points2);\n\n    // calculate inclusion flag for not intersected faces\n    calcInclusionForNotIntersectedFaces(notIntersectedFacesRes, wrk_poly);\n    calcInclusionForNotIntersectedFaces(notIntersectedFacesWrk, res_poly);\n\n    // initialize inclusion flags for edges incident to intersections\n    initializeInclusionFlags(intersections.int_points1);\n    initializeInclusionFlags(intersections.int_points2);\n\n    // calculate inclusion flags only for edges incident to intersections\n    calculateInclusionFlags(intersections.int_points1, wrk_poly);\n    calculateInclusionFlags(intersections.int_points2, res_poly);\n\n    // fix boundary conflicts\n    while (fixBoundaryConflicts(res_poly, wrk_poly, intersections.int_points1, intersections.int_points1_sorted, intersections.int_points2, intersections));\n    // while (fixBoundaryConflicts(wrk_poly, res_poly, intersections.int_points2, intersections.int_points2_sorted, intersections.int_points1, intersections));\n\n    // Set overlapping flags for boundary chains: SAME or OPPOSITE\n    setOverlappingFlags(intersections);\n\n    // remove not relevant chains between intersection points\n    removeNotRelevantChains(res_poly, op, intersections.int_points1_sorted, true);\n    removeNotRelevantChains(wrk_poly, op, intersections.int_points2_sorted, false);\n\n    // remove not relevant not intersected faces from res_polygon and wrk_polygon\n    // if op == UNION, remove faces that are included in wrk_polygon without intersection\n    // if op == INTERSECT, remove faces that are not included into wrk_polygon\n    removeNotRelevantNotIntersectedFaces(res_poly, notIntersectedFacesRes, op, true);\n    removeNotRelevantNotIntersectedFaces(wrk_poly, notIntersectedFacesWrk, op, false);\n}\n\nfunction swapLinksAndRestore(res_poly, wrk_poly, intersections, op) {\n\n    // add edges of wrk_poly into the edge container of res_poly\n    copyWrkToRes(res_poly, wrk_poly, op, intersections.int_points2);\n\n    // swap links from res_poly to wrk_poly and vice versa\n    swapLinks(res_poly, wrk_poly, intersections);\n\n    // remove old faces\n    removeOldFaces(res_poly, intersections.int_points1);\n    removeOldFaces(wrk_poly, intersections.int_points2);\n\n    // restore faces\n    restoreFaces(res_poly, intersections.int_points1, intersections.int_points2);\n    restoreFaces(res_poly, intersections.int_points2, intersections.int_points1);\n\n    // merge relevant not intersected faces from wrk_polygon to res_polygon\n    // mergeRelevantNotIntersectedFaces(res_poly, wrk_poly);\n}\n\n\nfunction booleanOpBinary(polygon1, polygon2, op, restore)\n{\n    let res_poly = polygon1.clone();\n    let wrk_poly = polygon2.clone();\n\n    // get intersection points\n    let intersections = getIntersections(res_poly, wrk_poly);\n\n    // sort intersection points\n    sortIntersections(intersections);\n\n    // split by intersection points\n    splitByIntersections(res_poly, intersections.int_points1_sorted);\n    splitByIntersections(wrk_poly, intersections.int_points2_sorted);\n\n    // filter duplicated intersection points\n    filterDuplicatedIntersections(intersections);\n\n    // sort intersection points again after filtering\n    sortIntersections(intersections);\n\n    // calculate inclusion and remove not relevant edges\n    filterNotRelevantEdges(res_poly, wrk_poly, intersections, op);\n\n    if (restore) {\n        swapLinksAndRestore(res_poly, wrk_poly, intersections, op);\n    }\n\n    return [res_poly, wrk_poly];\n}\n\nfunction getIntersections(polygon1, polygon2)\n{\n    let intersections = {\n        int_points1: [],\n        int_points2: []\n    };\n\n    // calculate intersections\n    for (let edge1 of polygon1.edges) {\n\n        // request edges of polygon2 in the box of edge1\n        let resp = polygon2.edges.search(edge1.box);\n\n        // for each edge2 in response\n        for (let edge2 of resp) {\n\n            // calculate intersections between edge1 and edge2\n            let ip = edge1.shape.intersect(edge2.shape);\n\n            // for each intersection point\n            for (let pt of ip) {\n                addToIntPoints(edge1, pt, intersections.int_points1);\n                addToIntPoints(edge2, pt, intersections.int_points2);\n            }\n        }\n    }\n    return intersections;\n}\n\nfunction getNotIntersectedFaces(poly, int_points)\n{\n    let notIntersected = [];\n    for (let face of poly.faces) {\n        if (!int_points.find((ip) => ip.face === face)) {\n            notIntersected.push(face);\n        }\n    }\n    return notIntersected;\n}\n\nfunction calcInclusionForNotIntersectedFaces(notIntersectedFaces, poly2)\n{\n    for (let face of notIntersectedFaces) {\n        face.first.bv = face.first.bvStart = face.first.bvEnd = undefined;\n        face.first.setInclusion(poly2);\n    }\n}\n\nfunction fixBoundaryConflicts(poly1, poly2, int_points1, int_points1_sorted, int_points2, intersections )\n{\n    let cur_face;\n    let first_int_point_in_face_id;\n    let next_int_point1;\n    let num_int_points = int_points1_sorted.length;\n    let iterate_more = false;\n\n    for (let i = 0; i < num_int_points; i++) {\n        let cur_int_point1 = int_points1_sorted[i];\n\n        // Find boundary chain in the polygon1\n        if (cur_int_point1.face !== cur_face) {                               // next chain started\n            first_int_point_in_face_id = i; // cur_int_point1;\n            cur_face = cur_int_point1.face;\n        }\n\n        // Skip duplicated points with same <x,y> in \"cur_int_point1\" pool\n        let int_points_cur_pool_start = i;\n        let int_points_cur_pool_num = intPointsPoolCount(int_points1_sorted, i, cur_face);\n        let next_int_point_id;\n        if (int_points_cur_pool_start + int_points_cur_pool_num < num_int_points &&\n            int_points1_sorted[int_points_cur_pool_start + int_points_cur_pool_num].face === cur_face) {\n            next_int_point_id = int_points_cur_pool_start + int_points_cur_pool_num;\n        } else {                                         // get first point from the same face\n            next_int_point_id = first_int_point_in_face_id;\n        }\n\n        // From all points with same ,x,y. in 'next_int_point1' pool choose one that\n        // has same face both in res_poly and in wrk_poly\n        let int_points_next_pool_num = intPointsPoolCount(int_points1_sorted, next_int_point_id, cur_face);\n        next_int_point1 = null;\n        for (let j=next_int_point_id; j < next_int_point_id + int_points_next_pool_num; j++) {\n            let next_int_point1_tmp = int_points1_sorted[j];\n            if (next_int_point1_tmp.face === cur_face &&\n                int_points2[next_int_point1_tmp.id].face === int_points2[cur_int_point1.id].face) {\n                next_int_point1 = next_int_point1_tmp;\n                break;\n            }\n        }\n        if (next_int_point1 === null)\n            continue;\n\n        let edge_from1 = cur_int_point1.edge_after;\n        let edge_to1 = next_int_point1.edge_before;\n\n        // Case #1. One of the ends is not boundary - probably tiny edge wrongly marked as boundary\n        if (edge_from1.bv === BOUNDARY && edge_to1.bv != BOUNDARY) {\n            edge_from1.bv = edge_to1.bv;\n            continue;\n        }\n\n        if (edge_from1.bv != BOUNDARY && edge_to1.bv === BOUNDARY) {\n            edge_to1.bv = edge_from1.bv;\n            continue;\n        }\n\n        // Set up all boundary values for middle edges. Need for cases 2 and 3\n        if ( (edge_from1.bv === BOUNDARY && edge_to1.bv === BOUNDARY && edge_from1 != edge_to1) ||\n        (edge_from1.bv === INSIDE$1 && edge_to1.bv === OUTSIDE  || edge_from1.bv === OUTSIDE && edge_to1.bv === INSIDE$1 ) ) {\n            let edge_tmp = edge_from1.next;\n            while (edge_tmp != edge_to1) {\n                edge_tmp.bvStart = undefined;\n                edge_tmp.bvEnd = undefined;\n                edge_tmp.bv = undefined;\n                edge_tmp.setInclusion(poly2);\n                edge_tmp = edge_tmp.next;\n            }\n        }\n\n        // Case #2. Both of the ends boundary. Check all the edges in the middle\n        // If some edges in the middle are not boundary then update bv of 'from' and 'to' edges\n        if (edge_from1.bv === BOUNDARY && edge_to1.bv === BOUNDARY && edge_from1 != edge_to1) {\n            let edge_tmp = edge_from1.next;\n            let new_bv;\n            while (edge_tmp != edge_to1) {\n                if (edge_tmp.bv != BOUNDARY) {\n                    if (new_bv === undefined) {        // first not boundary edge between from and to\n                        new_bv = edge_tmp.bv;\n                    }\n                    else {                            // another not boundary edge between from and to\n                        if (edge_tmp.bv != new_bv) {  // and it has different bv - can't resolve conflict\n                            throw Errors.UNRESOLVED_BOUNDARY_CONFLICT;\n                        }\n                    }\n                }\n                edge_tmp = edge_tmp.next;\n            }\n\n            if (new_bv != undefined) {\n                edge_from1.bv = new_bv;\n                edge_to1.bv = new_bv;\n            }\n            continue;         // all middle edges are boundary, proceed with this\n        }\n\n        // Case 3. One of the ends is inner, another is outer\n        if (edge_from1.bv === INSIDE$1 && edge_to1.bv === OUTSIDE  || edge_from1.bv === OUTSIDE && edge_to1.bv === INSIDE$1 ) {\n            let edge_tmp = edge_from1;\n            // Find missing intersection point\n            while (edge_tmp != edge_to1) {\n                if (edge_tmp.bvStart === edge_from1.bv && edge_tmp.bvEnd === edge_to1.bv) {\n                    let [dist, segment] = edge_tmp.shape.distanceTo(poly2);\n                    if (dist < 10*Flatten.DP_TOL) {  // it should be very close\n                        // let pt = edge_tmp.end;\n                        // add to the list of intersections of poly1\n                        addToIntPoints(edge_tmp, segment.ps, int_points1);\n\n                        // split edge_tmp in poly1 if need\n                        let int_point1 = int_points1[int_points1.length-1];\n                        if (int_point1.is_vertex & START_VERTEX) {        // nothing to split\n                            int_point1.edge_after = edge_tmp;\n                            int_point1.edge_before = edge_tmp.prev;\n                            edge_tmp.bvStart = BOUNDARY;\n                            edge_tmp.bv = undefined;\n                            edge_tmp.setInclusion(poly2);\n                        }\n                        else if (int_point1.is_vertex & END_VERTEX) {    // nothing to split\n                            int_point1.edge_after = edge_tmp.next;\n                            edge_tmp.bvEnd = BOUNDARY;\n                            edge_tmp.bv = undefined;\n                            edge_tmp.setInclusion(poly2);\n                        }\n                        else {        // split edge here\n                            let newEdge1 = poly2.addVertex(int_point1.pt, edge_tmp);\n                            int_point1.edge_before = newEdge1;\n                            int_point1.edge_after = newEdge1.next;\n\n                            newEdge1.setInclusion(poly2);\n\n                            newEdge1.next.bvStart = BOUNDARY;\n                            newEdge1.next.bvEnd = undefined;\n                            newEdge1.next.bv = undefined;\n                            newEdge1.next.setInclusion(poly2);\n                        }\n\n                        // add to the list of intersections of poly2\n                        let edge2 = poly2.findEdgeByPoint(segment.pe);\n                        addToIntPoints(edge2, segment.pe, int_points2);\n                        // split edge2 in poly2 if need\n                        let int_point2 = int_points2[int_points2.length-1];\n                        if (int_point2.is_vertex & START_VERTEX) {        // nothing to split\n                            int_point2.edge_after = edge2;\n                            int_point2.edge_before = edge2.prev;\n                        }\n                        else if (int_point2.is_vertex & END_VERTEX) {    // nothing to split\n                            int_point2.edge_after = edge2.next;\n                        }\n                        else {        // split edge here\n                            // first locate int_points that may refer to edge2 as edge.after\n                            // let int_point2_edge_before = int_points2.find( int_point => int_point.edge_before === edge2)\n                            let int_point2_edge_after = int_points2.find( int_point => int_point.edge_after === edge2 );\n\n                            let newEdge2 = poly2.addVertex(int_point2.pt, edge2);\n                            int_point2.edge_before = newEdge2;\n                            int_point2.edge_after = newEdge2.next;\n\n                            if (int_point2_edge_after)\n                                int_point2_edge_after.edge_after = newEdge2;\n\n                            newEdge2.bvStart = undefined;\n                            newEdge2.bvEnd = BOUNDARY;\n                            newEdge2.bv = undefined;\n                            newEdge2.setInclusion(poly1);\n\n                            newEdge2.next.bvStart = BOUNDARY;\n                            newEdge2.next.bvEnd = undefined;\n                            newEdge2.next.bv = undefined;\n                            newEdge2.next.setInclusion(poly1);\n                        }\n\n                        sortIntersections(intersections);\n\n                        iterate_more = true;\n                        break;\n                    }\n                }\n                edge_tmp = edge_tmp.next;\n            }\n\n            // we changed intersections inside loop, have to exit and repair again\n            if (iterate_more)\n                break;\n\n            throw Errors.UNRESOLVED_BOUNDARY_CONFLICT;\n        }\n    }\n\n    return iterate_more;\n}\n\nfunction removeNotRelevantChains(polygon, op, int_points, is_res_polygon)\n{\n    if (!int_points) return;\n    let cur_face = undefined;\n    let first_int_point_in_face_num = undefined;\n    let int_point_current;\n    let int_point_next;\n\n    for (let i = 0; i < int_points.length; i++) {\n        int_point_current = int_points[i];\n\n        if (int_point_current.face !== cur_face) {   // next face started\n            first_int_point_in_face_num = i;\n            cur_face = int_point_current.face;\n        }\n\n        if (cur_face.isEmpty())                // ??\n            continue;\n\n        // Get next int point from the same face that current\n\n        // Count how many duplicated points with same <x,y> in \"points from\" pool ?\n        let int_points_from_pull_start = i;\n        let int_points_from_pull_num = intPointsPoolCount(int_points, i, cur_face);\n        let next_int_point_num;\n        if (int_points_from_pull_start + int_points_from_pull_num < int_points.length &&\n            int_points[int_points_from_pull_start + int_points_from_pull_num].face === int_point_current.face) {\n            next_int_point_num = int_points_from_pull_start + int_points_from_pull_num;\n        } else {                                         // get first point from the same face\n            next_int_point_num = first_int_point_in_face_num;\n        }\n        int_point_next = int_points[next_int_point_num];\n\n        /* Count how many duplicated points with same <x,y> in \"points to\" pull ? */\n        let int_points_to_pull_start = next_int_point_num;\n        let int_points_to_pull_num = intPointsPoolCount(int_points, int_points_to_pull_start, cur_face);\n\n\n        let edge_from = int_point_current.edge_after;\n        let edge_to = int_point_next.edge_before;\n\n        if ((edge_from.bv === INSIDE$1 && edge_to.bv === INSIDE$1 && op === BOOLEAN_UNION) ||\n            (edge_from.bv === OUTSIDE && edge_to.bv === OUTSIDE && op === BOOLEAN_INTERSECT) ||\n            ((edge_from.bv === OUTSIDE || edge_to.bv === OUTSIDE) && op === BOOLEAN_SUBTRACT && !is_res_polygon) ||\n            ((edge_from.bv === INSIDE$1 || edge_to.bv === INSIDE$1) && op === BOOLEAN_SUBTRACT && is_res_polygon) ||\n            (edge_from.bv === BOUNDARY && edge_to.bv === BOUNDARY && (edge_from.overlap & OVERLAP_SAME) && is_res_polygon) ||\n            (edge_from.bv === BOUNDARY && edge_to.bv === BOUNDARY && (edge_from.overlap & OVERLAP_OPPOSITE))) {\n\n            polygon.removeChain(cur_face, edge_from, edge_to);\n\n            /* update all points in \"points from\" pull */\n            for (let k = int_points_from_pull_start; k < int_points_from_pull_start + int_points_from_pull_num; k++) {\n                int_points[k].edge_after = undefined;\n            }\n\n            /* update all points in \"points to\" pull */\n            for (let k = int_points_to_pull_start; k < int_points_to_pull_start + int_points_to_pull_num; k++) {\n                int_points[k].edge_before = undefined;\n            }\n        }\n\n        /* skip to the last point in \"points from\" group */\n        i += int_points_from_pull_num - 1;\n    }\n}\nfunction copyWrkToRes(res_polygon, wrk_polygon, op, int_points)\n{\n    for (let face of wrk_polygon.faces) {\n        for (let edge of face) {\n            res_polygon.edges.add(edge);\n        }\n        // If union - add face from wrk_polygon that is not intersected with res_polygon\n        if ( /*(op === BOOLEAN_UNION || op == BOOLEAN_SUBTRACT) &&*/\n            int_points.find((ip) => (ip.face === face)) === undefined) {\n            res_polygon.addFace(face.first, face.last);\n        }\n    }\n}\n\nfunction swapLinks(res_polygon, wrk_polygon, intersections)\n{\n    if (intersections.int_points1.length === 0) return;\n\n    for (let i = 0; i < intersections.int_points1.length; i++) {\n        let int_point1 = intersections.int_points1[i];\n        let int_point2 = intersections.int_points2[i];\n\n        // Simple case - find continuation on the other polygon\n\n        // Process edge from res_polygon\n        if (int_point1.edge_before !== undefined && int_point1.edge_after === undefined) {    // swap need\n            if (int_point2.edge_before === undefined && int_point2.edge_after !== undefined) {  // simple case\n                // Connect edges\n                int_point1.edge_before.next = int_point2.edge_after;\n                int_point2.edge_after.prev = int_point1.edge_before;\n\n                // Fill in missed links in intersection points\n                int_point1.edge_after = int_point2.edge_after;\n                int_point2.edge_before = int_point1.edge_before;\n            }\n        }\n        // Process edge from wrk_polygon\n        if (int_point2.edge_before !== undefined && int_point2.edge_after === undefined) {    // swap need\n            if (int_point1.edge_before === undefined && int_point1.edge_after !== undefined) {  // simple case\n                // Connect edges\n                int_point2.edge_before.next = int_point1.edge_after;\n                int_point1.edge_after.prev = int_point2.edge_before;\n\n                // Complete missed links\n                int_point2.edge_after = int_point1.edge_after;\n                int_point1.edge_before = int_point2.edge_before;\n            }\n        }\n\n        // Continuation not found - complex case\n        // Continuation will be found on the same polygon.\n        // It happens when intersection point is actually touching point\n        // Polygon1\n        if (int_point1.edge_before !== undefined && int_point1.edge_after === undefined) {    // still swap need\n            for (let int_point of intersections.int_points1_sorted) {\n                if (int_point === int_point1) continue;     // skip same\n                if (int_point.edge_before === undefined && int_point.edge_after !== undefined) {\n                    if (int_point.pt.equalTo(int_point1.pt)) {\n                        // Connect edges\n                        int_point1.edge_before.next = int_point.edge_after;\n                        int_point.edge_after.prev = int_point1.edge_before;\n\n                        // Complete missed links\n                        int_point1.edge_after = int_point.edge_after;\n                        int_point.edge_before = int_point1.edge_before;\n                    }\n                }\n            }\n        }\n        // Polygon2\n        if (int_point2.edge_before !== undefined && int_point2.edge_after === undefined) {    // still swap need\n            for (let int_point of intersections.int_points2_sorted) {\n                if (int_point === int_point2) continue;     // skip same\n                if (int_point.edge_before === undefined && int_point.edge_after !== undefined) {\n                    if (int_point.pt.equalTo(int_point2.pt)) {\n                        // Connect edges\n                        int_point2.edge_before.next = int_point.edge_after;\n                        int_point.edge_after.prev = int_point2.edge_before;\n\n                        // Complete missed links\n                        int_point2.edge_after = int_point.edge_after;\n                        int_point.edge_before = int_point2.edge_before;\n                    }\n                }\n            }\n        }\n    }\n    // Sanity check that no dead ends left\n}\n\nfunction removeOldFaces(polygon, int_points)\n{\n    for (let int_point of int_points) {\n        polygon.faces.delete(int_point.face);\n        int_point.face = undefined;\n        if (int_point.edge_before)\n            int_point.edge_before.face = undefined;\n        if (int_point.edge_after)\n            int_point.edge_after.face = undefined;\n    }\n}\n\nfunction restoreFaces(polygon, int_points, other_int_points)\n{\n    // For each intersection point - create new face\n    for (let int_point of int_points) {\n        if (int_point.edge_before === undefined || int_point.edge_after === undefined)  // completely deleted\n            continue;\n        if (int_point.face)            // already restored\n            continue;\n\n        if (int_point.edge_after.face || int_point.edge_before.face)        // Face already created. Possible case in duplicated intersection points\n            continue;\n\n        let first = int_point.edge_after;      // face start\n        let last = int_point.edge_before;      // face end;\n\n        try {\n            LinkedList.testInfiniteLoop(first);    // check and throw error if infinite loop found\n        }\n        catch (error) {\n            throw Errors.CANNOT_COMPLETE_BOOLEAN_OPERATION\n        }\n\n        let face = polygon.addFace(first, last);\n\n        // Mark intersection points from the newly create face\n        // to avoid multiple creation of the same face.\n        // Face was assigned to each edge of new face in addFace function\n        for (let int_point_tmp of int_points) {\n            if (int_point_tmp.edge_before && int_point_tmp.edge_after &&\n                int_point_tmp.edge_before.face === face && int_point_tmp.edge_after.face === face) {\n                int_point_tmp.face = face;\n            }\n        }\n        // Mark other intersection points as well\n        for (let int_point_tmp of other_int_points) {\n            if (int_point_tmp.edge_before && int_point_tmp.edge_after &&\n                int_point_tmp.edge_before.face === face && int_point_tmp.edge_after.face === face) {\n                int_point_tmp.face = face;\n            }\n        }\n    }\n}\n\nfunction removeNotRelevantNotIntersectedFaces(polygon, notIntersectedFaces, op, is_res_polygon)\n{\n    for (let face of notIntersectedFaces) {\n        let rel = face.first.bv;\n        if (op === BOOLEAN_UNION && rel === INSIDE$1 ||\n            op === BOOLEAN_SUBTRACT && rel === INSIDE$1 && is_res_polygon ||\n            op === BOOLEAN_SUBTRACT && rel === OUTSIDE && !is_res_polygon ||\n            op === BOOLEAN_INTERSECT && rel === OUTSIDE) {\n\n            polygon.deleteFace(face);\n        }\n    }\n}\n\nvar BooleanOperations = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    BOOLEAN_INTERSECT: BOOLEAN_INTERSECT,\n    BOOLEAN_SUBTRACT: BOOLEAN_SUBTRACT,\n    BOOLEAN_UNION: BOOLEAN_UNION,\n    calculateIntersections: calculateIntersections,\n    innerClip: innerClip,\n    intersect: intersect$1,\n    outerClip: outerClip,\n    removeNotRelevantChains: removeNotRelevantChains,\n    removeOldFaces: removeOldFaces,\n    restoreFaces: restoreFaces,\n    subtract: subtract,\n    unify: unify\n});\n\n/*\n    Dimensionally extended 9-intersected model\n    See https://en.wikipedia.org/wiki/DE-9IM for more details\n */\n// const DISJOINT = RegExp('FF.FF....');\nconst EQUAL = RegExp('T.F..FFF.|T.F...F..');\nconst INTERSECT = RegExp('T........|.T.......|...T.....|....T....');\nconst TOUCH = RegExp('FT.......|F..T.....|F...T....');\nconst INSIDE = RegExp('T.F..F...');\nconst COVERED = RegExp('T.F..F...|.TF..F...|..FT.F...|..F.TF...');\n\nclass DE9IM {\n    /**\n     * Create new instance of DE9IM matrix\n     */\n    constructor() {\n        /**\n         * Array representing 3x3 intersection matrix\n         * @type {Shape[]}\n         */\n        this.m = new Array(9).fill(undefined);\n    }\n\n    /**\n     * Get Interior To Interior intersection\n     * @returns {Shape[] | undefined}\n     */\n    get I2I() {\n        return this.m[0];\n    }\n\n    /**\n     * Set Interior To Interior intersection\n     * @param geom\n     */\n    set I2I(geom) {\n        this.m[0] = geom;\n    }\n\n    /**\n     * Get Interior To Boundary intersection\n     * @returns {Shape[] | undefined}\n     */\n    get I2B() {\n        return this.m[1];\n    }\n\n    /**\n     * Set Interior to Boundary intersection\n     * @param geomc\n     */\n    set I2B(geom) {\n        this.m[1] = geom;\n    }\n\n    /**\n     * Get Interior To Exterior intersection\n     * @returns {Shape[] | undefined}\n     */\n    get I2E() {\n        return this.m[2];\n    }\n\n    /**\n     * Set Interior to Exterior intersection\n     * @param geom\n     */\n    set I2E(geom) {\n        this.m[2] = geom;\n    }\n\n    /**\n     * Get Boundary To Interior intersection\n     * @returns {Shape[] | undefined}\n     */\n    get B2I() {\n        return this.m[3];\n    }\n\n    /**\n     * Set Boundary to Interior intersection\n     * @param geom\n     */\n    set B2I(geom) {\n        this.m[3] = geom;\n    }\n\n    /**\n     * Get Boundary To Boundary intersection\n     * @returns {Shape[] | undefined}\n     */\n    get B2B() {\n        return this.m[4];\n    }\n\n    /**\n     * Set Boundary to Boundary intersection\n     * @param geom\n     */\n    set B2B(geom) {\n        this.m[4] = geom;\n    }\n\n    /**\n     * Get Boundary To Exterior intersection\n     * @returns {Shape[] | undefined}\n     */\n    get B2E() {\n        return this.m[5];\n    }\n\n    /**\n     * Set Boundary to Exterior intersection\n     * @param geom\n     */\n    set B2E(geom) {\n        this.m[5] = geom;\n    }\n\n    /**\n     * Get Exterior To Interior intersection\n     * @returns {Shape[] | undefined}\n     */\n    get E2I() {\n        return this.m[6];\n    }\n\n    /**\n     * Set Exterior to Interior intersection\n     * @param geom\n     */\n    set E2I(geom) {\n        this.m[6] = geom;\n    }\n\n    /**\n     * Get Exterior To Boundary intersection\n     * @returns {Shape[] | undefined}\n     */\n    get E2B() {\n        return this.m[7];\n    }\n\n    /**\n     * Set Exterior to Boundary intersection\n     * @param geom\n     */\n    set E2B(geom) {\n        this.m[7] = geom;\n    }\n\n    /**\n     * Get Exterior to Exterior intersection\n     * @returns {Shape[] | undefined}\n     */\n    get E2E() {\n        return this.m[8];\n    }\n\n    /**\n     * Set Exterior to Exterior intersection\n     * @param geom\n     */\n    set E2E(geom) {\n        this.m[8] = geom;\n    }\n\n    /**\n     * Return de9im matrix as string where<br/>\n     * - intersection is 'T'<br/>\n     * - not intersected is 'F'<br/>\n     * - not relevant is '*'<br/>\n     * For example, string 'FF**FF****' means 'DISJOINT'\n     * @returns {string}\n     */\n    toString() {\n        return this.m.map( e => {\n            if (e instanceof Array && e.length > 0) {\n                return 'T'\n            }\n            else if (e instanceof Array && e.length === 0) {\n                return 'F'\n            }\n            else {\n                return '*'\n            }\n        }).join(\"\")\n    }\n\n    equal() {\n        return EQUAL.test(this.toString());\n    }\n\n    intersect() {\n        return INTERSECT.test(this.toString());\n    }\n\n    touch() {\n        return TOUCH.test(this.toString());\n    }\n\n    inside() {\n        return INSIDE.test(this.toString());\n    }\n\n    covered() {\n        return COVERED.test(this.toString());\n    }\n}\n\n/**\n * Intersection\n *\n * */\n\n\nfunction intersectLine2Line(line1, line2) {\n    let ip = [];\n\n    let [A1, B1, C1] = line1.standard;\n    let [A2, B2, C2] = line2.standard;\n\n    /* Cramer's rule */\n    let det = A1 * B2 - B1 * A2;\n    let detX = C1 * B2 - B1 * C2;\n    let detY = A1 * C2 - C1 * A2;\n\n    if (!Flatten.Utils.EQ_0(det)) {\n        let x, y;\n\n        if (B1 === 0) {        // vertical line x  = C1/A1, where A1 == +1 or -1\n            x = C1/A1;\n            y = detY / det;\n        }\n        else if (B2 === 0) {   // vertical line x = C2/A2, where A2 = +1 or -1\n            x = C2/A2;\n            y = detY / det;\n        }\n        else if (A1 === 0) {   // horizontal line y = C1/B1, where B1 = +1 or -1\n            x = detX / det;\n            y = C1/B1;\n        }\n        else if (A2 === 0) {   // horizontal line y = C2/B2, where B2 = +1 or -1\n            x = detX / det;\n            y = C2/B2;\n        }\n        else {\n            x = detX / det;\n            y = detY / det;\n        }\n\n        ip.push(new Flatten.Point(x, y));\n    }\n\n    return ip;\n}\n\nfunction intersectLine2Circle(line, circle) {\n    let ip = [];\n    let prj = circle.pc.projectionOn(line);            // projection of circle center on a line\n    let dist = circle.pc.distanceTo(prj)[0];           // distance from circle center to projection\n\n    if (Flatten.Utils.EQ(dist, circle.r)) {            // line tangent to circle - return single intersection point\n        ip.push(prj);\n    } else if (Flatten.Utils.LT(dist, circle.r)) {       // return two intersection points\n        let delta = Math.sqrt(circle.r * circle.r - dist * dist);\n        let v_trans, pt;\n\n        v_trans = line.norm.rotate90CCW().multiply(delta);\n        pt = prj.translate(v_trans);\n        ip.push(pt);\n\n        v_trans = line.norm.rotate90CW().multiply(delta);\n        pt = prj.translate(v_trans);\n        ip.push(pt);\n    }\n    return ip;\n}\n\nfunction intersectLine2Box(line, box) {\n    let ips = [];\n    for (let seg of box.toSegments()) {\n        let ips_tmp = intersectSegment2Line(seg, line);\n        for (let pt of ips_tmp) {\n            if (!ptInIntPoints(pt, ips)) {\n                ips.push(pt);\n            }\n        }\n    }\n    return ips;\n}\n\nfunction intersectLine2Arc(line, arc) {\n    let ip = [];\n\n    if (intersectLine2Box(line, arc.box).length === 0) {\n        return ip;\n    }\n\n    let circle = new Flatten.Circle(arc.pc, arc.r);\n    let ip_tmp = intersectLine2Circle(line, circle);\n    for (let pt of ip_tmp) {\n        if (pt.on(arc)) {\n            ip.push(pt);\n        }\n    }\n\n    return ip;\n}\n\nfunction intersectSegment2Line(seg, line) {\n    let ip = [];\n\n    // Boundary cases\n    if (seg.ps.on(line)) {\n        ip.push(seg.ps);\n    }\n    // If both ends lay on line, return two intersection points\n    if (seg.pe.on(line) && !seg.isZeroLength()) {\n        ip.push(seg.pe);\n    }\n\n    if (ip.length > 0) {\n        return ip;          // done, intersection found\n    }\n\n    // If zero-length segment and nothing found, return no intersections\n    if (seg.isZeroLength()) {\n        return ip;\n    }\n\n    // Not a boundary case, check if both points are on the same side and\n    // hence there is no intersection\n    if (seg.ps.leftTo(line) && seg.pe.leftTo(line) ||\n        !seg.ps.leftTo(line) && !seg.pe.leftTo(line)) {\n        return ip;\n    }\n\n    // Calculate intersection between lines\n    let line1 = new Flatten.Line(seg.ps, seg.pe);\n    return intersectLine2Line(line1, line);\n}\n\nfunction intersectSegment2Segment(seg1, seg2) {\n    let ip = [];\n\n    // quick reject\n    if (seg1.box.not_intersect(seg2.box)) {\n        return ip;\n    }\n\n    // Special case of seg1 zero length\n    if (seg1.isZeroLength()) {\n        if (seg1.ps.on(seg2)) {\n            ip.push(seg1.ps);\n        }\n        return ip;\n    }\n\n    // Special case of seg2 zero length\n    if (seg2.isZeroLength()) {\n        if (seg2.ps.on(seg1)) {\n            ip.push(seg2.ps);\n        }\n        return ip;\n    }\n\n    // Neither seg1 nor seg2 is zero length\n    let line1 = new Flatten.Line(seg1.ps, seg1.pe);\n    let line2 = new Flatten.Line(seg2.ps, seg2.pe);\n\n    // Check overlapping between segments in case of incidence\n    // If segments touching, add one point. If overlapping, add two points\n    if (line1.incidentTo(line2)) {\n        if (seg1.ps.on(seg2)) {\n            ip.push(seg1.ps);\n        }\n        if (seg1.pe.on(seg2)) {\n            ip.push(seg1.pe);\n        }\n        if (seg2.ps.on(seg1) && !seg2.ps.equalTo(seg1.ps) && !seg2.ps.equalTo(seg1.pe)) {\n            ip.push(seg2.ps);\n        }\n        if (seg2.pe.on(seg1) && !seg2.pe.equalTo(seg1.ps) && !seg2.pe.equalTo(seg1.pe)) {\n            ip.push(seg2.pe);\n        }\n    } else {                /* not incident - parallel or intersect */\n        // Calculate intersection between lines\n        let new_ip = intersectLine2Line(line1, line2);\n        if (new_ip.length > 0) {\n            if (isPointInSegmentBox(new_ip[0], seg1) && isPointInSegmentBox(new_ip[0], seg2)) {\n                ip.push(new_ip[0]);\n            }\n        }\n    }\n    return ip;\n}\n\nfunction isPointInSegmentBox(point, segment) {\n    const box = segment.box;\n    return Flatten.Utils.LE(point.x, box.xmax) && Flatten.Utils.GE(point.x, box.xmin) &&\n        Flatten.Utils.LE(point.y, box.ymax) && Flatten.Utils.GE(point.y, box.ymin)\n}\n\nfunction intersectSegment2Circle(segment, circle) {\n    let ips = [];\n\n    if (segment.box.not_intersect(circle.box)) {\n        return ips;\n    }\n\n    // Special case of zero length segment\n    if (segment.isZeroLength()) {\n        let [dist, _] = segment.ps.distanceTo(circle.pc);\n        if (Flatten.Utils.EQ(dist, circle.r)) {\n            ips.push(segment.ps);\n        }\n        return ips;\n    }\n\n    // Non zero-length segment\n    let line = new Flatten.Line(segment.ps, segment.pe);\n\n    let ips_tmp = intersectLine2Circle(line, circle);\n\n    for (let ip of ips_tmp) {\n        if (ip.on(segment)) {\n            ips.push(ip);\n        }\n    }\n\n    return ips;\n}\n\nfunction intersectSegment2Arc(segment, arc) {\n    let ip = [];\n\n    if (segment.box.not_intersect(arc.box)) {\n        return ip;\n    }\n\n    // Special case of zero-length segment\n    if (segment.isZeroLength()) {\n        if (segment.ps.on(arc)) {\n            ip.push(segment.ps);\n        }\n        return ip;\n    }\n\n    // Non-zero length segment\n    let line = new Flatten.Line(segment.ps, segment.pe);\n    let circle = new Flatten.Circle(arc.pc, arc.r);\n\n    let ip_tmp = intersectLine2Circle(line, circle);\n\n    for (let pt of ip_tmp) {\n        if (pt.on(segment) && pt.on(arc)) {\n            ip.push(pt);\n        }\n    }\n    return ip;\n\n}\n\nfunction intersectSegment2Box(segment, box) {\n    let ips = [];\n    for (let seg of box.toSegments()) {\n        let ips_tmp = intersectSegment2Segment(seg, segment);\n        for (let ip of ips_tmp) {\n            ips.push(ip);\n        }\n    }\n    return ips;\n}\n\nfunction intersectCircle2Circle(circle1, circle2) {\n    let ip = [];\n\n    if (circle1.box.not_intersect(circle2.box)) {\n        return ip;\n    }\n\n    let vec = new Flatten.Vector(circle1.pc, circle2.pc);\n\n    let r1 = circle1.r;\n    let r2 = circle2.r;\n\n    // Degenerated circle\n    if (Flatten.Utils.EQ_0(r1) || Flatten.Utils.EQ_0(r2))\n        return ip;\n\n    // In case of equal circles return one leftmost point\n    if (Flatten.Utils.EQ_0(vec.x) && Flatten.Utils.EQ_0(vec.y) && Flatten.Utils.EQ(r1, r2)) {\n        ip.push(circle1.pc.translate(-r1, 0));\n        return ip;\n    }\n\n    let dist = circle1.pc.distanceTo(circle2.pc)[0];\n\n    if (Flatten.Utils.GT(dist, r1 + r2))               // circles too far, no intersections\n        return ip;\n\n    if (Flatten.Utils.LT(dist, Math.abs(r1 - r2)))     // one circle is contained within another, no intersections\n        return ip;\n\n    // Normalize vector.\n    vec.x /= dist;\n    vec.y /= dist;\n\n    let pt;\n\n    // Case of touching from outside or from inside - single intersection point\n    // TODO: check this specifically not sure if correct\n    if (Flatten.Utils.EQ(dist, r1 + r2) || Flatten.Utils.EQ(dist, Math.abs(r1 - r2))) {\n        pt = circle1.pc.translate(r1 * vec.x, r1 * vec.y);\n        ip.push(pt);\n        return ip;\n    }\n\n    // Case of two intersection points\n\n    // Distance from first center to center of common chord:\n    //   a = (r1^2 - r2^2 + d^2) / 2d\n    // Separate for better accuracy\n    let a = (r1 * r1) / (2 * dist) - (r2 * r2) / (2 * dist) + dist / 2;\n\n    let mid_pt = circle1.pc.translate(a * vec.x, a * vec.y);\n    let h = Math.sqrt(r1 * r1 - a * a);\n    // let norm;\n\n    // norm = vec.rotate90CCW().multiply(h);\n    pt = mid_pt.translate(vec.rotate90CCW().multiply(h));\n    ip.push(pt);\n\n    // norm = vec.rotate90CW();\n    pt = mid_pt.translate(vec.rotate90CW().multiply(h));\n    ip.push(pt);\n\n    return ip;\n}\n\nfunction intersectCircle2Box(circle, box) {\n    let ips = [];\n    for (let seg of box.toSegments()) {\n        let ips_tmp = intersectSegment2Circle(seg, circle);\n        for (let ip of ips_tmp) {\n            ips.push(ip);\n        }\n    }\n    return ips;\n}\n\nfunction intersectArc2Arc(arc1, arc2) {\n    let ip = [];\n\n    if (arc1.box.not_intersect(arc2.box)) {\n        return ip;\n    }\n\n    // Special case: overlapping arcs\n    // May return up to 4 intersection points\n    if (arc1.pc.equalTo(arc2.pc) && Flatten.Utils.EQ(arc1.r, arc2.r)) {\n        let pt;\n\n        pt = arc1.start;\n        if (pt.on(arc2))\n            ip.push(pt);\n\n        pt = arc1.end;\n        if (pt.on(arc2))\n            ip.push(pt);\n\n        pt = arc2.start;\n        if (pt.on(arc1)) ip.push(pt);\n\n        pt = arc2.end;\n        if (pt.on(arc1)) ip.push(pt);\n\n        return ip;\n    }\n\n    // Common case\n    let circle1 = new Flatten.Circle(arc1.pc, arc1.r);\n    let circle2 = new Flatten.Circle(arc2.pc, arc2.r);\n    let ip_tmp = circle1.intersect(circle2);\n    for (let pt of ip_tmp) {\n        if (pt.on(arc1) && pt.on(arc2)) {\n            ip.push(pt);\n        }\n    }\n    return ip;\n}\n\nfunction intersectArc2Circle(arc, circle) {\n    let ip = [];\n\n    if (arc.box.not_intersect(circle.box)) {\n        return ip;\n    }\n\n    // Case when arc center incident to circle center\n    // Return arc's end points as 2 intersection points\n    if (circle.pc.equalTo(arc.pc) && Flatten.Utils.EQ(circle.r, arc.r)) {\n        ip.push(arc.start);\n        ip.push(arc.end);\n        return ip;\n    }\n\n    // Common case\n    let circle1 = circle;\n    let circle2 = new Flatten.Circle(arc.pc, arc.r);\n    let ip_tmp = intersectCircle2Circle(circle1, circle2);\n    for (let pt of ip_tmp) {\n        if (pt.on(arc)) {\n            ip.push(pt);\n        }\n    }\n    return ip;\n}\n\nfunction intersectArc2Box(arc, box) {\n    let ips = [];\n    for (let seg of box.toSegments()) {\n        let ips_tmp = intersectSegment2Arc(seg, arc);\n        for (let ip of ips_tmp) {\n            ips.push(ip);\n        }\n    }\n    return ips;\n}\n\nfunction intersectEdge2Segment(edge, segment) {\n    return edge.isSegment ? intersectSegment2Segment(edge.shape, segment) : intersectSegment2Arc(segment, edge.shape);\n}\n\nfunction intersectEdge2Arc(edge, arc) {\n    return edge.isSegment ? intersectSegment2Arc(edge.shape, arc) : intersectArc2Arc(edge.shape, arc);\n}\n\nfunction intersectEdge2Line(edge, line) {\n    return edge.isSegment ? intersectSegment2Line(edge.shape, line) : intersectLine2Arc(line, edge.shape);\n}\n\nfunction intersectEdge2Ray(edge, ray) {\n    return edge.isSegment ? intersectRay2Segment(ray, edge.shape) : intersectRay2Arc(ray, edge.shape);\n}\n\nfunction intersectEdge2Circle(edge, circle) {\n    return edge.isSegment ? intersectSegment2Circle(edge.shape, circle) : intersectArc2Circle(edge.shape, circle);\n}\n\nfunction intersectSegment2Polygon(segment, polygon) {\n    let ip = [];\n\n    for (let edge of polygon.edges) {\n        for (let pt of intersectEdge2Segment(edge, segment)) {\n            ip.push(pt);\n        }\n    }\n\n    return ip;\n}\n\nfunction intersectArc2Polygon(arc, polygon) {\n    let ip = [];\n\n    for (let edge of polygon.edges) {\n        for (let pt of intersectEdge2Arc(edge, arc)) {\n            ip.push(pt);\n        }\n    }\n\n    return ip;\n}\n\nfunction intersectLine2Polygon(line, polygon) {\n    let ip = [];\n\n    if (polygon.isEmpty()) {\n        return ip;\n    }\n\n    for (let edge of polygon.edges) {\n        for (let pt of intersectEdge2Line(edge, line)) {\n            if (!ptInIntPoints(pt, ip)) {\n                ip.push(pt);\n            }\n        }\n    }\n\n    return line.sortPoints(ip);\n}\n\nfunction intersectCircle2Polygon(circle, polygon) {\n    let ip = [];\n\n    if (polygon.isEmpty()) {\n        return ip;\n    }\n\n    for (let edge of polygon.edges) {\n        for (let pt of intersectEdge2Circle(edge, circle)) {\n            ip.push(pt);\n        }\n    }\n\n    return ip;\n}\n\nfunction intersectEdge2Edge(edge1, edge2) {\n    if (edge1.isSegment) {\n        return intersectEdge2Segment(edge2, edge1.shape)\n    }\n    else if (edge1.isArc) {\n        return intersectEdge2Arc(edge2, edge1.shape)\n    }\n    else if (edge1.isLine) {\n        return intersectEdge2Line(edge2, edge1.shape)\n    }\n    else if (edge1.isRay) {\n        return intersectEdge2Ray(edge2, edge1.shape)\n    }\n    return []\n}\n\nfunction intersectEdge2Polygon(edge, polygon) {\n    let ip = [];\n\n    if (polygon.isEmpty() || edge.shape.box.not_intersect(polygon.box)) {\n        return ip;\n    }\n\n    let resp_edges = polygon.edges.search(edge.shape.box);\n\n    for (let resp_edge of resp_edges) {\n        ip = [...ip, ...intersectEdge2Edge(edge, resp_edge)];\n    }\n\n    return ip;\n}\n\nfunction intersectPolygon2Polygon(polygon1, polygon2) {\n    let ip = [];\n\n    if (polygon1.isEmpty() || polygon2.isEmpty()) {\n        return ip;\n    }\n\n    if (polygon1.box.not_intersect(polygon2.box)) {\n        return ip;\n    }\n\n    for (let edge1 of polygon1.edges) {\n        ip = [...ip, ...intersectEdge2Polygon(edge1, polygon2)];\n    }\n\n    return ip;\n}\n\nfunction intersectShape2Polygon(shape, polygon) {\n    if (shape instanceof Flatten.Line) {\n        return intersectLine2Polygon(shape, polygon);\n    }\n    else if (shape instanceof Flatten.Segment) {\n        return intersectSegment2Polygon(shape, polygon);\n    }\n    else if (shape instanceof Flatten.Arc) {\n        return intersectArc2Polygon(shape, polygon);\n    }\n    else {\n        return [];\n    }\n}\n\nfunction ptInIntPoints(new_pt, ip) {\n    return ip.some( pt => pt.equalTo(new_pt) )\n}\n\nfunction createLineFromRay(ray) {\n    return new Flatten.Line(ray.start, ray.norm)\n}\nfunction intersectRay2Segment(ray, segment) {\n    return intersectSegment2Line(segment, createLineFromRay(ray))\n        .filter(pt => ray.contains(pt));\n}\n\nfunction intersectRay2Arc(ray, arc) {\n    return intersectLine2Arc(createLineFromRay(ray), arc)\n        .filter(pt => ray.contains(pt))\n}\n\nfunction intersectRay2Circle(ray, circle) {\n    return intersectLine2Circle(createLineFromRay(ray), circle)\n        .filter(pt => ray.contains(pt))\n}\n\nfunction intersectRay2Box(ray, box) {\n    return intersectLine2Box(createLineFromRay(ray), box)\n        .filter(pt => ray.contains(pt))\n}\n\nfunction intersectRay2Line(ray, line) {\n    return intersectLine2Line(createLineFromRay(ray), line)\n        .filter(pt => ray.contains(pt))\n}\n\nfunction intersectRay2Ray(ray1, ray2) {\n    return intersectLine2Line(createLineFromRay(ray1), createLineFromRay(ray2))\n        .filter(pt => ray1.contains(pt))\n        .filter(pt => ray2.contains(pt))\n}\n\nfunction intersectRay2Polygon(ray, polygon) {\n    return intersectLine2Polygon(createLineFromRay(ray), polygon)\n        .filter(pt => ray.contains(pt))\n}\n\nconst defaultAttributes = {\n    stroke: \"black\"\n};\n\nclass SVGAttributes {\n    constructor(args = defaultAttributes) {\n        for(const property in args) {\n            this[property] = args[property];\n        }\n        this.stroke = args.stroke ?? defaultAttributes.stroke;\n    }\n\n    toAttributesString() {\n        return Object.keys(this)\n            .reduce( (acc, key) =>\n                    acc + (this[key] !== undefined ? this.toAttrString(key, this[key]) : \"\")\n            , ``)\n    }\n\n    toAttrString(key, value) {\n        const SVGKey = key === \"className\" ? \"class\" : this.convertCamelToKebabCase(key);\n        return value === null ? `${SVGKey} ` : `${SVGKey}=\"${value.toString()}\" `\n    }\n\n    convertCamelToKebabCase(str) {\n        return str\n            .match(/[A-Z]{2,}(?=[A-Z][a-z]+[0-9]*|\\b)|[A-Z]?[a-z]+[0-9]*|[A-Z]|[0-9]+/g)\n            .join('-')\n            .toLowerCase();\n    }\n}\n\nfunction convertToString(attrs) {\n    return new SVGAttributes(attrs).toAttributesString()\n}\n\n/**\n * Class Multiline represent connected path of [edges]{@link Flatten.Edge}, where each edge may be\n * [segment]{@link Flatten.Segment}, [arc]{@link Flatten.Arc}, [line]{@link Flatten.Line} or [ray]{@link Flatten.Ray}\n */\nclass Multiline extends LinkedList {\n    constructor(...args) {\n        super();\n\n        if (args.length === 0) {\n            return;\n        }\n\n        if (args.length === 1) {\n            if (args[0] instanceof Array) {\n                let shapes = args[0];\n                if (shapes.length === 0)\n                    return;\n\n                // TODO: more strict validation:\n                // there may be only one line\n                // only first and last may be rays\n                shapes.every((shape) => {\n                    return shape instanceof Flatten.Segment ||\n                        shape instanceof Flatten.Arc ||\n                        shape instanceof Flatten.Ray ||\n                        shape instanceof Flatten.Line\n                });\n\n                for (let shape of shapes) {\n                    let edge = new Flatten.Edge(shape);\n                    this.append(edge);\n                }\n\n                this.setArcLength();\n            }\n        }\n    }\n\n    /**\n     * (Getter) Return array of edges\n     * @returns {Edge[]}\n     */\n    get edges() {\n        return [...this];\n    }\n\n    /**\n     * (Getter) Return bounding box of the multiline\n     * @returns {Box}\n     */\n    get box() {\n        return this.edges.reduce( (acc,edge) => acc.merge(edge.box), new Flatten.Box() );\n    }\n\n    /**\n     * (Getter) Returns array of vertices\n     * @returns {Point[]}\n     */\n    get vertices() {\n        let v = this.edges.map(edge => edge.start);\n        v.push(this.last.end);\n        return v;\n    }\n\n    /**\n     * Return new cloned instance of Multiline\n     * @returns {Multiline}\n     */\n    clone() {\n        return new Multiline(this.toShapes());\n    }\n\n    /**\n     * Set arc_length property for each of the edges in the face.\n     * Arc_length of the edge it the arc length from the first edge of the face\n     */\n    setArcLength() {\n        for (let edge of this) {\n            this.setOneEdgeArcLength(edge);\n        }\n    }\n\n    setOneEdgeArcLength(edge) {\n        if (edge === this.first) {\n            edge.arc_length = 0.0;\n        } else {\n            edge.arc_length = edge.prev.arc_length + edge.prev.length;\n        }\n    }\n\n    /**\n     * Split edge and add new vertex, return new edge inserted\n     * @param {Point} pt - point on edge that will be added as new vertex\n     * @param {Edge} edge - edge to split\n     * @returns {Edge}\n     */\n    addVertex(pt, edge) {\n        let shapes = edge.shape.split(pt);\n        // if (shapes.length < 2) return;\n\n        if (shapes[0] === null)   // point incident to edge start vertex, return previous edge\n           return edge.prev;\n\n        if (shapes[1] === null)   // point incident to edge end vertex, return edge itself\n           return edge;\n\n        let newEdge = new Flatten.Edge(shapes[0]);\n        let edgeBefore = edge.prev;\n\n        /* Insert first split edge into linked list after edgeBefore */\n        this.insert(newEdge, edgeBefore);     // edge.face ?\n\n        // Update edge shape with second split edge keeping links\n        edge.shape = shapes[1];\n\n        return newEdge;\n    }\n\n    getChain(edgeFrom, edgeTo) {\n        let edges = [];\n        for (let edge = edgeFrom; edge !== edgeTo.next; edge = edge.next) {\n            edges.push(edge);\n        }\n        return edges\n    }\n\n    /**\n     * Split edges of multiline with intersection points and return mutated multiline\n     * @param {Point[]} ip - array of points to be added as new vertices\n     * @returns {Multiline}\n     */\n    split(ip) {\n        for (let pt of ip) {\n            let edge = this.findEdgeByPoint(pt);\n            this.addVertex(pt, edge);\n        }\n        return this;\n    }\n\n    /**\n     * Returns edge which contains given point\n     * @param {Point} pt\n     * @returns {Edge}\n     */\n    findEdgeByPoint(pt) {\n        let edgeFound;\n        for (let edge of this) {\n            if (edge.shape.contains(pt)) {\n                edgeFound = edge;\n                break;\n            }\n        }\n        return edgeFound;\n    }\n\n    /**\n     * Returns new multiline translated by vector vec\n     * @param {Vector} vec\n     * @returns {Multiline}\n     */\n    translate(vec) {\n        return new Multiline(this.edges.map( edge => edge.shape.translate(vec)));\n    }\n\n    /**\n     * Return new multiline rotated by given angle around given point\n     * If point omitted, rotate around origin (0,0)\n     * Positive value of angle defines rotation counterclockwise, negative - clockwise\n     * @param {number} angle - rotation angle in radians\n     * @param {Point} center - rotation center, default is (0,0)\n     * @returns {Multiline} - new rotated polygon\n     */\n    rotate(angle = 0, center = new Flatten.Point()) {\n        return new Multiline(this.edges.map( edge => edge.shape.rotate(angle, center) ));\n    }\n\n    /**\n     * Return new multiline transformed using affine transformation matrix\n     * Method does not support unbounded shapes\n     * @param {Matrix} matrix - affine transformation matrix\n     * @returns {Multiline} - new multiline\n     */\n    transform(matrix = new Flatten.Matrix()) {\n        return new Multiline(this.edges.map( edge => edge.shape.transform(matrix)));\n    }\n\n    /**\n     * Transform multiline into array of shapes\n     * @returns {Shape[]}\n     */\n    toShapes() {\n        return this.edges.map(edge => edge.shape.clone())\n    }\n\n    /**\n     * This method returns an object that defines how data will be\n     * serialized when called JSON.stringify() method\n     * @returns {Object}\n     */\n    toJSON() {\n        return this.edges.map(edge => edge.toJSON());\n    }\n\n    /**\n     * Return string to draw multiline in svg\n     * @param attrs  - an object with attributes for svg path element\n     * TODO: support semi-infinite Ray and infinite Line\n     * @returns {string}\n     */\n    svg(attrs = {}) {\n        let svgStr = `\\n<path ${convertToString({fill: \"none\", ...attrs})} d=\"`;\n        svgStr += `\\nM${this.first.start.x},${this.first.start.y}`;\n        for (let edge of this) {\n            svgStr += edge.svg();\n        }\n        svgStr += `\" >\\n</path>`;\n        return svgStr;\n    }\n}\n\nFlatten.Multiline = Multiline;\n\n/**\n * Shortcut function to create multiline\n * @param args\n */\nconst multiline = (...args) => new Flatten.Multiline(...args);\nFlatten.multiline = multiline;\n\n/**\n * @module RayShoot\n */\n/**\n * Implements ray shooting algorithm. Returns relation between point and polygon: inside, outside or boundary\n * @param {Polygon} polygon - polygon to test\n * @param {Point} point - point to test\n * @returns {INSIDE|OUTSIDE|BOUNDARY}\n */\nfunction ray_shoot(polygon, point) {\n    let contains = undefined;\n\n    // 1. Quick reject\n    // if (polygon.box.not_intersect(point.box)) {\n    //     return Flatten.OUTSIDE;\n    // }\n\n    let ray = new Flatten.Ray(point);\n    let line = new Flatten.Line(ray.pt, ray.norm);\n\n    // 2. Locate relevant edges of the polygon\n    const searchBox = new Flatten.Box(\n        ray.box.xmin-Flatten.DP_TOL, ray.box.ymin-Flatten.DP_TOL,\n        ray.box.xmax, ray.box.ymax+Flatten.DP_TOL\n    );\n\n    if (polygon.box.not_intersect(searchBox)) {\n        return Flatten.OUTSIDE;\n    }\n\n    let resp_edges = polygon.edges.search(searchBox);\n\n    if (resp_edges.length == 0) {\n        return Flatten.OUTSIDE;\n    }\n\n    // 2.5 Check if boundary\n    for (let edge of resp_edges) {\n        if (edge.shape.contains(point)) {\n            return Flatten.BOUNDARY;\n        }\n    }\n\n    // 3. Calculate intersections\n    let intersections = [];\n    for (let edge of resp_edges) {\n        for (let ip of ray.intersect(edge.shape)) {\n\n            // If intersection is equal to query point then point lays on boundary\n            if (ip.equalTo(point)) {\n                return Flatten.BOUNDARY;\n            }\n\n            intersections.push({\n                pt: ip,\n                edge: edge\n            });\n        }\n    }\n\n    // 4. Sort intersection in x-ascending order\n    intersections.sort((i1, i2) => {\n        if (LT(i1.pt.x, i2.pt.x)) {\n            return -1;\n        }\n        if (GT(i1.pt.x, i2.pt.x)) {\n            return 1;\n        }\n        return 0;\n    });\n\n    // 5. Count real intersections, exclude touching\n    let counter = 0;\n\n    for (let i = 0; i < intersections.length; i++) {\n        let intersection = intersections[i];\n        if (intersection.pt.equalTo(intersection.edge.shape.start)) {\n            /* skip same point between same edges if already counted */\n            if (i > 0 && intersection.pt.equalTo(intersections[i - 1].pt) &&\n                intersection.edge.prev === intersections[i - 1].edge) {\n                continue;\n            }\n            let prev_edge = intersection.edge.prev;\n            while (EQ_0(prev_edge.length)) {\n                prev_edge = prev_edge.prev;\n            }\n            let prev_tangent = prev_edge.shape.tangentInEnd();\n            let prev_point = intersection.pt.translate(prev_tangent);\n\n            let cur_tangent = intersection.edge.shape.tangentInStart();\n            let cur_point = intersection.pt.translate(cur_tangent);\n\n            let prev_on_the_left = prev_point.leftTo(line);\n            let cur_on_the_left = cur_point.leftTo(line);\n\n            if ((prev_on_the_left && !cur_on_the_left) || (!prev_on_the_left && cur_on_the_left)) {\n                counter++;\n            }\n        } else if (intersection.pt.equalTo(intersection.edge.shape.end)) {\n            /* skip same point between same edges if already counted */\n            if (i > 0 && intersection.pt.equalTo(intersections[i - 1].pt) &&\n                intersection.edge.next === intersections[i - 1].edge) {\n                continue;\n            }\n            let next_edge = intersection.edge.next;\n            while (EQ_0(next_edge.length)) {\n                next_edge = next_edge.next;\n            }\n            let next_tangent = next_edge.shape.tangentInStart();\n            let next_point = intersection.pt.translate(next_tangent);\n\n            let cur_tangent = intersection.edge.shape.tangentInEnd();\n            let cur_point = intersection.pt.translate(cur_tangent);\n\n            let next_on_the_left = next_point.leftTo(line);\n            let cur_on_the_left = cur_point.leftTo(line);\n\n            if ((next_on_the_left && !cur_on_the_left) || (!next_on_the_left && cur_on_the_left)) {\n                counter++;\n            }\n        } else {        /* intersection point is not a coincident with a vertex */\n            if (intersection.edge.shape instanceof Flatten.Segment) {\n                counter++;\n            } else {\n                /* Check if ray does not touch the curve in the extremal (top or bottom) point */\n                let box = intersection.edge.shape.box;\n                if (!(EQ(intersection.pt.y, box.ymin) ||\n                    EQ(intersection.pt.y, box.ymax))) {\n                    counter++;\n                }\n            }\n        }\n    }\n\n    // 6. Odd or even?\n    contains = counter % 2 == 1 ? INSIDE$2 : OUTSIDE$1;\n\n    return contains;\n}\n\n/*\n    Calculate relationship between two shapes and return result in the form of\n    Dimensionally Extended nine-Intersection Matrix (https://en.wikipedia.org/wiki/DE-9IM)\n */\n\n\n/**\n * Returns true if shapes are topologically equal:  their interiors intersect and\n * no part of the interior or boundary of one geometry intersects the exterior of the other\n * @param shape1\n * @param shape2\n * @returns {boolean}\n */\nfunction equal(shape1, shape2) {\n    return relate(shape1, shape2).equal();\n}\n\n/**\n * Returns true if shapes have at least one point in common, same as \"not disjoint\"\n * @param shape1\n * @param shape2\n * @returns {boolean}\n */\nfunction intersect(shape1, shape2) {\n    return relate(shape1, shape2).intersect();\n}\n\n/**\n * Returns true if shapes have at least one point in common, but their interiors do not intersect\n * @param shape1\n * @param shape2\n * @returns {boolean}\n */\nfunction touch(shape1, shape2) {\n    return relate(shape1, shape2).touch();\n}\n\n/**\n * Returns true if shapes have no points in common neither in interior nor in boundary\n * @param shape1\n * @param shape2\n * @returns {boolean}\n */\nfunction disjoint(shape1, shape2) {\n    return !intersect(shape1, shape2);\n}\n\n/**\n * Returns true shape1 lies in the interior of shape2\n * @param shape1\n * @param shape2\n * @returns {boolean}\n */\nfunction inside(shape1, shape2) {\n    return relate(shape1, shape2).inside();\n}\n\n/**\n * Returns true if every point in shape1 lies in the interior or on the boundary of shape2\n * @param shape1\n * @param shape2\n * @returns {boolean}\n */\nfunction covered(shape1, shape2) {\n    return  relate(shape1, shape2).covered();\n}\n\n/**\n * Returns true shape1's interior contains shape2 <br/>\n * Same as inside(shape2, shape1)\n * @param shape1\n * @param shape2\n * @returns {boolean}\n */\nfunction contain(shape1, shape2) {\n    return inside(shape2, shape1);\n}\n\n/**\n * Returns true shape1's cover shape2, same as shape2 covered by shape1\n * @param shape1\n * @param shape2\n * @returns {boolean}\n */\nfunction cover(shape1, shape2) {\n    return covered(shape2, shape1);\n}\n\n/**\n * Returns relation between two shapes as intersection 3x3 matrix, where each\n * element contains relevant intersection as array of shapes.\n * If there is no intersection, element contains empty array\n * If intersection is irrelevant it left undefined. (For example, intersection\n * between two exteriors is usually irrelevant)\n * @param shape1\n * @param shape2\n * @returns {DE9IM}\n */\nfunction relate(shape1, shape2) {\n    if (shape1 instanceof Flatten.Line && shape2 instanceof Flatten.Line) {\n        return relateLine2Line(shape1,  shape2);\n    }\n    else if (shape1 instanceof Flatten.Line && shape2 instanceof Flatten.Circle) {\n        return relateLine2Circle(shape1, shape2);\n    }\n    else if (shape1 instanceof Flatten.Line && shape2 instanceof Flatten.Box) {\n        return relateLine2Box(shape1, shape2);\n    }\n    else if ( shape1 instanceof Flatten.Line  && shape2 instanceof Flatten.Polygon) {\n        return relateLine2Polygon(shape1, shape2);\n    }\n    else if ( (shape1 instanceof Flatten.Segment || shape1 instanceof Flatten.Arc)  && shape2 instanceof Flatten.Polygon) {\n        return relateShape2Polygon(shape1, shape2);\n    }\n    else if ( (shape1 instanceof Flatten.Segment || shape1 instanceof Flatten.Arc)  &&\n        (shape2 instanceof Flatten.Circle || shape2 instanceof Flatten.Box) ) {\n        return relateShape2Polygon(shape1, new Flatten.Polygon(shape2));\n    }\n    else if (shape1 instanceof Flatten.Polygon && shape2 instanceof Flatten.Polygon) {\n        return relatePolygon2Polygon(shape1, shape2);\n    }\n    else if ((shape1 instanceof Flatten.Circle || shape1 instanceof Flatten.Box) &&\n        (shape2 instanceof  Flatten.Circle || shape2 instanceof Flatten.Box)) {\n        return relatePolygon2Polygon(new Flatten.Polygon(shape1), new Flatten.Polygon(shape2));\n    }\n    else if ((shape1 instanceof Flatten.Circle || shape1 instanceof Flatten.Box) && shape2 instanceof Flatten.Polygon) {\n        return relatePolygon2Polygon(new Flatten.Polygon(shape1), shape2);\n    }\n    else if (shape1 instanceof Flatten.Polygon && (shape2 instanceof Flatten.Circle || shape2 instanceof Flatten.Box)) {\n        return relatePolygon2Polygon(shape1, new Flatten.Polygon(shape2));\n    }\n}\n\nfunction relateLine2Line(line1, line2) {\n    let denim = new DE9IM();\n    let ip = intersectLine2Line(line1, line2);\n    if (ip.length === 0) {       // parallel or equal ?\n        if (line1.contains(line2.pt) && line2.contains(line1.pt)) {\n            denim.I2I = [line1];   // equal  'T.F...F..'  - no boundary\n            denim.I2E = [];\n            denim.E2I = [];\n        }\n        else {                     // parallel - disjoint 'FFTFF*T**'\n            denim.I2I = [];\n            denim.I2E = [line1];\n            denim.E2I = [line2];\n        }\n    }\n    else {                       // intersect   'T********'\n        denim.I2I = ip;\n        denim.I2E = line1.split(ip);\n        denim.E2I = line2.split(ip);\n    }\n    return denim;\n}\n\nfunction relateLine2Circle(line,circle) {\n    let denim = new DE9IM();\n    let ip = intersectLine2Circle(line, circle);\n    if (ip.length === 0) {\n        denim.I2I = [];\n        denim.I2B = [];\n        denim.I2E = [line];\n        denim.E2I = [circle];\n    }\n    else if (ip.length === 1) {\n        denim.I2I = [];\n        denim.I2B = ip;\n        denim.I2E = line.split(ip);\n\n        denim.E2I = [circle];\n    }\n    else {       // ip.length == 2\n        let multiline = new Multiline([line]);\n        let ip_sorted = line.sortPoints(ip);\n        multiline.split(ip_sorted);\n        let splitShapes = multiline.toShapes();\n\n        denim.I2I = [splitShapes[1]];\n        denim.I2B = ip_sorted;\n        denim.I2E = [splitShapes[0], splitShapes[2]];\n\n        denim.E2I = new Flatten.Polygon([circle.toArc()]).cutWithLine(line);\n    }\n\n    return denim;\n}\n\nfunction relateLine2Box(line, box) {\n    let denim = new DE9IM();\n    let ip = intersectLine2Box(line, box);\n    if (ip.length === 0) {\n        denim.I2I = [];\n        denim.I2B = [];\n        denim.I2E = [line];\n\n        denim.E2I = [box];\n    }\n    else if (ip.length === 1) {\n        denim.I2I = [];\n        denim.I2B = ip;\n        denim.I2E = line.split(ip);\n\n        denim.E2I = [box];\n    }\n    else {                     // ip.length == 2\n        let multiline = new Multiline([line]);\n        let ip_sorted = line.sortPoints(ip);\n        multiline.split(ip_sorted);\n        let splitShapes = multiline.toShapes();\n\n        /* Are two intersection points on the same segment of the box boundary ? */\n        if (box.toSegments().some( segment => segment.contains(ip[0]) && segment.contains(ip[1]) )) {\n            denim.I2I = [];                         // case of touching\n            denim.I2B = [splitShapes[1]];\n            denim.I2E = [splitShapes[0], splitShapes[2]];\n\n            denim.E2I = [box];\n        }\n        else {                                       // case of intersection\n            denim.I2I = [splitShapes[1]];            // [segment(ip[0], ip[1])];\n            denim.I2B = ip_sorted;\n            denim.I2E = [splitShapes[0], splitShapes[2]];\n\n            denim.E2I = new Flatten.Polygon(box.toSegments()).cutWithLine(line);\n        }\n    }\n    return denim;\n}\n\nfunction relateLine2Polygon(line, polygon) {\n    let denim = new DE9IM();\n    let ip = intersectLine2Polygon(line, polygon);\n    let multiline = new Multiline([line]);\n    let ip_sorted = ip.length > 0 ? ip.slice() : line.sortPoints(ip);\n\n    multiline.split(ip_sorted);\n\n    [...multiline].forEach(edge => edge.setInclusion(polygon));\n\n    denim.I2I = [...multiline].filter(edge => edge.bv === Flatten.INSIDE).map(edge => edge.shape);\n    denim.I2B = [...multiline].slice(1).map( (edge) => edge.bv === Flatten.BOUNDARY ? edge.shape : edge.shape.start );\n    denim.I2E = [...multiline].filter(edge => edge.bv === Flatten.OUTSIDE).map(edge => edge.shape);\n\n    denim.E2I = polygon.cutWithLine(line);\n\n    return denim;\n}\n\nfunction relateShape2Polygon(shape, polygon) {\n    let denim = new DE9IM();\n    let ip = intersectShape2Polygon(shape, polygon);\n    let ip_sorted = ip.length > 0 ? ip.slice() : shape.sortPoints(ip);\n\n    let multiline = new Multiline([shape]);\n    multiline.split(ip_sorted);\n\n    [...multiline].forEach(edge => edge.setInclusion(polygon));\n\n    denim.I2I = [...multiline].filter(edge => edge.bv === Flatten.INSIDE).map(edge => edge.shape);\n    denim.I2B = [...multiline].slice(1).map( (edge) => edge.bv === Flatten.BOUNDARY ? edge.shape : edge.shape.start );\n    denim.I2E = [...multiline].filter(edge => edge.bv === Flatten.OUTSIDE).map(edge => edge.shape);\n\n\n    denim.B2I = [];\n    denim.B2B = [];\n    denim.B2E = [];\n    for (let pt of [shape.start, shape.end]) {\n        switch (ray_shoot(polygon, pt)) {\n            case Flatten.INSIDE:\n                denim.B2I.push(pt);\n                break;\n            case Flatten.BOUNDARY:\n                denim.B2B.push(pt);\n                break;\n            case Flatten.OUTSIDE:\n                denim.B2E.push(pt);\n                break;\n        }\n    }\n\n    // denim.E2I  TODO: calculate, not clear what is expected result\n\n    return denim;\n}\n\nfunction relatePolygon2Polygon(polygon1, polygon2) {\n    let denim = new DE9IM();\n\n    let [ip_sorted1, ip_sorted2] = calculateIntersections(polygon1, polygon2);\n    let boolean_intersection = intersect$1(polygon1, polygon2);\n    let boolean_difference1 = subtract(polygon1, polygon2);\n    let boolean_difference2 = subtract(polygon2, polygon1);\n    let [inner_clip_shapes1, inner_clip_shapes2] = innerClip(polygon1, polygon2);\n    let outer_clip_shapes1 = outerClip(polygon1, polygon2);\n    let outer_clip_shapes2 = outerClip(polygon2, polygon1);\n\n    denim.I2I = boolean_intersection.isEmpty() ? [] : [boolean_intersection];\n    denim.I2B = inner_clip_shapes2;\n    denim.I2E = boolean_difference1.isEmpty() ? [] : [boolean_difference1];\n\n    denim.B2I = inner_clip_shapes1;\n    denim.B2B = ip_sorted1;\n    denim.B2E = outer_clip_shapes1;\n\n    denim.E2I = boolean_difference2.isEmpty() ? [] : [boolean_difference2];\n    denim.E2B = outer_clip_shapes2;\n    // denim.E2E    not relevant meanwhile\n\n    return denim;\n}\n\nvar Relations = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    contain: contain,\n    cover: cover,\n    covered: covered,\n    disjoint: disjoint,\n    equal: equal,\n    inside: inside,\n    intersect: intersect,\n    relate: relate,\n    touch: touch\n});\n\n/**\n * Class representing an affine transformation 3x3 matrix:\n * <pre>\n *      [ a  c  tx\n * A =    b  d  ty\n *        0  0  1  ]\n * </pre\n * @type {Matrix}\n */\nclass Matrix {\n    /**\n     * Construct new instance of affine transformation matrix <br/>\n     * If parameters omitted, construct identity matrix a = 1, d = 1\n     * @param {number} a - position(0,0)   sx*cos(alpha)\n     * @param {number} b - position (0,1)  sx*sin(alpha)\n     * @param {number} c - position (1,0)  -sy*sin(alpha)\n     * @param {number} d - position (1,1)  sy*cos(alpha)\n     * @param {number} tx - position (2,0) translation by x\n     * @param {number} ty - position (2,1) translation by y\n     */\n    constructor(a = 1, b = 0, c = 0, d = 1, tx = 0, ty = 0) {\n        this.a = a;\n        this.b = b;\n        this.c = c;\n        this.d = d;\n        this.tx = tx;\n        this.ty = ty;\n    }\n\n    /**\n     * Return new cloned instance of matrix\n     * @return {Matrix}\n     **/\n    clone() {\n        return new Matrix(this.a, this.b, this.c, this.d, this.tx, this.ty);\n    };\n\n    /**\n     * Transform vector [x,y] using transformation matrix. <br/>\n     * Vector [x,y] is an abstract array[2] of numbers and not a FlattenJS object <br/>\n     * The result is also an abstract vector [x',y'] = A * [x,y]:\n     * <code>\n     * [x'       [ ax + by + tx\n     *  y'   =     cx + dy + ty\n     *  1]                    1 ]\n     * </code>\n     * @param {number[]} vector - array[2] of numbers\n     * @returns {number[]} transformation result - array[2] of numbers\n     */\n    transform(vector) {\n        return [\n            vector[0] * this.a + vector[1] * this.c + this.tx,\n            vector[0] * this.b + vector[1] * this.d + this.ty\n        ]\n    };\n\n    /**\n     * Returns result of multiplication of this matrix by other matrix\n     * @param {Matrix} other_matrix - matrix to multiply by\n     * @returns {Matrix}\n     */\n    multiply(other_matrix) {\n        return new Matrix(\n            this.a * other_matrix.a + this.c * other_matrix.b,\n            this.b * other_matrix.a + this.d * other_matrix.b,\n            this.a * other_matrix.c + this.c * other_matrix.d,\n            this.b * other_matrix.c + this.d * other_matrix.d,\n            this.a * other_matrix.tx + this.c * other_matrix.ty + this.tx,\n            this.b * other_matrix.tx + this.d * other_matrix.ty + this.ty\n        )\n    };\n\n    /**\n     * Return new matrix as a result of multiplication of the current matrix\n     * by the matrix(1,0,0,1,tx,ty)\n     * @param {Vector} vector - Translation by vector or\n     * @param {number} tx - translation by x-axis\n     * @param {number} ty - translation by y-axis\n     * @returns {Matrix}\n     */\n    translate(...args) {\n        let tx, ty;\n        if (args.length == 1 &&  !isNaN(args[0].x) && !isNaN(args[0].y)) {\n            tx = args[0].x;\n            ty = args[0].y;\n        } else if (args.length === 2 && typeof (args[0]) == \"number\" && typeof (args[1]) == \"number\") {\n            tx = args[0];\n            ty = args[1];\n        } else {\n            throw Errors.ILLEGAL_PARAMETERS;\n        }\n        return this.multiply(new Matrix(1, 0, 0, 1, tx, ty))\n    };\n\n    /**\n     * Return new matrix as a result of multiplication of the current matrix\n     * by the matrix that defines rotation by given angle (in radians) around\n     * center of rotation (centerX,centerY) in counterclockwise direction\n     * @param {number} angle - angle in radians\n     * @param {number} centerX - center of rotation\n     * @param {number} centerY - center of rotation\n     * @returns {Matrix}\n     */\n    rotate(angle, centerX = 0.0, centerY = 0.0) {\n        let cos = Math.cos(angle);\n        let sin = Math.sin(angle);\n        return this\n            .translate(centerX, centerY)\n            .multiply(new Matrix(cos, sin, -sin, cos, 0, 0))\n            .translate(-centerX, -centerY);\n    };\n\n    /**\n     * Return new matrix as a result of multiplication of the current matrix\n     * by the matrix (sx,0,0,sy,0,0) that defines scaling\n     * @param {number} sx\n     * @param {number} sy\n     * @returns {Matrix}\n     */\n    scale(sx, sy) {\n        return this.multiply(new Matrix(sx, 0, 0, sy, 0, 0));\n    };\n\n    /**\n     * Returns true if two matrix are equal parameter by parameter\n     * @param {Matrix} matrix - other matrix\n     * @returns {boolean} true if equal, false otherwise\n     */\n    equalTo(matrix) {\n        if (!Flatten.Utils.EQ(this.tx, matrix.tx)) return false;\n        if (!Flatten.Utils.EQ(this.ty, matrix.ty)) return false;\n        if (!Flatten.Utils.EQ(this.a, matrix.a)) return false;\n        if (!Flatten.Utils.EQ(this.b, matrix.b)) return false;\n        if (!Flatten.Utils.EQ(this.c, matrix.c)) return false;\n        if (!Flatten.Utils.EQ(this.d, matrix.d)) return false;\n        return true;\n    };\n}\nFlatten.Matrix = Matrix;\n/**\n * Function to create matrix equivalent to \"new\" constructor\n * @param args\n */\nconst matrix = (...args) => new Flatten.Matrix(...args);\nFlatten.matrix = matrix;\n\n/**\n * Created by Alex Bol on 4/1/2017.\n */\n\n/**\n * Interval is a pair of numbers or a pair of any comparable objects on which may be defined predicates\n * *equal*, *less* and method *max(p1, p1)* that returns maximum in a pair.\n * When interval is an object rather than pair of numbers, this object should have properties *low*, *high*, *max*\n * and implement methods *less_than(), equal_to(), intersect(), not_intersect(), clone(), output()*.\n * Two static methods *comparable_max(), comparable_less_than()* define how to compare values in pair. <br/>\n * This interface is described in typescript definition file *index.d.ts*\n *\n * Axis aligned rectangle is an example of such interval.\n * We may look at rectangle as an interval between its low left and top right corners.\n * See **Box** class in [flatten-js](https://github.com/alexbol99/flatten-js) library as the example\n * of Interval interface implementation\n * @type {Interval}\n */\nconst Interval = class Interval {\n    /**\n     * Accept two comparable values and creates new instance of interval\n     * Predicate Interval.comparable_less(low, high) supposed to return true on these values\n     * @param low\n     * @param high\n     */\n    constructor(low, high) {\n        this.low = low;\n        this.high = high;\n    }\n\n    /**\n     * Clone interval\n     * @returns {Interval}\n     */\n    clone() {\n        return new Interval(this.low, this.high);\n    }\n\n    /**\n     * Propery max returns clone of this interval\n     * @returns {Interval}\n     */\n    get max() {\n        return this.clone();   // this.high;\n    }\n\n    /**\n     * Predicate returns true is this interval less than other interval\n     * @param other_interval\n     * @returns {boolean}\n     */\n    less_than(other_interval) {\n        return this.low < other_interval.low ||\n            this.low == other_interval.low && this.high < other_interval.high;\n    }\n\n    /**\n     * Predicate returns true is this interval equals to other interval\n     * @param other_interval\n     * @returns {boolean}\n     */\n    equal_to(other_interval) {\n        return this.low == other_interval.low && this.high == other_interval.high;\n    }\n\n    /**\n     * Predicate returns true if this interval intersects other interval\n     * @param other_interval\n     * @returns {boolean}\n     */\n    intersect(other_interval) {\n        return !this.not_intersect(other_interval);\n    }\n\n    /**\n     * Predicate returns true if this interval does not intersect other interval\n     * @param other_interval\n     * @returns {boolean}\n     */\n    not_intersect(other_interval) {\n        return (this.high < other_interval.low || other_interval.high < this.low);\n    }\n\n    /**\n     * Returns new interval merged with other interval\n     * @param {Interval} interval - Other interval to merge with\n     * @returns {Interval}\n     */\n    merge(other_interval) {\n        return new Interval(\n            this.low === undefined ? other_interval.low : Math.min(this.low, other_interval.low),\n            this.high === undefined ? other_interval.high : Math.max(this.high, other_interval.high)\n        );\n    }\n\n    /**\n     * Returns how key should return\n     */\n    output() {\n        return [this.low, this.high];\n    }\n\n    /**\n     * Function returns maximum between two comparable values\n     * @param interval1\n     * @param interval2\n     * @returns {Interval}\n     */\n    static comparable_max(interval1, interval2) {\n        return interval1.merge(interval2);\n    }\n\n    /**\n     * Predicate returns true if first value less than second value\n     * @param val1\n     * @param val2\n     * @returns {boolean}\n     */\n    static comparable_less_than(val1, val2 ) {\n        return val1 < val2;\n    }\n};\n\n/**\n * Created by Alex Bol on 3/28/2017.\n */\n\n\n// module.exports = {\n//     RB_TREE_COLOR_RED: 0,\n//     RB_TREE_COLOR_BLACK: 1\n// };\n\nconst RB_TREE_COLOR_RED = 0;\nconst RB_TREE_COLOR_BLACK = 1;\n\n/**\n * Created by Alex Bol on 4/1/2017.\n */\n\n\nclass Node {\n    constructor(key = undefined, value = undefined,\n                left = null, right = null, parent = null, color = RB_TREE_COLOR_BLACK) {\n        this.left = left;                     // reference to left child node\n        this.right = right;                   // reference to right child node\n        this.parent = parent;                 // reference to parent node\n        this.color = color;\n\n        this.item = {key: key, value: value};   // key is supposed to be instance of Interval\n\n        /* If not, this should by an array of two numbers */\n        if (key && key instanceof Array && key.length == 2) {\n            if (!Number.isNaN(key[0]) && !Number.isNaN(key[1])) {\n                this.item.key = new Interval(Math.min(key[0], key[1]), Math.max(key[0], key[1]));\n            }\n        }\n\n        this.max = this.item.key ? this.item.key.max : undefined;\n    }\n\n    isNil() {\n        return (this.item.key === undefined && this.item.value === undefined &&\n            this.left === null && this.right === null && this.color === RB_TREE_COLOR_BLACK);\n    }\n\n    _value_less_than(other_node) {\n        return this.item.value && other_node.item.value && this.item.value.less_than ?\n            this.item.value.less_than(other_node.item.value) :\n            this.item.value < other_node.item.value;\n    }\n\n    less_than(other_node) {\n        // if tree stores only keys\n        if (this.item.value === this.item.key && other_node.item.value === other_node.item.key) {\n            return this.item.key.less_than(other_node.item.key);\n        }\n        else {    // if tree stores keys and values\n            return this.item.key.less_than(other_node.item.key) ||\n                this.item.key.equal_to((other_node.item.key)) && this._value_less_than(other_node)\n        }\n    }\n\n    _value_equal(other_node) {\n        return this.item.value && other_node.item.value && this.item.value.equal_to ?\n            this.item.value.equal_to(other_node.item.value) :\n            this.item.value == other_node.item.value;\n    }\n    equal_to(other_node) {\n        // if tree stores only keys\n        if (this.item.value === this.item.key && other_node.item.value === other_node.item.key) {\n            return this.item.key.equal_to(other_node.item.key);\n        }\n        else {    // if tree stores keys and values\n            return this.item.key.equal_to(other_node.item.key) && this._value_equal(other_node);\n        }\n    }\n\n    intersect(other_node) {\n        return this.item.key.intersect(other_node.item.key);\n    }\n\n    copy_data(other_node) {\n        this.item.key = other_node.item.key;\n        this.item.value = other_node.item.value;\n    }\n\n    update_max() {\n        // use key (Interval) max property instead of key.high\n        this.max = this.item.key ? this.item.key.max : undefined;\n        if (this.right && this.right.max) {\n            const comparable_max = this.item.key.constructor.comparable_max;  // static method\n            this.max = comparable_max(this.max, this.right.max);\n        }\n        if (this.left && this.left.max) {\n            const comparable_max = this.item.key.constructor.comparable_max;  // static method\n            this.max = comparable_max(this.max, this.left.max);\n        }\n    }\n\n    // Other_node does not intersect any node of left subtree, if this.left.max < other_node.item.key.low\n    not_intersect_left_subtree(search_node) {\n        const comparable_less_than = this.item.key.constructor.comparable_less_than;  // static method\n        let high = this.left.max.high !== undefined ? this.left.max.high : this.left.max;\n        return comparable_less_than(high, search_node.item.key.low);\n    }\n\n    // Other_node does not intersect right subtree if other_node.item.key.high < this.right.key.low\n    not_intersect_right_subtree(search_node) {\n        const comparable_less_than = this.item.key.constructor.comparable_less_than;  // static method\n        let low = this.right.max.low !== undefined ? this.right.max.low : this.right.item.key.low;\n        return comparable_less_than(search_node.item.key.high, low);\n    }\n}\n\n/**\n * Created by Alex Bol on 3/31/2017.\n */\n\n// const nil_node = new Node();\n\n/**\n * Implementation of interval binary search tree <br/>\n * Interval tree stores items which are couples of {key:interval, value: value} <br/>\n * Interval is an object with high and low properties or simply pair [low,high] of numeric values <br />\n * @type {IntervalTree}\n */\nclass IntervalTree {\n    /**\n     * Construct new empty instance of IntervalTree\n     */\n    constructor() {\n        this.root = null;\n        this.nil_node = new Node();\n    }\n\n    /**\n     * Returns number of items stored in the interval tree\n     * @returns {number}\n     */\n    get size() {\n        let count = 0;\n        this.tree_walk(this.root, () => count++);\n        return count;\n    }\n\n    /**\n     * Returns array of sorted keys in the ascending order\n     * @returns {Array}\n     */\n    get keys() {\n        let res = [];\n        this.tree_walk(this.root, (node) => res.push(\n            node.item.key.output ? node.item.key.output() : node.item.key\n        ));\n        return res;\n    }\n\n    /**\n     * Return array of values in the ascending keys order\n     * @returns {Array}\n     */\n    get values() {\n        let res = [];\n        this.tree_walk(this.root, (node) => res.push(node.item.value));\n        return res;\n    }\n\n    /**\n     * Returns array of items (<key,value> pairs) in the ascended keys order\n     * @returns {Array}\n     */\n    get items() {\n        let res = [];\n        this.tree_walk(this.root, (node) => res.push({\n            key: node.item.key.output ? node.item.key.output() : node.item.key,\n            value: node.item.value\n        }));\n        return res;\n    }\n\n    /**\n     * Returns true if tree is empty\n     * @returns {boolean}\n     */\n    isEmpty() {\n        return (this.root == null || this.root == this.nil_node);\n    }\n\n    /**\n     * Clear tree\n     */\n    clear() {\n        this.root = null;\n    }\n\n    /**\n     * Insert new item into interval tree\n     * @param {Interval} key - interval object or array of two numbers [low, high]\n     * @param {any} value - value representing any object (optional)\n     * @returns {Node} returns reference to inserted node as an object {key:interval, value: value}\n     */\n    insert(key, value = key) {\n        if (key === undefined) return;\n        let insert_node = new Node(key, value, this.nil_node, this.nil_node, null, RB_TREE_COLOR_RED);\n        this.tree_insert(insert_node);\n        this.recalc_max(insert_node);\n        return insert_node;\n    }\n\n    /**\n     * Returns true if item {key,value} exist in the tree\n     * @param {Interval} key - interval correspondent to keys stored in the tree\n     * @param {any} value - value object to be checked\n     * @returns {boolean} true if item {key, value} exist in the tree, false otherwise\n     */\n    exist(key, value = key) {\n        let search_node = new Node(key, value);\n        return this.tree_search(this.root, search_node) ? true : false;\n    }\n\n    /**\n     * Remove entry {key, value} from the tree\n     * @param {Interval} key - interval correspondent to keys stored in the tree\n     * @param {any} value - value object\n     * @returns {boolean} true if item {key, value} deleted, false if not found\n     */\n    remove(key, value = key) {\n        let search_node = new Node(key, value);\n        let delete_node = this.tree_search(this.root, search_node);\n        if (delete_node) {\n            this.tree_delete(delete_node);\n        }\n        return delete_node;\n    }\n\n    /**\n     * Returns array of entry values which keys intersect with given interval <br/>\n     * If no values stored in the tree, returns array of keys which intersect given interval\n     * @param {Interval} interval - search interval, or tuple [low, high]\n     * @param outputMapperFn(value,key) - optional function that maps (value, key) to custom output\n     * @returns {Array}\n     */\n    search(interval, outputMapperFn = (value, key) => value === key ? key.output() : value) {\n        let search_node = new Node(interval);\n        let resp_nodes = [];\n        this.tree_search_interval(this.root, search_node, resp_nodes);\n        return resp_nodes.map(node => outputMapperFn(node.item.value, node.item.key))\n    }\n\n    /**\n     * Returns true if intersection between given and any interval stored in the tree found\n     * @param {Interval} interval - search interval or tuple [low, high]\n     * @returns {boolean}\n     */\n    intersect_any(interval) {\n        let search_node = new Node(interval);\n        let found = this.tree_find_any_interval(this.root, search_node);\n        return found;\n    }\n\n    /**\n     * Tree visitor. For each node implement a callback function. <br/>\n     * Method calls a callback function with two parameters (key, value)\n     * @param visitor(key,value) - function to be called for each tree item\n     */\n    forEach(visitor) {\n        this.tree_walk(this.root, (node) => visitor(node.item.key, node.item.value));\n    }\n\n    /** Value Mapper. Walk through every node and map node value to another value\n    * @param callback(value,key) - function to be called for each tree item\n    */\n    map(callback) {\n        const tree = new IntervalTree();\n        this.tree_walk(this.root, (node) => tree.insert(node.item.key, callback(node.item.value, node.item.key)));\n        return tree;\n    }\n\n    recalc_max(node) {\n        let node_current = node;\n        while (node_current.parent != null) {\n            node_current.parent.update_max();\n            node_current = node_current.parent;\n        }\n    }\n\n    tree_insert(insert_node) {\n        let current_node = this.root;\n        let parent_node = null;\n\n        if (this.root == null || this.root == this.nil_node) {\n            this.root = insert_node;\n        }\n        else {\n            while (current_node != this.nil_node) {\n                parent_node = current_node;\n                if (insert_node.less_than(current_node)) {\n                    current_node = current_node.left;\n                }\n                else {\n                    current_node = current_node.right;\n                }\n            }\n\n            insert_node.parent = parent_node;\n\n            if (insert_node.less_than(parent_node)) {\n                parent_node.left = insert_node;\n            }\n            else {\n                parent_node.right = insert_node;\n            }\n        }\n\n        this.insert_fixup(insert_node);\n    }\n\n// After insertion insert_node may have red-colored parent, and this is a single possible violation\n// Go upwords to the root and re-color until violation will be resolved\n    insert_fixup(insert_node) {\n        let current_node;\n        let uncle_node;\n\n        current_node = insert_node;\n        while (current_node != this.root && current_node.parent.color == RB_TREE_COLOR_RED) {\n            if (current_node.parent == current_node.parent.parent.left) {   // parent is left child of grandfather\n                uncle_node = current_node.parent.parent.right;              // right brother of parent\n                if (uncle_node.color == RB_TREE_COLOR_RED) {             // Case 1. Uncle is red\n                    // re-color father and uncle into black\n                    current_node.parent.color = RB_TREE_COLOR_BLACK;\n                    uncle_node.color = RB_TREE_COLOR_BLACK;\n                    current_node.parent.parent.color = RB_TREE_COLOR_RED;\n                    current_node = current_node.parent.parent;\n                }\n                else {                                                    // Case 2 & 3. Uncle is black\n                    if (current_node == current_node.parent.right) {     // Case 2. Current if right child\n                        // This case is transformed into Case 3.\n                        current_node = current_node.parent;\n                        this.rotate_left(current_node);\n                    }\n                    current_node.parent.color = RB_TREE_COLOR_BLACK;    // Case 3. Current is left child.\n                    // Re-color father and grandfather, rotate grandfather right\n                    current_node.parent.parent.color = RB_TREE_COLOR_RED;\n                    this.rotate_right(current_node.parent.parent);\n                }\n            }\n            else {                                                         // parent is right child of grandfather\n                uncle_node = current_node.parent.parent.left;              // left brother of parent\n                if (uncle_node.color == RB_TREE_COLOR_RED) {             // Case 4. Uncle is red\n                    // re-color father and uncle into black\n                    current_node.parent.color = RB_TREE_COLOR_BLACK;\n                    uncle_node.color = RB_TREE_COLOR_BLACK;\n                    current_node.parent.parent.color = RB_TREE_COLOR_RED;\n                    current_node = current_node.parent.parent;\n                }\n                else {\n                    if (current_node == current_node.parent.left) {             // Case 5. Current is left child\n                        // Transform into case 6\n                        current_node = current_node.parent;\n                        this.rotate_right(current_node);\n                    }\n                    current_node.parent.color = RB_TREE_COLOR_BLACK;    // Case 6. Current is right child.\n                    // Re-color father and grandfather, rotate grandfather left\n                    current_node.parent.parent.color = RB_TREE_COLOR_RED;\n                    this.rotate_left(current_node.parent.parent);\n                }\n            }\n        }\n\n        this.root.color = RB_TREE_COLOR_BLACK;\n    }\n\n    tree_delete(delete_node) {\n        let cut_node;   // node to be cut - either delete_node or successor_node  (\"y\" from 14.4)\n        let fix_node;   // node to fix rb tree property   (\"x\" from 14.4)\n\n        if (delete_node.left == this.nil_node || delete_node.right == this.nil_node) {  // delete_node has less then 2 children\n            cut_node = delete_node;\n        }\n        else {                                                    // delete_node has 2 children\n            cut_node = this.tree_successor(delete_node);\n        }\n\n        // fix_node if single child of cut_node\n        if (cut_node.left != this.nil_node) {\n            fix_node = cut_node.left;\n        }\n        else {\n            fix_node = cut_node.right;\n        }\n\n        // remove cut_node from parent\n        /*if (fix_node != this.nil_node) {*/\n            fix_node.parent = cut_node.parent;\n        /*}*/\n\n        if (cut_node == this.root) {\n            this.root = fix_node;\n        }\n        else {\n            if (cut_node == cut_node.parent.left) {\n                cut_node.parent.left = fix_node;\n            }\n            else {\n                cut_node.parent.right = fix_node;\n            }\n            cut_node.parent.update_max();        // update max property of the parent\n        }\n\n        this.recalc_max(fix_node);              // update max property upward from fix_node to root\n\n        // COPY DATA !!!\n        // Delete_node becomes cut_node, it means that we cannot hold reference\n        // to node in outer structure and we will have to delete by key, additional search need\n        if (cut_node != delete_node) {\n            delete_node.copy_data(cut_node);\n            delete_node.update_max();           // update max property of the cut node at the new place\n            this.recalc_max(delete_node);       // update max property upward from delete_node to root\n        }\n\n        if (/*fix_node != this.nil_node && */cut_node.color == RB_TREE_COLOR_BLACK) {\n            this.delete_fixup(fix_node);\n        }\n    }\n\n    delete_fixup(fix_node) {\n        let current_node = fix_node;\n        let brother_node;\n\n        while (current_node != this.root && current_node.parent != null && current_node.color == RB_TREE_COLOR_BLACK) {\n            if (current_node == current_node.parent.left) {          // fix node is left child\n                brother_node = current_node.parent.right;\n                if (brother_node.color == RB_TREE_COLOR_RED) {   // Case 1. Brother is red\n                    brother_node.color = RB_TREE_COLOR_BLACK;         // re-color brother\n                    current_node.parent.color = RB_TREE_COLOR_RED;    // re-color father\n                    this.rotate_left(current_node.parent);\n                    brother_node = current_node.parent.right;                      // update brother\n                }\n                // Derive to cases 2..4: brother is black\n                if (brother_node.left.color == RB_TREE_COLOR_BLACK &&\n                    brother_node.right.color == RB_TREE_COLOR_BLACK) {  // case 2: both nephews black\n                    brother_node.color = RB_TREE_COLOR_RED;              // re-color brother\n                    current_node = current_node.parent;                  // continue iteration\n                }\n                else {\n                    if (brother_node.right.color == RB_TREE_COLOR_BLACK) {   // case 3: left nephew red, right nephew black\n                        brother_node.color = RB_TREE_COLOR_RED;          // re-color brother\n                        brother_node.left.color = RB_TREE_COLOR_BLACK;   // re-color nephew\n                        this.rotate_right(brother_node);\n                        brother_node = current_node.parent.right;                     // update brother\n                        // Derive to case 4: left nephew black, right nephew red\n                    }\n                    // case 4: left nephew black, right nephew red\n                    brother_node.color = current_node.parent.color;\n                    current_node.parent.color = RB_TREE_COLOR_BLACK;\n                    brother_node.right.color = RB_TREE_COLOR_BLACK;\n                    this.rotate_left(current_node.parent);\n                    current_node = this.root;                         // exit from loop\n                }\n            }\n            else {                                             // fix node is right child\n                brother_node = current_node.parent.left;\n                if (brother_node.color == RB_TREE_COLOR_RED) {   // Case 1. Brother is red\n                    brother_node.color = RB_TREE_COLOR_BLACK;         // re-color brother\n                    current_node.parent.color = RB_TREE_COLOR_RED;    // re-color father\n                    this.rotate_right(current_node.parent);\n                    brother_node = current_node.parent.left;                        // update brother\n                }\n                // Go to cases 2..4\n                if (brother_node.left.color == RB_TREE_COLOR_BLACK &&\n                    brother_node.right.color == RB_TREE_COLOR_BLACK) {   // case 2\n                    brother_node.color = RB_TREE_COLOR_RED;             // re-color brother\n                    current_node = current_node.parent;                              // continue iteration\n                }\n                else {\n                    if (brother_node.left.color == RB_TREE_COLOR_BLACK) {  // case 3: right nephew red, left nephew black\n                        brother_node.color = RB_TREE_COLOR_RED;            // re-color brother\n                        brother_node.right.color = RB_TREE_COLOR_BLACK;    // re-color nephew\n                        this.rotate_left(brother_node);\n                        brother_node = current_node.parent.left;                        // update brother\n                        // Derive to case 4: right nephew black, left nephew red\n                    }\n                    // case 4: right nephew black, left nephew red\n                    brother_node.color = current_node.parent.color;\n                    current_node.parent.color = RB_TREE_COLOR_BLACK;\n                    brother_node.left.color = RB_TREE_COLOR_BLACK;\n                    this.rotate_right(current_node.parent);\n                    current_node = this.root;                               // force exit from loop\n                }\n            }\n        }\n\n        current_node.color = RB_TREE_COLOR_BLACK;\n    }\n\n    tree_search(node, search_node) {\n        if (node == null || node == this.nil_node)\n            return undefined;\n\n        if (search_node.equal_to(node)) {\n            return node;\n        }\n        if (search_node.less_than(node)) {\n            return this.tree_search(node.left, search_node);\n        }\n        else {\n            return this.tree_search(node.right, search_node);\n        }\n    }\n\n    // Original search_interval method; container res support push() insertion\n    // Search all intervals intersecting given one\n    tree_search_interval(node, search_node, res) {\n        if (node != null && node != this.nil_node) {\n            // if (node->left != this.nil_node && node->left->max >= low) {\n            if (node.left != this.nil_node && !node.not_intersect_left_subtree(search_node)) {\n                this.tree_search_interval(node.left, search_node, res);\n            }\n            // if (low <= node->high && node->low <= high) {\n            if (node.intersect(search_node)) {\n                res.push(node);\n            }\n            // if (node->right != this.nil_node && node->low <= high) {\n            if (node.right != this.nil_node && !node.not_intersect_right_subtree(search_node)) {\n                this.tree_search_interval(node.right, search_node, res);\n            }\n        }\n    }\n\n    tree_find_any_interval(node, search_node) {\n        let found = false;\n        if (node != null && node != this.nil_node) {\n            // if (node->left != this.nil_node && node->left->max >= low) {\n            if (node.left != this.nil_node && !node.not_intersect_left_subtree(search_node)) {\n                found = this.tree_find_any_interval(node.left, search_node);\n            }\n            // if (low <= node->high && node->low <= high) {\n            if (!found) {\n                found = node.intersect(search_node);\n            }\n            // if (node->right != this.nil_node && node->low <= high) {\n            if (!found && node.right != this.nil_node && !node.not_intersect_right_subtree(search_node)) {\n                found = this.tree_find_any_interval(node.right, search_node);\n            }\n        }\n        return found;\n    }\n\n    local_minimum(node) {\n        let node_min = node;\n        while (node_min.left != null && node_min.left != this.nil_node) {\n            node_min = node_min.left;\n        }\n        return node_min;\n    }\n\n    // not in use\n    local_maximum(node) {\n        let node_max = node;\n        while (node_max.right != null && node_max.right != this.nil_node) {\n            node_max = node_max.right;\n        }\n        return node_max;\n    }\n\n    tree_successor(node) {\n        let node_successor;\n        let current_node;\n        let parent_node;\n\n        if (node.right != this.nil_node) {\n            node_successor = this.local_minimum(node.right);\n        }\n        else {\n            current_node = node;\n            parent_node = node.parent;\n            while (parent_node != null && parent_node.right == current_node) {\n                current_node = parent_node;\n                parent_node = parent_node.parent;\n            }\n            node_successor = parent_node;\n        }\n        return node_successor;\n    }\n\n    //           |            right-rotate(T,y)       |\n    //           y            ---------------.       x\n    //          / \\                                  / \\\n    //         x   c          left-rotate(T,x)      a   y\n    //        / \\             <---------------         / \\\n    //       a   b                                    b   c\n\n    rotate_left(x) {\n        let y = x.right;\n\n        x.right = y.left;           // b goes to x.right\n\n        if (y.left != this.nil_node) {\n            y.left.parent = x;     // x becomes parent of b\n        }\n        y.parent = x.parent;       // move parent\n\n        if (x == this.root) {\n            this.root = y;           // y becomes root\n        }\n        else {                        // y becomes child of x.parent\n            if (x == x.parent.left) {\n                x.parent.left = y;\n            }\n            else {\n                x.parent.right = y;\n            }\n        }\n        y.left = x;                 // x becomes left child of y\n        x.parent = y;               // and y becomes parent of x\n\n        if (x != null && x != this.nil_node) {\n            x.update_max();\n        }\n\n        y = x.parent;\n        if (y != null && y != this.nil_node) {\n            y.update_max();\n        }\n    }\n\n    rotate_right(y) {\n        let x = y.left;\n\n        y.left = x.right;           // b goes to y.left\n\n        if (x.right != this.nil_node) {\n            x.right.parent = y;        // y becomes parent of b\n        }\n        x.parent = y.parent;          // move parent\n\n        if (y == this.root) {        // x becomes root\n            this.root = x;\n        }\n        else {                        // y becomes child of x.parent\n            if (y == y.parent.left) {\n                y.parent.left = x;\n            }\n            else {\n                y.parent.right = x;\n            }\n        }\n        x.right = y;                 // y becomes right child of x\n        y.parent = x;               // and x becomes parent of y\n\n        if (y != null && y != this.nil_node) {\n            y.update_max();\n        }\n\n        x = y.parent;\n        if (x != null && x != this.nil_node) {\n            x.update_max();\n        }\n    }\n\n    tree_walk(node, action) {\n        if (node != null && node != this.nil_node) {\n            this.tree_walk(node.left, action);\n            // arr.push(node.toArray());\n            action(node);\n            this.tree_walk(node.right, action);\n        }\n    }\n\n    /* Return true if all red nodes have exactly two black child nodes */\n    testRedBlackProperty() {\n        let res = true;\n        this.tree_walk(this.root, function (node) {\n            if (node.color == RB_TREE_COLOR_RED) {\n                if (!(node.left.color == RB_TREE_COLOR_BLACK && node.right.color == RB_TREE_COLOR_BLACK)) {\n                    res = false;\n                }\n            }\n        });\n        return res;\n    }\n\n    /* Throw error if not every path from root to bottom has same black height */\n    testBlackHeightProperty(node) {\n        let height = 0;\n        let heightLeft = 0;\n        let heightRight = 0;\n        if (node.color == RB_TREE_COLOR_BLACK) {\n            height++;\n        }\n        if (node.left != this.nil_node) {\n            heightLeft = this.testBlackHeightProperty(node.left);\n        }\n        else {\n            heightLeft = 1;\n        }\n        if (node.right != this.nil_node) {\n            heightRight = this.testBlackHeightProperty(node.right);\n        }\n        else {\n            heightRight = 1;\n        }\n        if (heightLeft != heightRight) {\n            throw new Error('Red-black height property violated');\n        }\n        height += heightLeft;\n        return height;\n    };\n}\n\n/**\n * Created by Alex Bol on 3/12/2017.\n */\n\n\n/**\n * Class representing a planar set - a generic container with ability to keep and retrieve shapes and\n * perform spatial queries. Planar set is an extension of Set container, so it supports\n * Set properties and methods\n */\nclass PlanarSet extends Set {\n    /**\n     * Create new instance of PlanarSet\n     * @param shapes - array or set of geometric objects to store in planar set\n     * Each object should have a <b>box</b> property\n     */\n    constructor(shapes) {\n        super(shapes);\n        this.index = new IntervalTree();\n        this.forEach(shape => this.index.insert(shape));\n    }\n\n    /**\n     * Add new shape to planar set and to its spatial index.<br/>\n     * If shape already exist, it will not be added again.\n     * This happens with no error, it is possible to use <i>size</i> property to check if\n     * a shape was actually added.<br/>\n     * Method returns planar set object updated and may be chained\n     * @param {AnyShape | {Box, AnyShape}} entry - shape to be added, should have valid <i>box</i> property\n     * Another option to transfer as an object {key: Box, value: AnyShape}\n     * @returns {PlanarSet}\n     */\n    add(entry) {\n        let size = this.size;\n        const {key, value} = entry;\n        const box = key || entry.box;\n        const shape = value || entry;\n        super.add(shape);\n        // size not changed - item not added, probably trying to add same item twice\n        if (this.size > size) {\n            this.index.insert(box, shape);\n        }\n        return this;         // in accordance to Set.add interface\n    }\n\n    /**\n     * Delete shape from planar set. Returns true if shape was actually deleted, false otherwise\n     * @param {AnyShape | {Box, AnyShape}} entry - shape to be deleted\n     * @returns {boolean}\n     */\n    delete(entry) {\n        const {key, value} = entry;\n        const box = key || entry.box;\n        const shape = value || entry;\n        let deleted = super.delete(shape);\n        if (deleted) {\n            this.index.remove(box, shape);\n        }\n        return deleted;\n    }\n\n    /**\n     * Clear planar set\n     */\n    clear() {\n        super.clear();\n        this.index = new IntervalTree();\n    }\n\n    /**\n     * 2d range search in planar set.<br/>\n     * Returns array of all shapes in planar set which bounding box is intersected with query box\n     * @param {Box} box - query box\n     * @returns {AnyShape[]}\n     */\n    search(box) {\n        let resp = this.index.search(box);\n        return resp;\n    }\n\n    /**\n     * Point location test. Returns array of shapes which contains given point\n     * @param {Point} point - query point\n     * @returns {AnyShape[]}\n     */\n    hit(point) {\n        let box = new Flatten.Box(point.x - 1, point.y - 1, point.x + 1, point.y + 1);\n        let resp = this.index.search(box);\n        return resp.filter((shape) => point.on(shape));\n    }\n\n    /**\n     * Returns svg string to draw all shapes in planar set\n     * @returns {String}\n     */\n    svg() {\n        let svgcontent = [...this].reduce((acc, shape) => acc + shape.svg(), \"\");\n        return svgcontent;\n    }\n}\n\nFlatten.PlanarSet = PlanarSet;\n\n/**\n * Base class representing shape\n * Implement common methods of affine transformations\n */\nclass Shape {\n    get name() {\n        throw(Errors.CANNOT_INVOKE_ABSTRACT_METHOD);\n    }\n\n    get box() {\n        throw(Errors.CANNOT_INVOKE_ABSTRACT_METHOD);\n    }\n\n    clone() {\n        throw(Errors.CANNOT_INVOKE_ABSTRACT_METHOD);\n    }\n\n    /**\n     * Returns new shape translated by given vector.\n     * Translation vector may be also defined by a pair of numbers.\n     * @param {Vector | (number, number) } args - Translation vector\n     * or tuple of numbers\n     * @returns {Shape}\n     */\n    translate(...args) {\n        return this.transform(new Matrix().translate(...args))\n    }\n\n    /**\n     * Returns new shape rotated by given angle around given center point.\n     * If center point is omitted, rotates around zero point (0,0).\n     * Positive value of angle defines rotation in counterclockwise direction,\n     * negative angle defines rotation in clockwise direction\n     * @param {number} angle - angle in radians\n     * @param {Point} [center=(0,0)] center\n     * @returns {Shape}\n     */\n    rotate(angle, center = new Flatten.Point()) {\n        return this.transform(new Matrix().rotate(angle, center.x, center.y));\n    }\n\n    /**\n     * Return new shape with coordinates multiplied by scaling factor\n     * @param {number} sx - x-axis scaling factor\n     * @param {number} sy - y-axis scaling factor\n     * @returns {Shape}\n     */\n    scale(sx, sy) {\n        return this.transform(new Matrix().scale(sx, sy));\n    }\n\n    transform(...args) {\n        throw(Errors.CANNOT_INVOKE_ABSTRACT_METHOD);\n    }\n\n    /**\n     * This method returns an object that defines how data will be\n     * serialized when called JSON.stringify() method\n     * @returns {Object}\n     */\n    toJSON() {\n        return Object.assign({}, this, {name: this.name});\n    }\n\n    svg(attrs = {}) {\n        throw(Errors.CANNOT_INVOKE_ABSTRACT_METHOD);\n    }\n}\n\n/**\n * Created by Alex Bol on 2/18/2017.\n */\n\n\n/**\n *\n * Class representing a point\n * @type {Point}\n */\nlet Point$1 = class Point extends Shape {\n    /**\n     * Point may be constructed by two numbers, or by array of two numbers\n     * @param {number} x - x-coordinate (float number)\n     * @param {number} y - y-coordinate (float number)\n     */\n    constructor(...args) {\n        super();\n        /**\n         * x-coordinate (float number)\n         * @type {number}\n         */\n        this.x = 0;\n        /**\n         * y-coordinate (float number)\n         * @type {number}\n         */\n        this.y = 0;\n\n        if (args.length === 0) {\n            return;\n        }\n\n        if (args.length === 1 && args[0] instanceof Array && args[0].length === 2) {\n            let arr = args[0];\n            if (typeof (arr[0]) == \"number\" && typeof (arr[1]) == \"number\") {\n                this.x = arr[0];\n                this.y = arr[1];\n                return;\n            }\n        }\n\n        if (args.length === 1 && args[0] instanceof Object && args[0].name === \"point\") {\n            let {x, y} = args[0];\n            this.x = x;\n            this.y = y;\n            return;\n        }\n\n        if (args.length === 2) {\n            if (typeof (args[0]) == \"number\" && typeof (args[1]) == \"number\") {\n                this.x = args[0];\n                this.y = args[1];\n                return;\n            }\n        }\n        throw Errors.ILLEGAL_PARAMETERS;\n    }\n\n    /**\n     * Returns bounding box of a point\n     * @returns {Box}\n     */\n    get box() {\n        return new Flatten.Box(this.x, this.y, this.x, this.y);\n    }\n\n    /**\n     * Return new cloned instance of point\n     * @returns {Point}\n     */\n    clone() {\n        return new Flatten.Point(this.x, this.y);\n    }\n\n    get vertices() {\n        return [this.clone()];\n    }\n\n    /**\n     * Returns true if points are equal up to [Flatten.Utils.DP_TOL]{@link DP_TOL} tolerance\n     * @param {Point} pt Query point\n     * @returns {boolean}\n     */\n    equalTo(pt) {\n        return Flatten.Utils.EQ(this.x, pt.x) && Flatten.Utils.EQ(this.y, pt.y);\n    }\n\n    /**\n     * Defines predicate \"less than\" between points. Returns true if the point is less than query points, false otherwise <br/>\n     * By definition point1 < point2 if {point1.y < point2.y || point1.y == point2.y && point1.x < point2.x <br/>\n     * Numeric values compared with [Flatten.Utils.DP_TOL]{@link DP_TOL} tolerance\n     * @param {Point} pt Query point\n     * @returns {boolean}\n     */\n    lessThan(pt) {\n        if (Flatten.Utils.LT(this.y, pt.y))\n            return true;\n        if (Flatten.Utils.EQ(this.y, pt.y) && Flatten.Utils.LT(this.x, pt.x))\n            return true;\n        return false;\n    }\n\n    /**\n     * Return new point transformed by affine transformation matrix\n     * @param {Matrix} m - affine transformation matrix (a,b,c,d,tx,ty)\n     * @returns {Point}\n     */\n    transform(m) {\n        return new Flatten.Point(m.transform([this.x, this.y]))\n    }\n\n    /**\n     * Returns projection point on given line\n     * @param {Line} line Line this point be projected on\n     * @returns {Point}\n     */\n    projectionOn(line) {\n        if (this.equalTo(line.pt))                   // this point equal to line anchor point\n            return this.clone();\n\n        let vec = new Flatten.Vector(this, line.pt);\n        if (Flatten.Utils.EQ_0(vec.cross(line.norm)))    // vector to point from anchor point collinear to normal vector\n            return line.pt.clone();\n\n        let dist = vec.dot(line.norm);             // signed distance\n        let proj_vec = line.norm.multiply(dist);\n        return this.translate(proj_vec);\n    }\n\n    /**\n     * Returns true if point belongs to the \"left\" semi-plane, which means, point belongs to the same semi plane where line normal vector points to\n     * Return false if point belongs to the \"right\" semi-plane or to the line itself\n     * @param {Line} line Query line\n     * @returns {boolean}\n     */\n    leftTo(line) {\n        let vec = new Flatten.Vector(line.pt, this);\n        let onLeftSemiPlane = Flatten.Utils.GT(vec.dot(line.norm), 0);\n        return onLeftSemiPlane;\n    }\n\n    /**\n     * Calculate distance and shortest segment from point to shape and return as array [distance, shortest segment]\n     * @param {Shape} shape Shape of the one of supported types Point, Line, Circle, Segment, Arc, Polygon or Planar Set\n     * @returns {number} distance from point to shape\n     * @returns {Segment} shortest segment between point and shape (started at point, ended at shape)\n     */\n    distanceTo(shape) {\n        if (shape instanceof Point) {\n            let dx = shape.x - this.x;\n            let dy = shape.y - this.y;\n            return [Math.sqrt(dx * dx + dy * dy), new Flatten.Segment(this, shape)];\n        }\n\n        if (shape instanceof Flatten.Line) {\n            return Flatten.Distance.point2line(this, shape);\n        }\n\n        if (shape instanceof Flatten.Circle) {\n            return Flatten.Distance.point2circle(this, shape);\n        }\n\n        if (shape instanceof Flatten.Segment) {\n            return Flatten.Distance.point2segment(this, shape);\n        }\n\n        if (shape instanceof Flatten.Arc) {\n            return Flatten.Distance.point2arc(this, shape);\n        }\n\n        if (shape instanceof Flatten.Polygon) {\n            return Flatten.Distance.point2polygon(this, shape);\n        }\n\n        if (shape instanceof Flatten.PlanarSet) {\n            return Flatten.Distance.shape2planarSet(this, shape);\n        }\n    }\n\n    /**\n     * Returns true if point is on a shape, false otherwise\n     * @param {Shape} shape\n     * @returns {boolean}\n     */\n    on(shape) {\n        if (shape instanceof Flatten.Point) {\n            return this.equalTo(shape);\n        }\n\n        if (shape instanceof Flatten.Box) {\n            return shape.contains(this);\n        }\n\n        if (shape instanceof Flatten.Line) {\n            return shape.contains(this);\n        }\n\n        if (shape instanceof Flatten.Ray) {\n            return shape.contains(this)\n        }\n\n        if (shape instanceof Flatten.Circle) {\n            return shape.contains(this);\n        }\n\n        if (shape instanceof Flatten.Segment) {\n            return shape.contains(this);\n        }\n\n        if (shape instanceof Flatten.Arc) {\n            return shape.contains(this);\n        }\n\n        if (shape instanceof Flatten.Polygon) {\n            return shape.contains(this);\n        }\n    }\n\n    get name() {\n        return \"point\"\n    }\n\n    /**\n     * Return string to draw point in svg as circle with radius \"r\" <br/>\n     * Accept any valid attributes of svg elements as svg object\n     * Defaults attribues are: <br/>\n     * {\n     *    r:\"3\",\n     *    stroke:\"black\",\n     *    strokeWidth:\"1\",\n     *    fill:\"red\"\n     * }\n     * @param {Object} attrs - Any valid attributes of svg circle element, like \"r\", \"stroke\", \"strokeWidth\", \"fill\"\n     * @returns {String}\n     */\n    svg(attrs = {}) {\n        const r = attrs.r ?? 3;            // default radius - 3\n        return `\\n<circle cx=\"${this.x}\" cy=\"${this.y}\" r=\"${r}\"\n            ${convertToString({fill: \"red\", ...attrs})} />`;\n    }\n};\n\nFlatten.Point = Point$1;\n/**\n * Function to create point equivalent to \"new\" constructor\n * @param args\n */\nconst point = (...args) => new Flatten.Point(...args);\nFlatten.point = point;\n\n// export {Point};\n\n/**\n * Created by Alex Bol on 2/19/2017.\n */\n\n\n/**\n * Class representing a vector\n * @type {Vector}\n */\nlet Vector$1 = class Vector extends Shape {\n    /**\n     * Vector may be constructed by two points, or by two float numbers,\n     * or by array of two numbers\n     * @param {Point} ps - start point\n     * @param {Point} pe - end point\n     */\n    constructor(...args) {\n        super();\n        /**\n         * x-coordinate of a vector (float number)\n         * @type {number}\n         */\n        this.x = 0;\n        /**\n         * y-coordinate of a vector (float number)\n         * @type {number}\n         */\n        this.y = 0;\n\n        /* return zero vector */\n        if (args.length === 0) {\n            return;\n        }\n\n        if (args.length === 1 && args[0] instanceof Array && args[0].length === 2) {\n            let arr = args[0];\n            if (typeof (arr[0]) == \"number\" && typeof (arr[1]) == \"number\") {\n                this.x = arr[0];\n                this.y = arr[1];\n                return;\n            }\n        }\n\n        if (args.length === 1 && args[0] instanceof Object && args[0].name === \"vector\") {\n            let {x, y} = args[0];\n            this.x = x;\n            this.y = y;\n            return;\n        }\n\n        if (args.length === 2) {\n            let a1 = args[0];\n            let a2 = args[1];\n\n            if (typeof (a1) == \"number\" && typeof (a2) == \"number\") {\n                this.x = a1;\n                this.y = a2;\n                return;\n            }\n\n            if (a1 instanceof Flatten.Point && a2 instanceof Flatten.Point) {\n                this.x = a2.x - a1.x;\n                this.y = a2.y - a1.y;\n                return;\n            }\n\n        }\n\n        throw Errors.ILLEGAL_PARAMETERS;\n    }\n\n    /**\n     * Method clone returns new instance of Vector\n     * @returns {Vector}\n     */\n    clone() {\n        return new Flatten.Vector(this.x, this.y);\n    }\n\n    /**\n     * Slope of the vector in radians from 0 to 2PI\n     * @returns {number}\n     */\n    get slope() {\n        let angle = Math.atan2(this.y, this.x);\n        if (angle < 0) angle = 2 * Math.PI + angle;\n        return angle;\n    }\n\n    /**\n     * Length of vector\n     * @returns {number}\n     */\n    get length() {\n        return Math.sqrt(this.dot(this));\n    }\n\n    /**\n     * Returns true if vectors are equal up to [DP_TOL]{@link http://localhost:63342/flatten-js/docs/global.html#DP_TOL}\n     * tolerance\n     * @param {Vector} v\n     * @returns {boolean}\n     */\n    equalTo(v) {\n        return Flatten.Utils.EQ(this.x, v.x) && Flatten.Utils.EQ(this.y, v.y);\n    }\n\n    /**\n     * Returns new vector multiplied by scalar\n     * @param {number} scalar\n     * @returns {Vector}\n     */\n    multiply(scalar) {\n        return (new Flatten.Vector(scalar * this.x, scalar * this.y));\n    }\n\n    /**\n     * Returns scalar product (dot product) of two vectors <br/>\n     * <code>dot_product = (this * v)</code>\n     * @param {Vector} v Other vector\n     * @returns {number}\n     */\n    dot(v) {\n        return (this.x * v.x + this.y * v.y);\n    }\n\n    /**\n     * Returns vector product (cross product) of two vectors <br/>\n     * <code>cross_product = (this x v)</code>\n     * @param {Vector} v Other vector\n     * @returns {number}\n     */\n    cross(v) {\n        return (this.x * v.y - this.y * v.x);\n    }\n\n    /**\n     * Returns unit vector.<br/>\n     * Throw error if given vector has zero length\n     * @returns {Vector}\n     */\n    normalize() {\n        if (!Flatten.Utils.EQ_0(this.length)) {\n            return (new Flatten.Vector(this.x / this.length, this.y / this.length));\n        }\n        throw Errors.ZERO_DIVISION;\n    }\n\n    /**\n     * Returns new vector rotated by given angle,\n     * positive angle defines rotation in counterclockwise direction,\n     * negative - in clockwise direction\n     * Vector only can be rotated around (0,0) point!\n     * @param {number} angle - Angle in radians\n     * @returns {Vector}\n     */\n    rotate(angle, center = new Flatten.Point()) {\n        if (center.x === 0 && center.y === 0) {\n            return this.transform(new Matrix().rotate(angle));\n        }\n        throw(Errors.OPERATION_IS_NOT_SUPPORTED);\n    }\n\n    /**\n     * Return new vector transformed by affine transformation matrix m\n     * @param {Matrix} m - affine transformation matrix (a,b,c,d,tx,ty)\n     * @returns {Vector}\n     */\n    transform(m) {\n        return new Flatten.Vector(m.transform([this.x, this.y]))\n    }\n\n    /**\n     * Returns vector rotated 90 degrees counterclockwise\n     * @returns {Vector}\n     */\n    rotate90CCW() {\n        return new Flatten.Vector(-this.y, this.x);\n    };\n\n    /**\n     * Returns vector rotated 90 degrees clockwise\n     * @returns {Vector}\n     */\n    rotate90CW() {\n        return new Flatten.Vector(this.y, -this.x);\n    };\n\n    /**\n     * Return inverted vector\n     * @returns {Vector}\n     */\n    invert() {\n        return new Flatten.Vector(-this.x, -this.y);\n    }\n\n    /**\n     * Return result of addition of other vector to this vector as a new vector\n     * @param {Vector} v Other vector\n     * @returns {Vector}\n     */\n    add(v) {\n        return new Flatten.Vector(this.x + v.x, this.y + v.y);\n    }\n\n    /**\n     * Return result of subtraction of other vector from current vector as a new vector\n     * @param {Vector} v Another vector\n     * @returns {Vector}\n     */\n    subtract(v) {\n        return new Flatten.Vector(this.x - v.x, this.y - v.y);\n    }\n\n    /**\n     * Return angle between this vector and other vector. <br/>\n     * Angle is measured from 0 to 2*PI in the counterclockwise direction\n     * from current vector to  another.\n     * @param {Vector} v Another vector\n     * @returns {number}\n     */\n    angleTo(v) {\n        let norm1 = this.normalize();\n        let norm2 = v.normalize();\n        let angle = Math.atan2(norm1.cross(norm2), norm1.dot(norm2));\n        if (angle < 0) angle += 2 * Math.PI;\n        return angle;\n    }\n\n    /**\n     * Return vector projection of the current vector on another vector\n     * @param {Vector} v Another vector\n     * @returns {Vector}\n     */\n    projectionOn(v) {\n        let n = v.normalize();\n        let d = this.dot(n);\n        return n.multiply(d);\n    }\n\n    get name() {\n        return \"vector\"\n    }\n};\n\nFlatten.Vector = Vector$1;\n\n/**\n * Function to create vector equivalent to \"new\" constructor\n * @param args\n */\nconst vector$1 = (...args) => new Flatten.Vector(...args);\nFlatten.vector = vector$1;\n\n/**\n * Created by Alex Bol on 3/10/2017.\n */\n\n\n/**\n * Class representing a segment\n * @type {Segment}\n */\nclass Segment extends Shape {\n    /**\n     *\n     * @param {Point} ps - start point\n     * @param {Point} pe - end point\n     */\n    constructor(...args) {\n        super();\n        /**\n         * Start point\n         * @type {Point}\n         */\n        this.ps = new Flatten.Point();\n        /**\n         * End Point\n         * @type {Point}\n         */\n        this.pe = new Flatten.Point();\n\n        if (args.length === 0) {\n            return;\n        }\n\n        if (args.length === 1 && args[0] instanceof Array && args[0].length === 4) {\n            let coords = args[0];\n            this.ps = new Flatten.Point(coords[0], coords[1]);\n            this.pe = new Flatten.Point(coords[2], coords[3]);\n            return;\n        }\n\n        if (args.length === 1 && args[0] instanceof Object && args[0].name === \"segment\") {\n            let {ps, pe} = args[0];\n            this.ps = new Flatten.Point(ps.x, ps.y);\n            this.pe = new Flatten.Point(pe.x, pe.y);\n            return;\n        }\n\n        // second point omitted issue #84\n        if (args.length === 1 && args[0] instanceof Flatten.Point) {\n            this.ps = args[0].clone();\n            return;\n        }\n\n        if (args.length === 2 && args[0] instanceof Flatten.Point && args[1] instanceof Flatten.Point) {\n            this.ps = args[0].clone();\n            this.pe = args[1].clone();\n            return;\n        }\n\n        if (args.length === 4) {\n            this.ps = new Flatten.Point(args[0], args[1]);\n            this.pe = new Flatten.Point(args[2], args[3]);\n            return;\n        }\n\n        throw Errors.ILLEGAL_PARAMETERS;\n    }\n\n    /**\n     * Return new cloned instance of segment\n     * @returns {Segment}\n     */\n    clone() {\n        return new Flatten.Segment(this.start, this.end);\n    }\n\n    /**\n     * Start point\n     * @returns {Point}\n     */\n    get start() {\n        return this.ps;\n    }\n\n    /**\n     * End point\n     * @returns {Point}\n     */\n    get end() {\n        return this.pe;\n    }\n\n\n    /**\n     * Returns array of start and end point\n     * @returns [Point,Point]\n     */\n    get vertices() {\n        return [this.ps.clone(), this.pe.clone()];\n    }\n\n    /**\n     * Length of a segment\n     * @returns {number}\n     */\n    get length() {\n        return this.start.distanceTo(this.end)[0];\n    }\n\n    /**\n     * Slope of the line - angle to axe x in radians from 0 to 2PI\n     * @returns {number}\n     */\n    get slope() {\n        let vec = new Flatten.Vector(this.start, this.end);\n        return vec.slope;\n    }\n\n    /**\n     * Bounding box\n     * @returns {Box}\n     */\n    get box() {\n        return new Flatten.Box(\n            Math.min(this.start.x, this.end.x),\n            Math.min(this.start.y, this.end.y),\n            Math.max(this.start.x, this.end.x),\n            Math.max(this.start.y, this.end.y)\n        )\n    }\n\n    /**\n     * Returns true if equals to query segment, false otherwise\n     * @param {Seg} seg - query segment\n     * @returns {boolean}\n     */\n    equalTo(seg) {\n        return this.ps.equalTo(seg.ps) && this.pe.equalTo(seg.pe);\n    }\n\n    /**\n     * Returns true if segment contains point\n     * @param {Point} pt Query point\n     * @returns {boolean}\n     */\n    contains(pt) {\n        return Flatten.Utils.EQ_0(this.distanceToPoint(pt));\n    }\n\n    /**\n     * Returns array of intersection points between segment and other shape\n     * @param {Shape} shape - Shape of the one of supported types <br/>\n     * @returns {Point[]}\n     */\n    intersect(shape) {\n        if (shape instanceof Flatten.Point) {\n            return this.contains(shape) ? [shape] : [];\n        }\n\n        if (shape instanceof Flatten.Line) {\n            return intersectSegment2Line(this, shape);\n        }\n\n        if (shape instanceof Flatten.Ray) {\n            return intersectRay2Segment(shape, this);\n        }\n\n        if (shape instanceof Flatten.Segment) {\n            return  intersectSegment2Segment(this, shape);\n        }\n\n        if (shape instanceof Flatten.Circle) {\n            return intersectSegment2Circle(this, shape);\n        }\n\n        if (shape instanceof Flatten.Box) {\n            return intersectSegment2Box(this, shape);\n        }\n\n        if (shape instanceof Flatten.Arc) {\n            return intersectSegment2Arc(this, shape);\n        }\n\n        if (shape instanceof Flatten.Polygon) {\n            return  intersectSegment2Polygon(this, shape);\n        }\n    }\n\n    /**\n     * Calculate distance and shortest segment from segment to shape and return as array [distance, shortest segment]\n     * @param {Shape} shape Shape of the one of supported types Point, Line, Circle, Segment, Arc, Polygon or Planar Set\n     * @returns {number} distance from segment to shape\n     * @returns {Segment} shortest segment between segment and shape (started at segment, ended at shape)\n     */\n    distanceTo(shape) {\n        if (shape instanceof Flatten.Point) {\n            let [dist, shortest_segment] = Flatten.Distance.point2segment(shape, this);\n            shortest_segment = shortest_segment.reverse();\n            return [dist, shortest_segment];\n        }\n\n        if (shape instanceof Flatten.Circle) {\n            let [dist, shortest_segment] = Flatten.Distance.segment2circle(this, shape);\n            return [dist, shortest_segment];\n        }\n\n        if (shape instanceof Flatten.Line) {\n            let [dist, shortest_segment] = Flatten.Distance.segment2line(this, shape);\n            return [dist, shortest_segment];\n        }\n\n        if (shape instanceof Flatten.Segment) {\n            let [dist, shortest_segment] = Flatten.Distance.segment2segment(this, shape);\n            return [dist, shortest_segment];\n        }\n\n        if (shape instanceof Flatten.Arc) {\n            let [dist, shortest_segment] = Flatten.Distance.segment2arc(this, shape);\n            return [dist, shortest_segment];\n        }\n\n        if (shape instanceof Flatten.Polygon) {\n            let [dist, shortest_segment] = Flatten.Distance.shape2polygon(this, shape);\n            return [dist, shortest_segment];\n        }\n\n        if (shape instanceof Flatten.PlanarSet) {\n            let [dist, shortest_segment] = Flatten.Distance.shape2planarSet(this, shape);\n            return [dist, shortest_segment];\n        }\n    }\n\n    /**\n     * Returns unit vector in the direction from start to end\n     * @returns {Vector}\n     */\n    tangentInStart() {\n        let vec = new Flatten.Vector(this.start, this.end);\n        return vec.normalize();\n    }\n\n    /**\n     * Return unit vector in the direction from end to start\n     * @returns {Vector}\n     */\n    tangentInEnd() {\n        let vec = new Flatten.Vector(this.end, this.start);\n        return vec.normalize();\n    }\n\n    /**\n     * Returns new segment with swapped start and end points\n     * @returns {Segment}\n     */\n    reverse() {\n        return new Segment(this.end, this.start);\n    }\n\n    /**\n     * When point belongs to segment, return array of two segments split by given point,\n     * if point is inside segment. Returns clone of this segment if query point is incident\n     * to start or end point of the segment. Returns empty array if point does not belong to segment\n     * @param {Point} pt Query point\n     * @returns {Segment[]}\n     */\n    split(pt) {\n        if (this.start.equalTo(pt))\n            return [null, this.clone()];\n\n        if (this.end.equalTo(pt))\n            return [this.clone(), null];\n\n        return [\n            new Flatten.Segment(this.start, pt),\n            new Flatten.Segment(pt, this.end)\n        ]\n    }\n\n    /**\n     * Return middle point of the segment\n     * @returns {Point}\n     */\n    middle() {\n        return new Flatten.Point((this.start.x + this.end.x) / 2, (this.start.y + this.end.y) / 2);\n    }\n\n    /**\n     * Get point at given length\n     * @param {number} length - The length along the segment\n     * @returns {Point}\n     */\n    pointAtLength(length) {\n        if (length > this.length || length < 0) return null;\n        if (length == 0) return this.start;\n        if (length == this.length) return this.end;\n        let factor = length / this.length;\n        return new Flatten.Point(\n            (this.end.x - this.start.x) * factor + this.start.x,\n            (this.end.y - this.start.y) * factor + this.start.y\n        );\n    }\n\n    distanceToPoint(pt) {\n        let [dist, ...rest] = Flatten.Distance.point2segment(pt, this);\n        return dist;\n    };\n\n    definiteIntegral(ymin = 0.0) {\n        let dx = this.end.x - this.start.x;\n        let dy1 = this.start.y - ymin;\n        let dy2 = this.end.y - ymin;\n        return (dx * (dy1 + dy2) / 2);\n    }\n\n    /**\n     * Return new segment transformed using affine transformation matrix\n     * @param {Matrix} matrix - affine transformation matrix\n     * @returns {Segment} - transformed segment\n     */\n    transform(matrix = new Flatten.Matrix()) {\n        return new Segment(this.ps.transform(matrix), this.pe.transform(matrix))\n    }\n\n    /**\n     * Returns true if segment start is equal to segment end up to DP_TOL\n     * @returns {boolean}\n     */\n    isZeroLength() {\n        return this.ps.equalTo(this.pe)\n    }\n\n    /**\n     * Sort given array of points from segment start to end, assuming all points lay on the segment\n     * @param {Point[]} - array of points\n     * @returns {Point[]} new array sorted\n     */\n    sortPoints(pts) {\n        let line = new Flatten.Line(this.start, this.end);\n        return line.sortPoints(pts);\n    }\n\n    get name() {\n        return \"segment\"\n    }\n\n    /**\n     * Return string to draw segment in svg\n     * @param {Object} attrs - an object with attributes for svg path element,\n     * like \"stroke\", \"strokeWidth\" <br/>\n     * Defaults are stroke:\"black\", strokeWidth:\"1\"\n     * @returns {string}\n     */\n    svg(attrs = {}) {\n        return `\\n<line x1=\"${this.start.x}\" y1=\"${this.start.y}\" x2=\"${this.end.x}\" y2=\"${this.end.y}\" ${convertToString(attrs)} />`;\n    }\n}\n\nFlatten.Segment = Segment;\n/**\n * Shortcut method to create new segment\n */\nconst segment = (...args) => new Flatten.Segment(...args);\nFlatten.segment = segment;\n\n/**\n * Created by Alex Bol on 2/20/2017.\n */\n\nlet {vector} = Flatten;\n\n/**\n * Class representing a line\n * @type {Line}\n */\nlet Line$1 = class Line extends Shape {\n    /**\n     * Line may be constructed by point and normal vector or by two points that a line passes through\n     * @param {Point} pt - point that a line passes through\n     * @param {Vector|Point} norm - normal vector to a line or second point a line passes through\n     */\n    constructor(...args) {\n        super();\n        /**\n         * Point a line passes through\n         * @type {Point}\n         */\n        this.pt = new Flatten.Point();\n        /**\n         * Normal vector to a line <br/>\n         * Vector is normalized (length == 1)<br/>\n         * Direction of the vector is chosen to satisfy inequality norm * p >= 0\n         * @type {Vector}\n         */\n        this.norm = new Flatten.Vector(0, 1);\n\n        if (args.length === 0) {\n            return;\n        }\n\n        if (args.length === 1 && args[0] instanceof Object && args[0].name === \"line\") {\n            let {pt, norm} = args[0];\n            this.pt = new Flatten.Point(pt);\n            this.norm = new Flatten.Vector(norm);\n            return;\n        }\n\n        if (args.length === 2) {\n            let a1 = args[0];\n            let a2 = args[1];\n\n            if (a1 instanceof Flatten.Point && a2 instanceof Flatten.Point) {\n                this.pt = a1;\n                this.norm = Line.points2norm(a1, a2);\n                if (this.norm.dot(vector(this.pt.x,this.pt.y)) >= 0) {\n                    this.norm.invert();\n                }\n                return;\n            }\n\n            if (a1 instanceof Flatten.Point && a2 instanceof Flatten.Vector) {\n                if (Flatten.Utils.EQ_0(a2.x) && Flatten.Utils.EQ_0(a2.y)) {\n                    throw Errors.ILLEGAL_PARAMETERS;\n                }\n                this.pt = a1.clone();\n                this.norm = a2.clone();\n                this.norm = this.norm.normalize();\n                if (this.norm.dot(vector(this.pt.x,this.pt.y)) >= 0) {\n                    this.norm.invert();\n                }\n                return;\n            }\n\n            if (a1 instanceof Flatten.Vector && a2 instanceof Flatten.Point) {\n                if (Flatten.Utils.EQ_0(a1.x) && Flatten.Utils.EQ_0(a1.y)) {\n                    throw Errors.ILLEGAL_PARAMETERS;\n                }\n                this.pt = a2.clone();\n                this.norm = a1.clone();\n                this.norm = this.norm.normalize();\n                if (this.norm.dot(vector(this.pt.x,this.pt.y)) >= 0) {\n                    this.norm.invert();\n                }\n                return;\n            }\n        }\n\n        throw Errors.ILLEGAL_PARAMETERS;\n    }\n\n    /**\n     * Return new cloned instance of line\n     * @returns {Line}\n     */\n    clone() {\n        return new Flatten.Line(this.pt, this.norm);\n    }\n\n    /* The following methods need for implementation of Edge interface\n    /**\n     * Line has no start point\n     * @returns {undefined}\n     */\n    get start() {return undefined;}\n\n    /**\n     * Line has no end point\n     */\n    get end() {return undefined;}\n\n    /**\n     * Return positive infinity number as length\n     * @returns {number}\n     */\n    get length() {return Number.POSITIVE_INFINITY;}\n\n    /**\n     * Returns infinite box\n     * @returns {Box}\n     */\n    get box() {\n        return new Flatten.Box(\n            Number.NEGATIVE_INFINITY,\n            Number.NEGATIVE_INFINITY,\n            Number.POSITIVE_INFINITY,\n            Number.POSITIVE_INFINITY\n        )\n    }\n\n    /**\n     * Middle point is undefined\n     * @returns {undefined}\n     */\n    get middle() {return undefined}\n\n    /**\n     * Slope of the line - angle in radians between line and axe x from 0 to 2PI\n     * @returns {number} - slope of the line\n     */\n    get slope() {\n        let vec = new Flatten.Vector(this.norm.y, -this.norm.x);\n        return vec.slope;\n    }\n\n    /**\n     * Get coefficients [A,B,C] of a standard line equation in the form Ax + By = C\n     * @code [A, B, C] = line.standard\n     * @returns {number[]} - array of coefficients\n     */\n    get standard() {\n        let A = this.norm.x;\n        let B = this.norm.y;\n        let C = this.norm.dot(vector(this.pt.x, this.pt.y));\n\n        return [A, B, C];\n    }\n\n    /**\n     * Return true if parallel or incident to other line\n     * @param {Line} other_line - line to check\n     * @returns {boolean}\n     */\n    parallelTo(other_line) {\n        return Flatten.Utils.EQ_0(this.norm.cross(other_line.norm));\n    }\n\n    /**\n     * Returns true if incident to other line\n     * @param {Line} other_line - line to check\n     * @returns {boolean}\n     */\n    incidentTo(other_line) {\n        return this.parallelTo(other_line) && this.pt.on(other_line);\n    }\n\n    /**\n     * Returns true if point belongs to line\n     * @param {Point} pt Query point\n     * @returns {boolean}\n     */\n    contains(pt) {\n        if (this.pt.equalTo(pt)) {\n            return true;\n        }\n        /* Line contains point if vector to point is orthogonal to the line normal vector */\n        let vec = new Flatten.Vector(this.pt, pt);\n        return Flatten.Utils.EQ_0(this.norm.dot(vec));\n    }\n\n    /**\n     * Return coordinate of the point that lies on the line in the transformed\n     * coordinate system where center is the projection of the point(0,0) to\n     * the line and axe y is collinear to the normal vector. <br/>\n     * This method assumes that point lies on the line and does not check it\n     * @param {Point} pt - point on a line\n     * @returns {number}\n     */\n    coord(pt) {\n        return vector(pt.x, pt.y).cross(this.norm);\n    }\n\n    /**\n     * Returns array of intersection points\n     * @param {Shape} shape - shape to intersect with\n     * @returns {Point[]}\n     */\n    intersect(shape) {\n        if (shape instanceof Flatten.Point) {\n            return this.contains(shape) ? [shape] : [];\n        }\n\n        if (shape instanceof Flatten.Line) {\n            return intersectLine2Line(this, shape);\n        }\n\n        if (shape instanceof Flatten.Ray) {\n            return intersectRay2Line(shape, this);\n        }\n\n        if (shape instanceof Flatten.Circle) {\n            return intersectLine2Circle(this, shape);\n        }\n\n        if (shape instanceof Flatten.Box) {\n            return intersectLine2Box(this, shape);\n        }\n\n        if (shape instanceof Flatten.Segment) {\n            return intersectSegment2Line(shape, this);\n        }\n\n        if (shape instanceof Flatten.Arc) {\n            return intersectLine2Arc(this, shape);\n        }\n\n        if (shape instanceof Flatten.Polygon) {\n            return  intersectLine2Polygon(this, shape);\n        }\n\n    }\n\n    /**\n     * Calculate distance and shortest segment from line to shape and returns array [distance, shortest_segment]\n     * @param {Shape} shape Shape of the one of the types Point, Circle, Segment, Arc, Polygon\n     * @returns {[number, Segment]}\n     */\n    distanceTo(shape) {\n        if (shape instanceof Flatten.Point) {\n            let [distance, shortest_segment] = Flatten.Distance.point2line(shape, this);\n            shortest_segment = shortest_segment.reverse();\n            return [distance, shortest_segment];\n        }\n\n        if (shape instanceof Flatten.Circle) {\n            let [distance, shortest_segment] = Flatten.Distance.circle2line(shape, this);\n            shortest_segment = shortest_segment.reverse();\n            return [distance, shortest_segment];\n        }\n\n        if (shape instanceof Flatten.Segment) {\n            let [distance, shortest_segment] = Flatten.Distance.segment2line(shape, this);\n            return [distance, shortest_segment.reverse()];\n        }\n\n        if (shape instanceof Flatten.Arc) {\n            let [distance, shortest_segment] = Flatten.Distance.arc2line(shape, this);\n            return [distance, shortest_segment.reverse()];\n        }\n\n        if (shape instanceof Flatten.Polygon) {\n            let [distance, shortest_segment] = Flatten.Distance.shape2polygon(this, shape);\n            return [distance, shortest_segment];\n        }\n    }\n\n    /**\n     * Split line with a point or array of points and return array of shapes\n     * Assumed (but not checked) that all points lay on the line\n     * @param {Point | Point[]} pt\n     * @returns {MultilineShapes}\n     */\n    split(pt) {\n        if (pt instanceof Flatten.Point) {\n            return [new Flatten.Ray(pt, this.norm), new Flatten.Ray(pt, this.norm)]\n        }\n        else {\n            let multiline = new Flatten.Multiline([this]);\n            let sorted_points = this.sortPoints(pt);\n            multiline.split(sorted_points);\n            return multiline.toShapes();\n        }\n    }\n\n    /**\n     * Return new line rotated by angle\n     * @param {number} angle - angle in radians\n     * @param {Point} center - center of rotation\n     */\n    rotate(angle, center = new Flatten.Point()) {\n        return new Flatten.Line(\n            this.pt.rotate(angle, center),\n            this.norm.rotate(angle)\n        )\n    }\n\n    /**\n     * Return new line transformed by affine transformation matrix\n     * @param {Matrix} m - affine transformation matrix (a,b,c,d,tx,ty)\n     * @returns {Line}\n     */\n    transform(m) {\n        return new Flatten.Line(\n            this.pt.transform(m),\n            this.norm.clone()\n        )\n    }\n\n    /**\n     * Sort given array of points that lay on a line with respect to coordinate on a line\n     * The method assumes that points lay on the line and does not check this\n     * @param {Point[]} pts - array of points\n     * @returns {Point[]} new array sorted\n     */\n    sortPoints(pts) {\n        return pts.slice().sort( (pt1, pt2) => {\n            if (this.coord(pt1) < this.coord(pt2)) {\n                return -1;\n            }\n            if (this.coord(pt1) > this.coord(pt2)) {\n                return 1;\n            }\n            return 0;\n        })\n    }\n\n    get name() {\n        return \"line\"\n    }\n\n    /**\n     * Return string to draw svg segment representing line inside given box\n     * @param {Box} box Box representing drawing area\n     * @param {Object} attrs - an object with attributes of svg circle element\n     */\n    svg(box, attrs = {}) {\n        let ip = intersectLine2Box(this, box);\n        if (ip.length === 0)\n            return \"\";\n        let ps = ip[0];\n        let pe = ip.length === 2 ? ip[1] : ip.find(pt => !pt.equalTo(ps));\n        if (pe === undefined) pe = ps;\n        let segment = new Flatten.Segment(ps, pe);\n        return segment.svg(attrs);\n    }\n\n    static points2norm(pt1, pt2) {\n        if (pt1.equalTo(pt2)) {\n            throw Errors.ILLEGAL_PARAMETERS;\n        }\n        let vec = new Flatten.Vector(pt1, pt2);\n        let unit = vec.normalize();\n        return unit.rotate90CCW();\n    }\n};\n\nFlatten.Line = Line$1;\n/**\n * Function to create line equivalent to \"new\" constructor\n * @param args\n */\nconst line = (...args) => new Flatten.Line(...args);\nFlatten.line = line;\n\n/**\n * Created by Alex Bol on 3/6/2017.\n */\n\n\n/**\n * Class representing a circle\n * @type {Circle}\n */\nlet Circle$1 = class Circle extends Shape {\n    /**\n     * Class private property\n     * @type {string}\n     */\n\n    /**\n     *\n     * @param {Point} pc - circle center point\n     * @param {number} r - circle radius\n     */\n    constructor(...args) {\n        super();\n        /**\n         * Circle center\n         * @type {Point}\n         */\n        this.pc = new Flatten.Point();\n        /**\n         * Circle radius\n         * @type {number}\n         */\n        this.r = 1;\n\n        if (args.length === 1 && args[0] instanceof Object && args[0].name === \"circle\") {\n            let {pc, r} = args[0];\n            this.pc = new Flatten.Point(pc);\n            this.r = r;\n        } else {\n            let [pc, r] = [...args];\n            if (pc && pc instanceof Flatten.Point) this.pc = pc.clone();\n            if (r !== undefined) this.r = r;\n        }\n        // throw Errors.ILLEGAL_PARAMETERS;    unreachable code\n    }\n\n    /**\n     * Return new cloned instance of circle\n     * @returns {Circle}\n     */\n    clone() {\n        return new Flatten.Circle(this.pc.clone(), this.r);\n    }\n\n    /**\n     * Circle center\n     * @returns {Point}\n     */\n    get center() {\n        return this.pc;\n    }\n\n    /**\n     * Circle bounding box\n     * @returns {Box}\n     */\n    get box() {\n        return new Flatten.Box(\n            this.pc.x - this.r,\n            this.pc.y - this.r,\n            this.pc.x + this.r,\n            this.pc.y + this.r\n        );\n    }\n\n    /**\n     * Return true if circle contains shape: no point of shape lies outside of the circle\n     * @param {Shape} shape - test shape\n     * @returns {boolean}\n     */\n    contains(shape) {\n        if (shape instanceof Flatten.Point) {\n            return Flatten.Utils.LE(shape.distanceTo(this.center)[0], this.r);\n        }\n\n        if (shape instanceof Flatten.Segment) {\n            return Flatten.Utils.LE(shape.start.distanceTo(this.center)[0], this.r) &&\n                Flatten.Utils.LE(shape.end.distanceTo(this.center)[0], this.r);\n        }\n\n        if (shape instanceof Flatten.Arc) {\n            return this.intersect(shape).length === 0 &&\n                Flatten.Utils.LE(shape.start.distanceTo(this.center)[0], this.r) &&\n                Flatten.Utils.LE(shape.end.distanceTo(this.center)[0], this.r);\n        }\n\n        if (shape instanceof Flatten.Circle) {\n            return this.intersect(shape).length === 0 &&\n                Flatten.Utils.LE(shape.r, this.r) &&\n                Flatten.Utils.LE(shape.center.distanceTo(this.center)[0], this.r);\n        }\n\n        /* TODO: box, polygon */\n    }\n\n    /**\n     * Transform circle to closed arc\n     * @param {boolean} counterclockwise\n     * @returns {Arc}\n     */\n    toArc(counterclockwise = true) {\n        return new Flatten.Arc(this.center, this.r, Math.PI, -Math.PI, counterclockwise);\n    }\n\n    /**\n     * Method scale is supported only for uniform scaling of the circle with (0,0) center\n     * @param {number} sx\n     * @param {number} sy\n     * @returns {Circle}\n     */\n    scale(sx, sy) {\n        if (sx !== sy)\n            throw Errors.OPERATION_IS_NOT_SUPPORTED\n        if (!(this.pc.x === 0.0 && this.pc.y === 0.0))\n            throw Errors.OPERATION_IS_NOT_SUPPORTED\n        return new Flatten.Circle(this.pc, this.r*sx)\n    }\n\n    /**\n     * Return new circle transformed using affine transformation matrix\n     * @param {Matrix} matrix - affine transformation matrix\n     * @returns {Circle}\n     */\n    transform(matrix = new Flatten.Matrix()) {\n        return new Flatten.Circle(this.pc.transform(matrix), this.r)\n    }\n\n    /**\n     * Returns array of intersection points between circle and other shape\n     * @param {Shape} shape Shape of the one of supported types\n     * @returns {Point[]}\n     */\n    intersect(shape) {\n        if (shape instanceof Flatten.Point) {\n            return this.contains(shape) ? [shape] : [];\n        }\n        if (shape instanceof Flatten.Line) {\n            return intersectLine2Circle(shape, this);\n        }\n        if (shape instanceof Flatten.Ray) {\n            return intersectRay2Circle(shape, this);\n        }\n        if (shape instanceof Flatten.Segment) {\n            return intersectSegment2Circle(shape, this);\n        }\n\n        if (shape instanceof Flatten.Circle) {\n            return intersectCircle2Circle(shape, this);\n        }\n\n        if (shape instanceof Flatten.Box) {\n            return intersectCircle2Box(this, shape);\n        }\n\n        if (shape instanceof Flatten.Arc) {\n            return intersectArc2Circle(shape, this);\n        }\n        if (shape instanceof Flatten.Polygon) {\n            return intersectCircle2Polygon(this, shape);\n        }\n    }\n\n    /**\n     * Calculate distance and shortest segment from circle to shape and return array [distance, shortest segment]\n     * @param {Shape} shape Shape of the one of supported types Point, Line, Circle, Segment, Arc, Polygon or Planar Set\n     * @returns {number} distance from circle to shape\n     * @returns {Segment} shortest segment between circle and shape (started at circle, ended at shape)\n\n     */\n    distanceTo(shape) {\n        if (shape instanceof Flatten.Point) {\n            let [distance, shortest_segment] = Flatten.Distance.point2circle(shape, this);\n            shortest_segment = shortest_segment.reverse();\n            return [distance, shortest_segment];\n        }\n\n        if (shape instanceof Flatten.Circle) {\n            let [distance, shortest_segment] = Flatten.Distance.circle2circle(this, shape);\n            return [distance, shortest_segment];\n        }\n\n        if (shape instanceof Flatten.Line) {\n            let [distance, shortest_segment] = Flatten.Distance.circle2line(this, shape);\n            return [distance, shortest_segment];\n        }\n\n        if (shape instanceof Flatten.Segment) {\n            let [distance, shortest_segment] = Flatten.Distance.segment2circle(shape, this);\n            shortest_segment = shortest_segment.reverse();\n            return [distance, shortest_segment];\n        }\n\n        if (shape instanceof Flatten.Arc) {\n            let [distance, shortest_segment] = Flatten.Distance.arc2circle(shape, this);\n            shortest_segment = shortest_segment.reverse();\n            return [distance, shortest_segment];\n        }\n\n        if (shape instanceof Flatten.Polygon) {\n            let [distance, shortest_segment] = Flatten.Distance.shape2polygon(this, shape);\n            return [distance, shortest_segment];\n        }\n\n        if (shape instanceof Flatten.PlanarSet) {\n            let [dist, shortest_segment] = Flatten.Distance.shape2planarSet(this, shape);\n            return [dist, shortest_segment];\n        }\n    }\n\n    get name() {\n        return \"circle\"\n    }\n\n    /**\n     * Return string to draw circle in svg\n     * @param {Object} attrs - an object with attributes of svg circle element\n     * @returns {string}\n     */\n    svg(attrs = {}) {\n        return `\\n<circle cx=\"${this.pc.x}\" cy=\"${this.pc.y}\" r=\"${this.r}\"\n                ${convertToString({fill: \"none\", ...attrs})} />`;\n    }\n\n};\n\nFlatten.Circle = Circle$1;\n/**\n * Shortcut to create new circle\n * @param args\n */\nconst circle = (...args) => new Flatten.Circle(...args);\nFlatten.circle = circle;\n\n/**\n * Created by Alex Bol on 3/10/2017.\n */\n\n\n/**\n * Class representing a circular arc\n * @type {Arc}\n */\nclass Arc extends Shape {\n    /**\n     *\n     * @param {Point} pc - arc center\n     * @param {number} r - arc radius\n     * @param {number} startAngle - start angle in radians from 0 to 2*PI\n     * @param {number} endAngle - end angle in radians from 0 to 2*PI\n     * @param {boolean} counterClockwise - arc direction, true - clockwise, false - counterclockwise\n     */\n    constructor(...args) {\n        super();\n        /**\n         * Arc center\n         * @type {Point}\n         */\n        this.pc = new Flatten.Point();\n        /**\n         * Arc radius\n         * @type {number}\n         */\n        this.r = 1;\n        /**\n         * Arc start angle in radians\n         * @type {number}\n         */\n        this.startAngle = 0;\n        /**\n         * Arc end angle in radians\n         * @type {number}\n         */\n        this.endAngle = 2 * Math.PI;\n        /**\n         * Arc orientation\n         * @type {boolean}\n         */\n        this.counterClockwise = Flatten.CCW;\n\n        if (args.length === 0)\n            return;\n\n        if (args.length === 1 && args[0] instanceof Object && args[0].name === \"arc\") {\n            let {pc, r, startAngle, endAngle, counterClockwise} = args[0];\n            this.pc = new Flatten.Point(pc.x, pc.y);\n            this.r = r;\n            this.startAngle = startAngle;\n            this.endAngle = endAngle;\n            this.counterClockwise = counterClockwise;\n        } else {\n            let [pc, r, startAngle, endAngle, counterClockwise] = [...args];\n            if (pc && pc instanceof Flatten.Point) this.pc = pc.clone();\n            if (r !== undefined) this.r = r;\n            if (startAngle !== undefined) this.startAngle = startAngle;\n            if (endAngle !== undefined) this.endAngle = endAngle;\n            if (counterClockwise !== undefined) this.counterClockwise = counterClockwise;\n        }\n\n        // throw Flatten.Errors.ILLEGAL_PARAMETERS; unreachable code\n    }\n\n    /**\n     * Return new cloned instance of arc\n     * @returns {Arc}\n     */\n    clone() {\n        return new Flatten.Arc(this.pc.clone(), this.r, this.startAngle, this.endAngle, this.counterClockwise);\n    }\n\n    /**\n     * Get sweep angle in radians. Sweep angle is non-negative number from 0 to 2*PI\n     * @returns {number}\n     */\n    get sweep() {\n        if (Flatten.Utils.EQ(this.startAngle, this.endAngle))\n            return 0.0;\n        if (Flatten.Utils.EQ(Math.abs(this.startAngle - this.endAngle), Flatten.PIx2)) {\n            return Flatten.PIx2;\n        }\n        let sweep;\n        if (this.counterClockwise) {\n            sweep = Flatten.Utils.GT(this.endAngle, this.startAngle) ?\n                this.endAngle - this.startAngle : this.endAngle - this.startAngle + Flatten.PIx2;\n        } else {\n            sweep = Flatten.Utils.GT(this.startAngle, this.endAngle) ?\n                this.startAngle - this.endAngle : this.startAngle - this.endAngle + Flatten.PIx2;\n        }\n\n        if (Flatten.Utils.GT(sweep, Flatten.PIx2)) {\n            sweep -= Flatten.PIx2;\n        }\n        if (Flatten.Utils.LT(sweep, 0)) {\n            sweep += Flatten.PIx2;\n        }\n        return sweep;\n    }\n\n    /**\n     * Get start point of arc\n     * @returns {Point}\n     */\n    get start() {\n        let p0 = new Flatten.Point(this.pc.x + this.r, this.pc.y);\n        return p0.rotate(this.startAngle, this.pc);\n    }\n\n    /**\n     * Get end point of arc\n     * @returns {Point}\n     */\n    get end() {\n        let p0 = new Flatten.Point(this.pc.x + this.r, this.pc.y);\n        return p0.rotate(this.endAngle, this.pc);\n    }\n\n    /**\n     * Get center of arc\n     * @returns {Point}\n     */\n    get center() {\n        return this.pc.clone();\n    }\n\n    get vertices() {\n        return [this.start.clone(), this.end.clone()];\n    }\n\n    /**\n     * Get arc length\n     * @returns {number}\n     */\n    get length() {\n        return Math.abs(this.sweep * this.r);\n    }\n\n    /**\n     * Get bounding box of the arc\n     * @returns {Box}\n     */\n    get box() {\n        let func_arcs = this.breakToFunctional();\n        let box = func_arcs.reduce((acc, arc) => acc.merge(arc.start.box), new Flatten.Box());\n        box = box.merge(this.end.box);\n        return box;\n    }\n\n    /**\n     * Returns true if arc contains point, false otherwise\n     * @param {Point} pt - point to test\n     * @returns {boolean}\n     */\n    contains(pt) {\n        // first check if  point on circle (pc,r)\n        if (!Flatten.Utils.EQ(this.pc.distanceTo(pt)[0], this.r))\n            return false;\n\n        // point on circle\n\n        if (pt.equalTo(this.start))\n            return true;\n\n        let angle = new Flatten.Vector(this.pc, pt).slope;\n        let test_arc = new Flatten.Arc(this.pc, this.r, this.startAngle, angle, this.counterClockwise);\n        return Flatten.Utils.LE(test_arc.length, this.length);\n    }\n\n    /**\n     * When given point belongs to arc, return array of two arcs split by this point. If points is incident\n     * to start or end point of the arc, return clone of the arc. If point does not belong to the arcs, return\n     * empty array.\n     * @param {Point} pt Query point\n     * @returns {Arc[]}\n     */\n    split(pt) {\n        if (this.start.equalTo(pt))\n            return [null, this.clone()];\n\n        if (this.end.equalTo(pt))\n            return [this.clone(), null];\n\n        let angle = new Flatten.Vector(this.pc, pt).slope;\n\n        return [\n            new Flatten.Arc(this.pc, this.r, this.startAngle, angle, this.counterClockwise),\n            new Flatten.Arc(this.pc, this.r, angle, this.endAngle, this.counterClockwise)\n        ]\n    }\n\n    /**\n     * Return middle point of the arc\n     * @returns {Point}\n     */\n    middle() {\n        let endAngle = this.counterClockwise ? this.startAngle + this.sweep / 2 : this.startAngle - this.sweep / 2;\n        let arc = new Flatten.Arc(this.pc, this.r, this.startAngle, endAngle, this.counterClockwise);\n        return arc.end;\n    }\n\n    /**\n     * Get point at given length\n     * @param {number} length - The length along the arc\n     * @returns {Point}\n     */\n    pointAtLength(length) {\n        if (length > this.length || length < 0) return null;\n        if (length === 0) return this.start;\n        if (length === this.length) return this.end;\n        let factor = length / this.length;\n        let endAngle = this.counterClockwise ? this.startAngle + this.sweep * factor : this.startAngle - this.sweep * factor;\n        let arc = new Flatten.Arc(this.pc, this.r, this.startAngle, endAngle, this.counterClockwise);\n        return arc.end;\n    }\n\n    /**\n     * Returns chord height (\"sagitta\") of the arc\n     * @returns {number}\n     */\n    chordHeight() {\n        return (1.0 - Math.cos(Math.abs(this.sweep / 2.0))) * this.r;\n    }\n\n    /**\n     * Returns array of intersection points between arc and other shape\n     * @param {Shape} shape Shape of the one of supported types <br/>\n     * @returns {Point[]}\n     */\n    intersect(shape) {\n        if (shape instanceof Flatten.Point) {\n            return this.contains(shape) ? [shape] : [];\n        }\n        if (shape instanceof Flatten.Line) {\n            return intersectLine2Arc(shape, this);\n        }\n        if (shape instanceof Flatten.Ray) {\n            return intersectRay2Arc(shape, this);\n        }\n        if (shape instanceof Flatten.Circle) {\n            return intersectArc2Circle(this, shape);\n        }\n        if (shape instanceof Flatten.Segment) {\n            return intersectSegment2Arc(shape, this);\n        }\n        if (shape instanceof Flatten.Box) {\n            return intersectArc2Box(this, shape);\n        }\n        if (shape instanceof Flatten.Arc) {\n            return intersectArc2Arc(this, shape);\n        }\n        if (shape instanceof Flatten.Polygon) {\n            return intersectArc2Polygon(this, shape);\n        }\n    }\n\n    /**\n     * Calculate distance and shortest segment from arc to shape and return array [distance, shortest segment]\n     * @param {Shape} shape Shape of the one of supported types Point, Line, Circle, Segment, Arc, Polygon or Planar Set\n     * @returns {number} distance from arc to shape\n     * @returns {Segment} shortest segment between arc and shape (started at arc, ended at shape)\n\n     */\n    distanceTo(shape) {\n        if (shape instanceof Flatten.Point) {\n            let [dist, shortest_segment] = Flatten.Distance.point2arc(shape, this);\n            shortest_segment = shortest_segment.reverse();\n            return [dist, shortest_segment];\n        }\n\n        if (shape instanceof Flatten.Circle) {\n            let [dist, shortest_segment] = Flatten.Distance.arc2circle(this, shape);\n            return [dist, shortest_segment];\n        }\n\n        if (shape instanceof Flatten.Line) {\n            let [dist, shortest_segment] = Flatten.Distance.arc2line(this, shape);\n            return [dist, shortest_segment];\n        }\n\n        if (shape instanceof Flatten.Segment) {\n            let [dist, shortest_segment] = Flatten.Distance.segment2arc(shape, this);\n            shortest_segment = shortest_segment.reverse();\n            return [dist, shortest_segment];\n        }\n\n        if (shape instanceof Flatten.Arc) {\n            let [dist, shortest_segment] = Flatten.Distance.arc2arc(this, shape);\n            return [dist, shortest_segment];\n        }\n\n        if (shape instanceof Flatten.Polygon) {\n            let [dist, shortest_segment] = Flatten.Distance.shape2polygon(this, shape);\n            return [dist, shortest_segment];\n        }\n\n        if (shape instanceof Flatten.PlanarSet) {\n            let [dist, shortest_segment] = Flatten.Distance.shape2planarSet(this, shape);\n            return [dist, shortest_segment];\n        }\n    }\n\n    /**\n     * Breaks arc in extreme point 0, pi/2, pi, 3*pi/2 and returns array of sub-arcs\n     * @returns {Arc[]}\n     */\n    breakToFunctional() {\n        let func_arcs_array = [];\n        let angles = [0, Math.PI / 2, 2 * Math.PI / 2, 3 * Math.PI / 2];\n        let pts = [\n            this.pc.translate(this.r, 0),\n            this.pc.translate(0, this.r),\n            this.pc.translate(-this.r, 0),\n            this.pc.translate(0, -this.r)\n        ];\n\n        // If arc contains extreme point,\n        // create test arc started at start point and ended at this extreme point\n        let test_arcs = [];\n        for (let i = 0; i < 4; i++) {\n            if (pts[i].on(this)) {\n                test_arcs.push(new Flatten.Arc(this.pc, this.r, this.startAngle, angles[i], this.counterClockwise));\n            }\n        }\n\n        if (test_arcs.length === 0) {                  // arc does contain any extreme point\n            func_arcs_array.push(this.clone());\n        } else {                                        // arc passes extreme point\n            // sort these arcs by length\n            test_arcs.sort((arc1, arc2) => arc1.length - arc2.length);\n\n            for (let i = 0; i < test_arcs.length; i++) {\n                let prev_arc = func_arcs_array.length > 0 ? func_arcs_array[func_arcs_array.length - 1] : undefined;\n                let new_arc;\n                if (prev_arc) {\n                    new_arc = new Flatten.Arc(this.pc, this.r, prev_arc.endAngle, test_arcs[i].endAngle, this.counterClockwise);\n                } else {\n                    new_arc = new Flatten.Arc(this.pc, this.r, this.startAngle, test_arcs[i].endAngle, this.counterClockwise);\n                }\n                if (!Flatten.Utils.EQ_0(new_arc.length)) {\n                    func_arcs_array.push(new_arc.clone());\n                }\n            }\n\n            // add last sub arc\n            let prev_arc = func_arcs_array.length > 0 ? func_arcs_array[func_arcs_array.length - 1] : undefined;\n            let new_arc;\n            if (prev_arc) {\n                new_arc = new Flatten.Arc(this.pc, this.r, prev_arc.endAngle, this.endAngle, this.counterClockwise);\n            } else {\n                new_arc = new Flatten.Arc(this.pc, this.r, this.startAngle, this.endAngle, this.counterClockwise);\n            }\n            // It could be 2*PI when occasionally start = 0 and end = 2*PI but this is not valid for breakToFunctional\n            if (!Flatten.Utils.EQ_0(new_arc.length) && !Flatten.Utils.EQ(new_arc.sweep, 2*Math.PI)) {\n                func_arcs_array.push(new_arc.clone());\n            }\n        }\n        return func_arcs_array;\n    }\n\n    /**\n     * Return tangent unit vector in the start point in the direction from start to end\n     * @returns {Vector}\n     */\n    tangentInStart() {\n        let vec = new Flatten.Vector(this.pc, this.start);\n        let angle = this.counterClockwise ? Math.PI / 2. : -Math.PI / 2.;\n        return vec.rotate(angle).normalize();\n    }\n\n    /**\n     * Return tangent unit vector in the end point in the direction from end to start\n     * @returns {Vector}\n     */\n    tangentInEnd() {\n        let vec = new Flatten.Vector(this.pc, this.end);\n        let angle = this.counterClockwise ? -Math.PI / 2. : Math.PI / 2.;\n        return vec.rotate(angle).normalize();\n    }\n\n    /**\n     * Returns new arc with swapped start and end angles and reversed direction\n     * @returns {Arc}\n     */\n    reverse() {\n        return new Flatten.Arc(this.pc, this.r, this.endAngle, this.startAngle, !this.counterClockwise);\n    }\n\n    /**\n     * Return new arc transformed using affine transformation matrix <br/>\n     * @param {Matrix} matrix - affine transformation matrix\n     * @returns {Arc}\n     */\n    transform(matrix = new Flatten.Matrix()) {\n        let newStart = this.start.transform(matrix);\n        let newEnd = this.end.transform(matrix);\n        let newCenter = this.pc.transform(matrix);\n        let newDirection = this.counterClockwise;\n        if (matrix.a * matrix.d < 0) {\n          newDirection = !newDirection;\n        }\n        return Flatten.Arc.arcSE(newCenter, newStart, newEnd, newDirection);\n    }\n\n    static arcSE(center, start, end, counterClockwise) {\n        let {vector} = Flatten;\n        let startAngle = vector(center, start).slope;\n        let endAngle = vector(center, end).slope;\n        if (Flatten.Utils.EQ(startAngle, endAngle)) {\n            endAngle += 2 * Math.PI;\n            counterClockwise = true;\n        }\n        let r = vector(center, start).length;\n\n        return new Flatten.Arc(center, r, startAngle, endAngle, counterClockwise);\n    }\n\n    definiteIntegral(ymin = 0) {\n        let f_arcs = this.breakToFunctional();\n        let area = f_arcs.reduce((acc, arc) => acc + arc.circularSegmentDefiniteIntegral(ymin), 0.0);\n        return area;\n    }\n\n    circularSegmentDefiniteIntegral(ymin) {\n        let line = new Flatten.Line(this.start, this.end);\n        let onLeftSide = this.pc.leftTo(line);\n        let segment = new Flatten.Segment(this.start, this.end);\n        let areaTrapez = segment.definiteIntegral(ymin);\n        let areaCircularSegment = this.circularSegmentArea();\n        let area = onLeftSide ? areaTrapez - areaCircularSegment : areaTrapez + areaCircularSegment;\n        return area;\n    }\n\n    circularSegmentArea() {\n        return (0.5 * this.r * this.r * (this.sweep - Math.sin(this.sweep)))\n    }\n\n    /**\n     * Sort given array of points from arc start to end, assuming all points lay on the arc\n     * @param {Point[]} pts array of points\n     * @returns {Point[]} new array sorted\n     */\n    sortPoints(pts) {\n        let {vector} = Flatten;\n        return pts.slice().sort( (pt1, pt2) => {\n            let slope1 = vector(this.pc, pt1).slope;\n            let slope2 = vector(this.pc, pt2).slope;\n            if (slope1 < slope2) {\n                return -1;\n            }\n            if (slope1 > slope2) {\n                return 1;\n            }\n            return 0;\n        })\n    }\n\n    get name() {\n        return \"arc\"\n    }\n\n    /**\n     * Return string to draw arc in svg\n     * @param {Object} attrs - an object with attributes of svg path element\n     * @returns {string}\n     */\n    svg(attrs = {}) {\n        let largeArcFlag = this.sweep <= Math.PI ? \"0\" : \"1\";\n        let sweepFlag = this.counterClockwise ? \"1\" : \"0\";\n\n        if (Flatten.Utils.EQ(this.sweep, 2 * Math.PI)) {\n            let circle = new Flatten.Circle(this.pc, this.r);\n            return circle.svg(attrs);\n        } else {\n            return `\\n<path d=\"M${this.start.x},${this.start.y}\n                             A${this.r},${this.r} 0 ${largeArcFlag},${sweepFlag} ${this.end.x},${this.end.y}\"\n                    ${convertToString({fill: \"none\", ...attrs})} />`\n        }\n    }\n\n}\n\nFlatten.Arc = Arc;\n/**\n * Function to create arc equivalent to \"new\" constructor\n * @param args\n */\nconst arc = (...args) => new Flatten.Arc(...args);\nFlatten.arc = arc;\n\n/**\n * Created by Alex Bol on 3/7/2017.\n */\n\n/**\n * Class Box represents bounding box of the shape.\n * It may also represent axis-aligned rectangle\n * @type {Box}\n */\nclass Box extends Shape {\n    /**\n     *\n     * @param {number} xmin - minimal x coordinate\n     * @param {number} ymin - minimal y coordinate\n     * @param {number} xmax - maximal x coordinate\n     * @param {number} ymax - maximal y coordinate\n     */\n    constructor(xmin = undefined, ymin = undefined, xmax = undefined, ymax = undefined) {\n        super();\n        /**\n         * Minimal x coordinate\n         * @type {number}\n         */\n        this.xmin = xmin;\n        /**\n         * Minimal y coordinate\n         * @type {number}\n         */\n        this.ymin = ymin;\n        /**\n         * Maximal x coordinate\n         * @type {number}\n         */\n        this.xmax = xmax;\n        /**\n         * Maximal y coordinate\n         * @type {number}\n         */\n        this.ymax = ymax;\n    }\n\n    /**\n     * Return new cloned instance of box\n     * @returns {Box}\n     */\n    clone() {\n        return new Box(this.xmin, this.ymin, this.xmax, this.ymax);\n    }\n\n    /**\n     * Property low need for interval tree interface\n     * @returns {Point}\n     */\n    get low() {\n        return new Flatten.Point(this.xmin, this.ymin);\n    }\n\n    /**\n     * Property high need for interval tree interface\n     * @returns {Point}\n     */\n    get high() {\n        return new Flatten.Point(this.xmax, this.ymax);\n    }\n\n    /**\n     * Property max returns the box itself !\n     * @returns {Box}\n     */\n    get max() {\n        return this.clone();\n    }\n    \n    /**\n     * Return center of the box\n     * @returns {Point}\n     */\n    get center() {\n        return new Flatten.Point((this.xmin + this.xmax) / 2, (this.ymin + this.ymax) / 2);\n    }\n\n    /**\n     * Return the width of the box\n     * @returns {number}\n     */\n    get width() {\n        return Math.abs(this.xmax - this.xmin);\n    }\n\n    /**\n     * Return the height of the box\n     * @returns {number}\n     */\n    get height() {\n        return Math.abs(this.ymax - this.ymin);\n    }\n    \n    /**\n     * Return property box like all other shapes\n     * @returns {Box}\n     */\n    get box() {\n        return this.clone();\n    }\n\n    /**\n     * Returns true if not intersected with other box\n     * @param {Box} other_box - other box to test\n     * @returns {boolean}\n     */\n    not_intersect(other_box) {\n        return (\n            this.xmax < other_box.xmin ||\n            this.xmin > other_box.xmax ||\n            this.ymax < other_box.ymin ||\n            this.ymin > other_box.ymax\n        );\n    }\n\n    /**\n     * Returns true if intersected with other box\n     * @param {Box} other_box - Query box\n     * @returns {boolean}\n     */\n    intersect(other_box) {\n        return !this.not_intersect(other_box);\n    }\n\n    /**\n     * Returns new box merged with other box\n     * @param {Box} other_box - Other box to merge with\n     * @returns {Box}\n     */\n    merge(other_box) {\n        return new Box(\n            this.xmin === undefined ? other_box.xmin : Math.min(this.xmin, other_box.xmin),\n            this.ymin === undefined ? other_box.ymin : Math.min(this.ymin, other_box.ymin),\n            this.xmax === undefined ? other_box.xmax : Math.max(this.xmax, other_box.xmax),\n            this.ymax === undefined ? other_box.ymax : Math.max(this.ymax, other_box.ymax)\n        );\n    }\n\n    /**\n     * Defines predicate \"less than\" between two boxes. Need for interval index\n     * @param {Box} other_box - other box\n     * @returns {boolean} - true if this box less than other box, false otherwise\n     */\n    less_than(other_box) {\n        if (this.low.lessThan(other_box.low))\n            return true;\n        if (this.low.equalTo(other_box.low) && this.high.lessThan(other_box.high))\n            return true;\n        return false;\n    }\n\n    /**\n     * Returns true if this box is equal to other box, false otherwise\n     * @param {Box} other_box - query box\n     * @returns {boolean}\n     */\n    equal_to(other_box) {\n        return (this.low.equalTo(other_box.low) && this.high.equalTo(other_box.high));\n    }\n\n    output() {\n        return this.clone();\n    }\n\n    static comparable_max(box1, box2) {\n        // return pt1.lessThan(pt2) ? pt2.clone() : pt1.clone();\n        return box1.merge(box2);\n    }\n\n    static comparable_less_than(pt1, pt2) {\n        return pt1.lessThan(pt2);\n    }\n\n    /**\n     * Set new values to the box object\n     * @param {number} xmin - mininal x coordinate\n     * @param {number} ymin - minimal y coordinate\n     * @param {number} xmax - maximal x coordinate\n     * @param {number} ymax - maximal y coordinate\n     */\n    set(xmin, ymin, xmax, ymax) {\n        this.xmin = xmin;\n        this.ymin = ymin;\n        this.xmax = xmax;\n        this.ymax = ymax;\n    }\n\n    /**\n     * Transform box into array of points from low left corner in counterclockwise\n     * @returns {Point[]}\n     */\n    toPoints() {\n        return [\n            new Flatten.Point(this.xmin, this.ymin),\n            new Flatten.Point(this.xmax, this.ymin),\n            new Flatten.Point(this.xmax, this.ymax),\n            new Flatten.Point(this.xmin, this.ymax)\n        ];\n    }\n\n    /**\n     * Transform box into array of segments from low left corner in counterclockwise\n     * @returns {Segment[]}\n     */\n    toSegments() {\n        let pts = this.toPoints();\n        return [\n            new Flatten.Segment(pts[0], pts[1]),\n            new Flatten.Segment(pts[1], pts[2]),\n            new Flatten.Segment(pts[2], pts[3]),\n            new Flatten.Segment(pts[3], pts[0])\n        ];\n    }\n\n    /**\n     * Box rotation is not supported\n     * Attempt to rotate box throws error\n     * @param {number} angle - angle in radians\n     * @param {Point} [center=(0,0)] center\n     */\n    rotate(angle, center = new Flatten.Point()) {\n            throw Errors.OPERATION_IS_NOT_SUPPORTED\n    }\n\n    /**\n     * Return new box transformed using affine transformation matrix\n     * New box is a bounding box of transformed corner points\n     * @param {Matrix} m - affine transformation matrix\n     * @returns {Box}\n     */\n    transform(m = new Flatten.Matrix()) {\n        const transformed_points = this.toPoints().map(pt => pt.transform(m));\n        return transformed_points.reduce(\n            (new_box, pt) => new_box.merge(pt.box), new Box())\n    }\n\n    /**\n     * Return true if box contains shape: no point of shape lies outside the box\n     * @param {AnyShape} shape - test shape\n     * @returns {boolean}\n     */\n    contains(shape) {\n        if (shape instanceof Flatten.Point) {\n            return (shape.x >= this.xmin) && (shape.x <= this.xmax) && (shape.y >= this.ymin) && (shape.y <= this.ymax);\n        }\n\n        if (shape instanceof Flatten.Segment) {\n            return shape.vertices.every(vertex => this.contains(vertex))\n        }\n\n        if (shape instanceof Flatten.Box) {\n            return shape.toSegments().every(segment => this.contains(segment))\n        }\n\n        if (shape instanceof Flatten.Circle) {\n            return this.contains(shape.box)\n        }\n\n        if (shape instanceof Flatten.Arc) {\n            return shape.vertices.every(vertex => this.contains(vertex)) &&\n                shape.toSegments().every(segment => intersectSegment2Arc(segment, shape).length === 0)\n        }\n\n        if (shape instanceof Flatten.Line || shape instanceof Flatten.Ray) {\n            return false\n        }\n\n        if (shape instanceof Flatten.Multiline) {\n            return shape.toShapes().every(shape => this.contains(shape))\n        }\n\n        if (shape instanceof Flatten.Polygon) {\n            return this.contains(shape.box)\n        }\n    }\n\n    get name() {\n        return \"box\"\n    }\n\n    /**\n     * Return string to draw box in svg\n     * @param {Object} attrs - an object with attributes of svg rectangle element\n     * @returns {string}\n     */\n    svg(attrs = {}) {\n        const width = this.xmax - this.xmin;\n        const height = this.ymax - this.ymin;\n        return `\\n<rect x=\"${this.xmin}\" y=\"${this.ymin}\" width=${width} height=${height}\n                ${convertToString({fill: \"none\", ...attrs})} />`;\n    };\n}\n\nFlatten.Box = Box;\n/**\n * Shortcut to create new box\n * @param args\n * @returns {Box}\n */\nconst box = (...args) => new Flatten.Box(...args);\nFlatten.box = box;\n\n/**\n * Created by Alex Bol on 3/17/2017.\n */\n\n\n/**\n * Class representing an edge of polygon. Edge shape may be Segment or Arc.\n * Each edge contains references to the next and previous edges in the face of the polygon.\n *\n * @type {Edge}\n */\nclass Edge {\n    /**\n     * Construct new instance of edge\n     * @param {Shape} shape Shape of type Segment or Arc\n     */\n    constructor(shape) {\n        /**\n         * Shape of the edge: Segment or Arc\n         * @type {Segment|Arc}\n         */\n        this.shape = shape;\n        /**\n         * Pointer to the next edge in the face\n         * @type {Edge}\n         */\n        this.next = undefined;\n        /**\n         * Pointer to the previous edge in the face\n         * @type {Edge}\n         */\n        this.prev = undefined;\n        /**\n         * Pointer to the face containing this edge\n         * @type {Face}\n         */\n        this.face = undefined;\n        /**\n         * \"Arc distance\" from the face start\n         * @type {number}\n         */\n        this.arc_length = 0;\n        /**\n         * Start inclusion flag (inside/outside/boundary)\n         * @type {*}\n         */\n        this.bvStart = undefined;\n        /**\n         * End inclusion flag (inside/outside/boundary)\n         * @type {*}\n         */\n        this.bvEnd = undefined;\n        /**\n         * Edge inclusion flag (Flatten.INSIDE, Flatten.OUTSIDE, Flatten.BOUNDARY)\n         * @type {*}\n         */\n        this.bv = undefined;\n        /**\n         * Overlap flag for boundary edge (Flatten.OVERLAP_SAME/Flatten.OVERLAP_OPPOSITE)\n         * @type {*}\n         */\n        this.overlap = undefined;\n    }\n\n    /**\n     * Get edge start point\n     */\n    get start() {\n        return this.shape.start;\n    }\n\n    /**\n     * Get edge end point\n     */\n    get end() {\n        return this.shape.end;\n    }\n\n    /**\n     * Get edge length\n     */\n    get length() {\n        return this.shape.length;\n    }\n\n    /**\n     * Get bounding box of the edge\n     * @returns {Box}\n     */\n    get box() {\n        return this.shape.box;\n    }\n\n    get isSegment() {\n        return this.shape instanceof Flatten.Segment;\n    }\n\n    get isArc() {\n        return this.shape instanceof Flatten.Arc;\n    }\n\n    get isLine() {\n        return this.shape instanceof Flatten.Line;\n    }\n\n    get isRay() {\n        return this.shape instanceof Flatten.Ray\n    }\n\n    /**\n     * Get middle point of the edge\n     * @returns {Point}\n     */\n    middle() {\n        return this.shape.middle();\n    }\n\n    /**\n     * Get point at given length\n     * @param {number} length - The length along the edge\n     * @returns {Point}\n     */\n    pointAtLength(length) {\n        return this.shape.pointAtLength(length);\n    }\n\n    /**\n     * Returns true if point belongs to the edge, false otherwise\n     * @param {Point} pt - test point\n     */\n    contains(pt) {\n        return this.shape.contains(pt);\n    }\n\n    /**\n     * Set inclusion flag of the edge with respect to another polygon\n     * Inclusion flag is one of Flatten.INSIDE, Flatten.OUTSIDE, Flatten.BOUNDARY\n     * @param polygon\n     */\n    setInclusion(polygon) {\n        if (this.bv !== undefined) return this.bv;\n\n        if (this.shape instanceof Flatten.Line || this.shape instanceof Flatten.Ray) {\n            this.bv = Flatten.OUTSIDE;\n            return this.bv;\n        }\n\n        if (this.bvStart === undefined) {\n            this.bvStart = ray_shoot(polygon, this.start);\n        }\n        if (this.bvEnd === undefined) {\n            this.bvEnd = ray_shoot(polygon, this.end);\n        }\n        /* At least one end outside - the whole edge outside */\n        if (this.bvStart === Flatten.OUTSIDE || this.bvEnd == Flatten.OUTSIDE) {\n            this.bv = Flatten.OUTSIDE;\n        }\n        /* At least one end inside - the whole edge inside */\n        else if (this.bvStart === Flatten.INSIDE || this.bvEnd == Flatten.INSIDE) {\n            this.bv = Flatten.INSIDE;\n        }\n        /* Both are boundary - check the middle point */\n        else {\n            let bvMiddle = ray_shoot(polygon, this.middle());\n            // let boundary = this.middle().distanceTo(polygon)[0] < 10*Flatten.DP_TOL;\n            // let bvMiddle = boundary ? Flatten.BOUNDARY : ray_shoot(polygon, this.middle());\n            this.bv = bvMiddle;\n        }\n        return this.bv;\n    }\n\n    /**\n     * Set overlapping between two coincident boundary edges\n     * Overlapping flag is one of Flatten.OVERLAP_SAME or Flatten.OVERLAP_OPPOSITE\n     * @param edge\n     */\n    setOverlap(edge) {\n        let flag = undefined;\n        let shape1 = this.shape;\n        let shape2 = edge.shape;\n\n        if (shape1 instanceof Flatten.Segment && shape2 instanceof Flatten.Segment) {\n            if (shape1.start.equalTo(shape2.start) && shape1.end.equalTo(shape2.end)) {\n                flag = Flatten.OVERLAP_SAME;\n            } else if (shape1.start.equalTo(shape2.end) && shape1.end.equalTo(shape2.start)) {\n                flag = Flatten.OVERLAP_OPPOSITE;\n            }\n        } else if (shape1 instanceof Flatten.Arc && shape2 instanceof Flatten.Arc) {\n            if (shape1.start.equalTo(shape2.start) && shape1.end.equalTo(shape2.end) && /*shape1.counterClockwise === shape2.counterClockwise &&*/\n                shape1.middle().equalTo(shape2.middle())) {\n                flag = Flatten.OVERLAP_SAME;\n            } else if (shape1.start.equalTo(shape2.end) && shape1.end.equalTo(shape2.start) && /*shape1.counterClockwise !== shape2.counterClockwise &&*/\n                shape1.middle().equalTo(shape2.middle())) {\n                flag = Flatten.OVERLAP_OPPOSITE;\n            }\n        } else if (shape1 instanceof Flatten.Segment && shape2 instanceof Flatten.Arc ||\n            shape1 instanceof Flatten.Arc && shape2 instanceof Flatten.Segment) {\n            if (shape1.start.equalTo(shape2.start) && shape1.end.equalTo(shape2.end) && shape1.middle().equalTo(shape2.middle())) {\n                flag = Flatten.OVERLAP_SAME;\n            } else if (shape1.start.equalTo(shape2.end) && shape1.end.equalTo(shape2.start) && shape1.middle().equalTo(shape2.middle())) {\n                flag = Flatten.OVERLAP_OPPOSITE;\n            }\n        }\n\n        /* Do not update overlap flag if already set on previous chain */\n        if (this.overlap === undefined) this.overlap = flag;\n        if (edge.overlap === undefined) edge.overlap = flag;\n    }\n\n    svg() {\n        if (this.shape instanceof Flatten.Segment) {\n            return ` L${this.shape.end.x},${this.shape.end.y}`;\n        } else if (this.shape instanceof Flatten.Arc) {\n            let arc = this.shape;\n            let largeArcFlag;\n            let sweepFlag = arc.counterClockwise ? \"1\" : \"0\";\n\n            // Draw full circe arc as special case: split it into two half-circles\n            if (Flatten.Utils.EQ(arc.sweep, 2 * Math.PI)) {\n                let sign = arc.counterClockwise ? 1 : -1;\n                let halfArc1 = new Flatten.Arc(arc.pc, arc.r, arc.startAngle, arc.startAngle + sign * Math.PI, arc.counterClockwise);\n                let halfArc2 = new Flatten.Arc(arc.pc, arc.r, arc.startAngle + sign * Math.PI, arc.endAngle, arc.counterClockwise);\n\n                largeArcFlag = \"0\";\n\n                return ` A${halfArc1.r},${halfArc1.r} 0 ${largeArcFlag},${sweepFlag} ${halfArc1.end.x},${halfArc1.end.y}\n                    A${halfArc2.r},${halfArc2.r} 0 ${largeArcFlag},${sweepFlag} ${halfArc2.end.x},${halfArc2.end.y}`\n            } else {\n                largeArcFlag = arc.sweep <= Math.PI ? \"0\" : \"1\";\n\n                return ` A${arc.r},${arc.r} 0 ${largeArcFlag},${sweepFlag} ${arc.end.x},${arc.end.y}`;\n            }\n        }\n    }\n\n    toJSON() {\n        return this.shape.toJSON();\n    }\n}\nFlatten.Edge = Edge;\n\n/**\n * Class implements circular bidirectional linked list <br/>\n * LinkedListElement - object of any type that has properties next and prev.\n */\nclass CircularLinkedList extends LinkedList {\n    constructor(first, last) {\n        super(first, last);\n        this.setCircularLinks();\n    }\n\n    setCircularLinks() {\n        if (this.isEmpty()) return;\n        this.last.next = this.first;\n        this.first.prev = this.last;\n    }\n\n    [Symbol.iterator]() {\n        let element = undefined;\n        return {\n            next: () => {\n                let value = element ? element : this.first;\n                let done = this.first ? (element ? element === this.first : false) : true;\n                element = value ? value.next : undefined;\n                return {value: value, done: done};\n            }\n        };\n    };\n\n    /**\n     * Append new element to the end of the list\n     * @param {LinkedListElement} element - new element to be appended\n     * @returns {CircularLinkedList}\n     */\n    append(element) {\n        super.append(element);\n        this.setCircularLinks();\n        return this;\n    }\n\n    /**\n     * Insert new element to the list after elementBefore\n     * @param {LinkedListElement} newElement - new element to be inserted\n     * @param {LinkedListElement} elementBefore - element in the list to insert after it\n     * @returns {CircularLinkedList}\n     */\n    insert(newElement, elementBefore) {\n        super.insert(newElement, elementBefore);\n        this.setCircularLinks();\n        return this;\n    }\n\n    /**\n     * Remove element from the list\n     * @param {LinkedListElement} element - element to be removed from the list\n     * @returns {CircularLinkedList}\n     */\n    remove(element) {\n        super.remove(element);\n        // this.setCircularLinks();\n        return this;\n    }\n}\n\n/**\n * Created by Alex Bol on 3/17/2017.\n */\n\n\n/**\n * Class representing a face (closed loop) in a [polygon]{@link Flatten.Polygon} object.\n * Face is a circular bidirectional linked list of [edges]{@link Flatten.Edge}.\n * Face object cannot be instantiated with a constructor.\n * Instead, use [polygon.addFace()]{@link Flatten.Polygon#addFace} method.\n * <br/>\n * Note, that face only set entry point to the linked list of edges but does not contain edges by itself.\n * Container of edges is a property of the polygon object. <br/>\n *\n * @example\n * // Face implements \"next\" iterator which enables to iterate edges in for loop:\n * for (let edge of face) {\n *      console.log(edge.shape.length)     // do something\n * }\n *\n * // Instead, it is possible to iterate edges as linked list, starting from face.first:\n * let edge = face.first;\n * do {\n *   console.log(edge.shape.length);   // do something\n *   edge = edge.next;\n * } while (edge != face.first)\n */\nclass Face extends CircularLinkedList {\n    constructor(polygon, ...args) {\n        super();            // construct empty list of edges\n        /**\n         * Reference to the first edge in face\n         */\n        // this.first;\n        /**\n         * Reference to the last edge in face\n         */\n        // this.last;\n\n        this._box = undefined;  // new Box();\n        this._orientation = undefined;\n\n        if (args.length === 0) {\n            return;\n        }\n\n        /* If passed an array it supposed to be:\n         1) array of shapes that performs close loop or\n         2) array of points that performs set of vertices\n         */\n        if (args.length === 1) {\n            if (args[0] instanceof Array) {\n                // let argsArray = args[0];\n                let shapes = args[0];  // argsArray[0];\n                if (shapes.length === 0)\n                    return;\n\n                /* array of Flatten.Points */\n                if (shapes.every((shape) => {return shape instanceof Flatten.Point})) {\n                    let segments = Face.points2segments(shapes);\n                    this.shapes2face(polygon.edges, segments);\n                }\n                /* array of points as pairs of numbers */\n                else if (shapes.every((shape) => {return shape instanceof Array && shape.length === 2})) {\n                    let points = shapes.map((shape) => new Flatten.Point(shape[0],shape[1]));\n                    let segments = Face.points2segments(points);\n                    this.shapes2face(polygon.edges, segments);\n                }\n                /* array of segments ot arcs */\n                else if (shapes.every((shape) => {\n                    return (shape instanceof Flatten.Segment || shape instanceof Flatten.Arc)\n                })) {\n                    this.shapes2face(polygon.edges, shapes);\n                }\n                // this is from JSON.parse object\n                else if (shapes.every((shape) => {\n                    return (shape.name === \"segment\" || shape.name === \"arc\")\n                })) {\n                    let flattenShapes = [];\n                    for (let shape of shapes) {\n                        let flattenShape;\n                        if (shape.name === \"segment\") {\n                            flattenShape = new Flatten.Segment(shape);\n                        } else {\n                            flattenShape = new Flatten.Arc(shape);\n                        }\n                        flattenShapes.push(flattenShape);\n                    }\n                    this.shapes2face(polygon.edges, flattenShapes);\n                }\n            }\n            /* Create new face and copy edges into polygon.edges set */\n            else if (args[0] instanceof Face) {\n                let face = args[0];\n                this.first = face.first;\n                this.last = face.last;\n                for (let edge of face) {\n                    polygon.edges.add(edge);\n                }\n            }\n            /* Instantiate face from a circle in CCW orientation */\n            else if (args[0] instanceof Flatten.Circle) {\n                this.shapes2face(polygon.edges, [args[0].toArc(CCW)]);\n            }\n            /* Instantiate face from a box in CCW orientation */\n            else if (args[0] instanceof Flatten.Box) {\n                let box = args[0];\n                this.shapes2face(polygon.edges, [\n                    new Flatten.Segment(new Flatten.Point(box.xmin, box.ymin), new Flatten.Point(box.xmax, box.ymin)),\n                    new Flatten.Segment(new Flatten.Point(box.xmax, box.ymin), new Flatten.Point(box.xmax, box.ymax)),\n                    new Flatten.Segment(new Flatten.Point(box.xmax, box.ymax), new Flatten.Point(box.xmin, box.ymax)),\n                    new Flatten.Segment(new Flatten.Point(box.xmin, box.ymax), new Flatten.Point(box.xmin, box.ymin))\n                ]);\n            }\n        }\n        /* If passed two edges, consider them as start and end of the face loop */\n        /* THIS METHOD WILL BE USED BY BOOLEAN OPERATIONS */\n        /* Assume that edges already copied to polygon.edges set in the clip algorithm !!! */\n        if (args.length === 2 && args[0] instanceof Flatten.Edge && args[1] instanceof Flatten.Edge) {\n            this.first = args[0];                          // first edge in face or undefined\n            this.last = args[1];                           // last edge in face or undefined\n            this.last.next = this.first;\n            this.first.prev = this.last;\n\n            // set arc length\n            this.setArcLength();\n\n            // this.box = this.getBox();\n            // this.orientation = this.getOrientation();      // face direction cw or ccw\n        }\n    }\n\n    /**\n     * Return array of edges from first to last\n     * @returns {Array}\n     */\n    get edges() {\n        return this.toArray();\n    }\n\n    /**\n     * Return array of shapes which comprise face\n     * @returns {Array}\n     */\n    get shapes() {\n        return this.edges.map(edge => edge.shape.clone());\n    }\n\n    /**\n     * Return bounding box of the face\n     * @returns {Box}\n     */\n    get box() {\n        if (this._box === undefined) {\n            let box = new Flatten.Box();\n            for (let edge of this) {\n                box = box.merge(edge.box);\n            }\n            this._box = box;\n        }\n        return this._box;\n    }\n\n    /**\n     * Get all edges length\n     * @returns {number}\n     */\n    get perimeter() {\n        return this.last.arc_length + this.last.length\n    }\n\n    /**\n     * Get point on face boundary at given length\n     * @param {number} length - The length along the face boundary\n     * @returns {Point}\n     */\n    pointAtLength(length) {\n        if (length > this.perimeter || length < 0) return null;\n        let point = null;\n        for (let edge of this) {\n            if (length >= edge.arc_length &&\n                (edge === this.last || length < edge.next.arc_length)) {\n                point = edge.pointAtLength(length - edge.arc_length);\n                break;\n            }\n        }\n        return point;\n    }\n\n    static points2segments(points) {\n        let segments = [];\n        for (let i = 0; i < points.length; i++) {\n            // skip zero length segment\n            if (points[i].equalTo(points[(i + 1) % points.length]))\n                continue;\n            segments.push(new Flatten.Segment(points[i], points[(i + 1) % points.length]));\n        }\n        return segments;\n    }\n\n    shapes2face(edges, shapes) {\n        for (let shape of shapes) {\n            let edge = new Flatten.Edge(shape);\n            this.append(edge);\n            // this.box = this.box.merge(shape.box);\n            edges.add(edge);\n        }\n        // this.orientation = this.getOrientation();              // face direction cw or ccw\n    }\n\n    /**\n     * Append edge after the last edge of the face (and before the first edge). <br/>\n     * @param {Edge} edge - Edge to be appended to the linked list\n     * @returns {Face}\n     */\n    append(edge) {\n        super.append(edge);\n        // set arc length\n        this.setOneEdgeArcLength(edge);\n        edge.face = this;\n        // edges.add(edge);      // Add new edges into edges container\n        return this;\n    }\n\n    /**\n     * Insert edge newEdge into the linked list after the edge edgeBefore <br/>\n     * @param {Edge} newEdge - Edge to be inserted into linked list\n     * @param {Edge} edgeBefore - Edge to insert newEdge after it\n     * @returns {Face}\n     */\n    insert(newEdge, edgeBefore) {\n        super.insert(newEdge, edgeBefore);\n        // set arc length\n        this.setOneEdgeArcLength(newEdge);\n        newEdge.face = this;\n        return this;\n    }\n\n    /**\n     * Remove the given edge from the linked list of the face <br/>\n     * @param {Edge} edge - Edge to be removed\n     * @returns {Face}\n     */\n    remove(edge) {\n        super.remove(edge);\n        // Recalculate arc length\n        this.setArcLength();\n        return this;\n    }\n\n    /**\n     * Merge current edge with the next edge. Given edge will be extended,\n     * next edge after it will be removed. The distortion of the polygon\n     * is on the responsibility of the user of this method\n     * @param {Edge} edge - edge to be extended\n     * @returns {Face}\n     */\n    merge_with_next_edge(edge) {\n        edge.shape.end.x = edge.next.shape.end.x;\n        edge.shape.end.y = edge.next.shape.end.y;\n        this.remove(edge.next);\n        return this;\n    }\n\n    /**\n     * Reverse orientation of the face: first edge become last and vice a verse,\n     * all edges starts and ends swapped, direction of arcs inverted. If face was oriented\n     * clockwise, it becomes counterclockwise and vice versa\n     */\n    reverse() {\n        // collect edges in revert order with reverted shapes\n        let edges = [];\n        let edge_tmp = this.last;\n        do {\n            // reverse shape\n            edge_tmp.shape = edge_tmp.shape.reverse();\n            edges.push(edge_tmp);\n            edge_tmp = edge_tmp.prev;\n        } while (edge_tmp !== this.last);\n\n        // restore linked list\n        this.first = undefined;\n        this.last = undefined;\n        for (let edge of edges) {\n            if (this.first === undefined) {\n                edge.prev = edge;\n                edge.next = edge;\n                this.first = edge;\n                this.last = edge;\n            } else {\n                // append to end\n                edge.prev = this.last;\n                this.last.next = edge;\n\n                // update edge to be last\n                this.last = edge;\n\n                // restore circular links\n                this.last.next = this.first;\n                this.first.prev = this.last;\n\n            }\n            // set arc length\n            this.setOneEdgeArcLength(edge);\n        }\n\n        // Recalculate orientation, if set\n        if (this._orientation !== undefined) {\n            this._orientation = undefined;\n            this._orientation = this.orientation();\n        }\n    }\n\n\n    /**\n     * Set arc_length property for each of the edges in the face.\n     * Arc_length of the edge it the arc length from the first edge of the face\n     */\n    setArcLength() {\n        for (let edge of this) {\n            this.setOneEdgeArcLength(edge);\n            edge.face = this;\n        }\n    }\n\n    setOneEdgeArcLength(edge) {\n        if (edge === this.first) {\n            edge.arc_length = 0.0;\n        } else {\n            edge.arc_length = edge.prev.arc_length + edge.prev.length;\n        }\n    }\n\n    /**\n     * Returns the absolute value of the area of the face\n     * @returns {number}\n     */\n    area() {\n        return Math.abs(this.signedArea());\n    }\n\n    /**\n     * Returns signed area of the simple face.\n     * Face is simple if it has no self intersections that change its orientation.\n     * Then the area will be positive if the orientation of the face is clockwise,\n     * and negative if orientation is counterclockwise.\n     * It may be zero if polygon is degenerated.\n     * @returns {number}\n     */\n    signedArea() {\n        let sArea = 0;\n        let ymin = this.box.ymin;\n        for (let edge of this) {\n            sArea += edge.shape.definiteIntegral(ymin);\n        }\n        return sArea;\n    }\n\n    /**\n     * Return face orientation: one of Flatten.ORIENTATION.CCW, Flatten.ORIENTATION.CW, Flatten.ORIENTATION.NOT_ORIENTABLE <br/>\n     * According to Green theorem the area of a closed curve may be calculated as double integral,\n     * and the sign of the integral will be defined by the direction of the curve.\n     * When the integral (\"signed area\") will be negative, direction is counterclockwise,\n     * when positive - clockwise and when it is zero, polygon is not orientable.\n     * See {@link https://mathinsight.org/greens_theorem_find_area}\n     * @returns {number}\n     */\n    orientation() {\n        if (this._orientation === undefined) {\n            let area = this.signedArea();\n            if (Flatten.Utils.EQ_0(area)) {\n                this._orientation = ORIENTATION.NOT_ORIENTABLE;\n            } else if (Flatten.Utils.LT(area, 0)) {\n                this._orientation = ORIENTATION.CCW;\n            } else {\n                this._orientation = ORIENTATION.CW;\n            }\n        }\n        return this._orientation;\n    }\n\n    /**\n     * Returns true if face of the polygon is simple (no self-intersection points found)\n     * NOTE: this method is incomplete because it does not exclude touching points.\n     * Self intersection test should check if polygon change orientation in the test point.\n     * @param {PlanarSet} edges - reference to polygon edges to provide search index\n     * @returns {boolean}\n     */\n    isSimple(edges) {\n        let ip = Face.getSelfIntersections(this, edges, true);\n        return ip.length === 0;\n    }\n\n    static getSelfIntersections(face, edges, exitOnFirst = false) {\n        let int_points = [];\n\n        // calculate intersections\n        for (let edge1 of face) {\n\n            // request edges of polygon in the box of edge1\n            let resp = edges.search(edge1.box);\n\n            // for each edge2 in response\n            for (let edge2 of resp) {\n\n                // Skip itself\n                if (edge1 === edge2)\n                    continue;\n\n                // Skip is edge2 belongs to another face\n                if (edge2.face !== face)\n                    continue;\n\n                // Skip next and previous edge if both are segment (if one of them arc - calc intersection)\n                if (edge1.shape instanceof Flatten.Segment && edge2.shape instanceof Flatten.Segment &&\n                    (edge1.next === edge2 || edge1.prev === edge2))\n                    continue;\n\n                // calculate intersections between edge1 and edge2\n                let ip = edge1.shape.intersect(edge2.shape);\n\n                // for each intersection point\n                for (let pt of ip) {\n\n                    // skip start-end connections\n                    if (pt.equalTo(edge1.start) && pt.equalTo(edge2.end) && edge2 === edge1.prev)\n                        continue;\n                    if (pt.equalTo(edge1.end) && pt.equalTo(edge2.start) && edge2 === edge1.next)\n                        continue;\n\n                    int_points.push(pt);\n\n                    if (exitOnFirst)\n                        break;\n                }\n\n                if (int_points.length > 0 && exitOnFirst)\n                    break;\n            }\n\n            if (int_points.length > 0 && exitOnFirst)\n                break;\n\n        }\n        return int_points;\n    }\n\n    /**\n     * Returns edge which contains given point\n     * @param {Point} pt - test point\n     * @returns {Edge}\n     */\n    findEdgeByPoint(pt) {\n        let edgeFound;\n        for (let edge of this) {\n            if (pt.equalTo(edge.shape.start)) continue\n            if (pt.equalTo(edge.shape.end) || edge.shape.contains(pt)) {\n                edgeFound = edge;\n                break;\n            }\n        }\n        return edgeFound;\n    }\n\n    /**\n     * Returns new polygon created from one face\n     * @returns {Polygon}\n     */\n    toPolygon() {\n        return new Flatten.Polygon(this.shapes);\n    }\n\n    toJSON() {\n        return this.edges.map(edge => edge.toJSON());\n    }\n\n    /**\n     * Returns string to be assigned to \"d\" attribute inside defined \"path\"\n     * @returns {string}\n     */\n    svg() {\n        let svgStr = `\\nM${this.first.start.x},${this.first.start.y}`;\n        for (let edge of this) {\n            svgStr += edge.svg();\n        }\n        svgStr += ` z`;\n        return svgStr;\n    }\n\n}\n\nFlatten.Face = Face;\n\n/**\n * Class representing a ray (a half-infinite line).\n * @type {Ray}\n */\nclass Ray extends Shape {\n    /**\n     * Ray may be constructed by setting an <b>origin</b> point and a <b>normal</b> vector, so that any point <b>x</b>\n     * on a ray fit an equation: <br />\n     *  (<b>x</b> - <b>origin</b>) * <b>vector</b> = 0 <br />\n     * Ray defined by constructor is a right semi-infinite line with respect to the normal vector <br/>\n     * If normal vector is omitted ray is considered horizontal (normal vector is (0,1)). <br/>\n     * Don't be confused: direction of the normal vector is orthogonal to the ray <br/>\n     * @param {Point} pt - start point\n     * @param {Vector} norm - normal vector\n     */\n    constructor(...args) {\n        super();\n        this.pt = new Flatten.Point();\n        this.norm = new Flatten.Vector(0,1);\n\n        if (args.length === 0) {\n            return;\n        }\n\n        if (args.length >= 1 && args[0] instanceof Flatten.Point) {\n            this.pt = args[0].clone();\n        }\n\n        if (args.length === 1) {\n            return;\n        }\n\n        if (args.length === 2 && args[1] instanceof Flatten.Vector) {\n            this.norm = args[1].clone();\n            return;\n        }\n\n        throw Errors.ILLEGAL_PARAMETERS;\n    }\n\n    /**\n     * Return new cloned instance of ray\n     * @returns {Ray}\n     */\n    clone() {\n        return new Ray(this.pt, this.norm);\n    }\n\n    /**\n     * Slope of the ray - angle in radians between ray and axe x from 0 to 2PI\n     * @returns {number} - slope of the line\n     */\n    get slope() {\n        let vec = new Flatten.Vector(this.norm.y, -this.norm.x);\n        return vec.slope;\n    }\n\n    /**\n     * Returns half-infinite bounding box of the ray\n     * @returns {Box} - bounding box\n     */\n    get box() {\n        let slope = this.slope;\n        return new Flatten.Box(\n            slope > Math.PI/2 && slope < 3*Math.PI/2 ? Number.NEGATIVE_INFINITY : this.pt.x,\n            slope >= 0 && slope <= Math.PI ? this.pt.y : Number.NEGATIVE_INFINITY,\n            slope >= Math.PI/2 && slope <= 3*Math.PI/2 ? this.pt.x : Number.POSITIVE_INFINITY,\n            slope >= Math.PI && slope <= 2*Math.PI || slope === 0 ? this.pt.y : Number.POSITIVE_INFINITY\n        )\n    }\n\n    /**\n     * Return ray start point\n     * @returns {Point} - ray start point\n     */\n    get start() {\n        return this.pt;\n    }\n\n    /**\n     * Ray has no end point?\n     * @returns {undefined}\n     */\n    get end() {return undefined;}\n\n    /**\n     * Return positive infinity number as length\n     * @returns {number}\n     */\n    get length() {return Number.POSITIVE_INFINITY;}\n\n    /**\n     * Returns true if point belongs to ray\n     * @param {Point} pt Query point\n     * @returns {boolean}\n     */\n    contains(pt) {\n        if (this.pt.equalTo(pt)) {\n            return true;\n        }\n        /* Ray contains point if vector to point is orthogonal to the ray normal vector\n            and cross product from vector to point is positive */\n        let vec = new Flatten.Vector(this.pt, pt);\n        return Flatten.Utils.EQ_0(this.norm.dot(vec)) && Flatten.Utils.GE(vec.cross(this.norm),0);\n    }\n\n    /**\n     * Return coordinate of the point that lies on the ray in the transformed\n     * coordinate system where center is the projection of the point(0,0) to\n     * the line containing this ray and axe y is collinear to the normal vector. <br/>\n     * This method assumes that point lies on the ray\n     * @param {Point} pt - point on a ray\n     * @returns {number}\n     */\n    coord(pt) {\n        return vector$1(pt.x, pt.y).cross(this.norm);\n    }\n\n    /**\n     * Split ray with point and return array of segment and new ray\n     * @param {Point} pt\n     * @returns [Segment,Ray]\n     */\n    split(pt) {\n        if (!this.contains(pt))\n            return [];\n\n        if (this.pt.equalTo(pt)) {\n            return [this]\n        }\n\n        return [\n            new Flatten.Segment(this.pt, pt),\n            new Flatten.Ray(pt, this.norm)\n        ]\n    }\n\n    /**\n     * Returns array of intersection points between ray and another shape\n     * @param {Shape} shape - Shape to intersect with ray\n     * @returns {Point[]} array of intersection points\n     */\n    intersect(shape) {\n        if (shape instanceof Flatten.Point) {\n            return this.contains(shape) ? [shape] : [];\n        }\n\n        if (shape instanceof Flatten.Segment) {\n            return intersectRay2Segment(this, shape);\n        }\n\n        if (shape instanceof Flatten.Arc) {\n            return intersectRay2Arc(this, shape);\n        }\n\n        if (shape instanceof Flatten.Line) {\n            return intersectRay2Line(this, shape);\n        }\n\n        if (shape instanceof Flatten.Ray) {\n            return intersectRay2Ray(this, shape)\n        }\n\n        if (shape instanceof Flatten.Circle) {\n            return intersectRay2Circle(this, shape);\n        }\n\n        if (shape instanceof Flatten.Box) {\n            return intersectRay2Box(this, shape);\n        }\n\n        if (shape instanceof Flatten.Polygon) {\n            return  intersectRay2Polygon(this, shape);\n        }\n    }\n\n    /**\n     * Return new line rotated by angle\n     * @param {number} angle - angle in radians\n     * @param {Point} center - center of rotation\n     */\n    rotate(angle, center = new Flatten.Point()) {\n        return new Flatten.Ray(\n            this.pt.rotate(angle, center),\n            this.norm.rotate(angle)\n        )\n    }\n\n    /**\n     * Return new ray transformed by affine transformation matrix\n     * @param {Matrix} m - affine transformation matrix (a,b,c,d,tx,ty)\n     * @returns {Ray}\n     */\n    transform(m) {\n        return new Flatten.Ray(\n            this.pt.transform(m),\n            this.norm.clone()\n        )\n    }\n\n    get name() {\n        return \"ray\"\n    }\n\n    /**\n     * Return string to draw svg segment representing ray inside given box\n     * @param {Box} box Box representing drawing area\n     * @param {Object} attrs - an object with attributes of svg segment element\n     */\n    svg(box, attrs = {}) {\n        let line = new Flatten.Line(this.pt, this.norm);\n        let ip = intersectLine2Box(line, box);\n        ip = ip.filter( pt => this.contains(pt) );\n        if (ip.length === 0 || ip.length === 2)\n            return \"\";\n        let segment = new Flatten.Segment(this.pt, ip[0]);\n        return segment.svg(attrs);\n    }\n\n}\n\nFlatten.Ray = Ray;\n\nconst ray = (...args) => new Flatten.Ray(...args);\nFlatten.ray = ray;\n\n/**\n * Created by Alex Bol on 3/15/2017.\n */\n\n\n/**\n * Class representing a polygon.<br/>\n * Polygon in FlattenJS is a multipolygon comprised from a set of [faces]{@link Flatten.Face}. <br/>\n * Face, in turn, is a closed loop of [edges]{@link Flatten.Edge}, where edge may be segment or circular arc<br/>\n * @type {Polygon}\n */\nclass Polygon {\n    /**\n     * Constructor creates new instance of polygon. With no arguments new polygon is empty.<br/>\n     * Constructor accepts as argument array that define loop of shapes\n     * or array of arrays in case of multi polygon <br/>\n     * Loop may be defined in different ways: <br/>\n     * - array of shapes of type Segment or Arc <br/>\n     * - array of points (Flatten.Point) <br/>\n     * - array of numeric pairs which represent points <br/>\n     * - box or circle object <br/>\n     * Alternatively, it is possible to use polygon.addFace method\n     * @param {args} - array of shapes or array of arrays\n     */\n    constructor() {\n        /**\n         * Container of faces (closed loops), may be empty\n         * @type {PlanarSet}\n         */\n        this.faces = new Flatten.PlanarSet();\n        /**\n         * Container of edges\n         * @type {PlanarSet}\n         */\n        this.edges = new Flatten.PlanarSet();\n\n        /* It may be array of something that may represent one loop (face) or\n         array of arrays that represent multiple loops\n         */\n        let args = [...arguments];\n        if (args.length === 1 &&\n            ((args[0] instanceof Array && args[0].length > 0) ||\n                args[0] instanceof Flatten.Circle || args[0] instanceof Flatten.Box)) {\n            let argsArray = args[0];\n            if (args[0] instanceof Array && args[0].every((loop) => {\n                return loop instanceof Array\n            })) {\n                if (argsArray.every(el => {\n                    return el instanceof Array && el.length === 2 && typeof (el[0]) === \"number\" && typeof (el[1]) === \"number\"\n                })) {\n                    this.faces.add(new Flatten.Face(this, argsArray));    // one-loop polygon as array of pairs of numbers\n                } else {\n                    for (let loop of argsArray) {   // multi-loop polygon\n                        /* Check extra level of nesting for GeoJSON-style multi polygons */\n                        if (loop instanceof Array && loop[0] instanceof Array &&\n                            loop[0].every(el => {\n                                return el instanceof Array && el.length === 2 && typeof (el[0]) === \"number\" && typeof (el[1]) === \"number\"\n                            })) {\n                            for (let loop1 of loop) {\n                                this.faces.add(new Flatten.Face(this, loop1));\n                            }\n                        } else {\n                            this.faces.add(new Flatten.Face(this, loop));\n                        }\n                    }\n                }\n            } else {\n                this.faces.add(new Flatten.Face(this, argsArray));    // one-loop polygon\n            }\n        }\n    }\n\n    /**\n     * (Getter) Returns bounding box of the polygon\n     * @returns {Box}\n     */\n    get box() {\n        return [...this.faces].reduce((acc, face) => acc.merge(face.box), new Flatten.Box());\n    }\n\n    /**\n     * (Getter) Returns array of vertices\n     * @returns {Array}\n     */\n    get vertices() {\n        return [...this.edges].map(edge => edge.start);\n    }\n\n    /**\n     * Create new cloned instance of the polygon\n     * @returns {Polygon}\n     */\n    clone() {\n        let polygon = new Polygon();\n        for (let face of this.faces) {\n            polygon.addFace(face.shapes);\n        }\n        return polygon;\n    }\n\n    /**\n     * Return true is polygon has no edges\n     * @returns {boolean}\n     */\n    isEmpty() {\n        return this.edges.size === 0;\n    }\n\n    /**\n     * Return true if polygon is valid for boolean operations\n     * Polygon is valid if <br/>\n     * 1. All faces are simple polygons (there are no self-intersected polygons) <br/>\n     * 2. All faces are orientable and there is no island inside island or hole inside hole - TODO <br/>\n     * 3. There is no intersections between faces (excluding touching) - TODO <br/>\n     * @returns {boolean}\n     */\n    isValid() {\n        let valid = true;\n        // 1. Polygon is invalid if at least one face is not simple\n        for (let face of this.faces) {\n            if (!face.isSimple(this.edges)) {\n                valid = false;\n                break;\n            }\n        }\n        // 2. TODO: check if no island inside island and no hole inside hole\n        // 3. TODO: check the there is no intersection between faces\n        return valid;\n    }\n\n    /**\n     * Returns area of the polygon. Area of an island will be added, area of a hole will be subtracted\n     * @returns {number}\n     */\n    area() {\n        let signedArea = [...this.faces].reduce((acc, face) => acc + face.signedArea(), 0);\n        return Math.abs(signedArea);\n    }\n\n    /**\n     * Add new face to polygon. Returns added face\n     * @param {Point[]|Segment[]|Arc[]|Circle|Box} args -  new face may be create with one of the following ways: <br/>\n     * 1) array of points that describe closed path (edges are segments) <br/>\n     * 2) array of shapes (segments and arcs) which describe closed path <br/>\n     * 3) circle - will be added as counterclockwise arc <br/>\n     * 4) box - will be added as counterclockwise rectangle <br/>\n     * You can chain method face.reverse() is you need to change direction of the creates face\n     * @returns {Face}\n     */\n    addFace(...args) {\n        let face = new Flatten.Face(this, ...args);\n        this.faces.add(face);\n        return face;\n    }\n\n    /**\n     * Delete existing face from polygon\n     * @param {Face} face Face to be deleted\n     * @returns {boolean}\n     */\n    deleteFace(face) {\n        for (let edge of face) {\n            this.edges.delete(edge);\n        }\n        return this.faces.delete(face);\n    }\n\n    /**\n     * Clear all faces and create new faces from edges\n     */\n    recreateFaces() {\n        // Remove all faces\n        this.faces.clear();\n        for (let edge of this.edges) {\n            edge.face = null;\n        }\n\n        // Restore faces\n        let first;\n        let unassignedEdgeFound = true;\n        while (unassignedEdgeFound) {\n            unassignedEdgeFound = false;\n            for (let edge of this.edges) {\n                if (edge.face === null) {\n                    first = edge;\n                    unassignedEdgeFound = true;\n                    break;\n                }\n            }\n\n            if (unassignedEdgeFound) {\n                let last = first;\n                do {\n                    last = last.next;\n                } while (last.next !== first)\n\n                this.addFace(first, last);\n            }\n        }\n    }\n\n    /**\n     * Delete chain of edges from the face.\n     * @param {Face} face Face to remove chain\n     * @param {Edge} edgeFrom Start of the chain of edges to be removed\n     * @param {Edge} edgeTo End of the chain of edges to be removed\n     */\n    removeChain(face, edgeFrom, edgeTo) {\n        // Special case: all edges removed\n        if (edgeTo.next === edgeFrom) {\n            this.deleteFace(face);\n            return;\n        }\n        for (let edge = edgeFrom; edge !== edgeTo.next; edge = edge.next) {\n            face.remove(edge);\n            this.edges.delete(edge);      // delete from PlanarSet of edges and update index\n            if (face.isEmpty()) {\n                this.deleteFace(face);    // delete from PlanarSet of faces and update index\n                break;\n            }\n        }\n    }\n\n    /**\n     * Add point as a new vertex and split edge. Point supposed to belong to an edge.\n     * When edge is split, new edge created from the start of the edge to the new vertex\n     * and inserted before current edge.\n     * Current edge is trimmed and updated.\n     * Method returns new edge added. If no edge added, it returns edge before vertex\n     * @param {Point} pt Point to be added as a new vertex\n     * @param {Edge} edge Edge to be split with new vertex and then trimmed from start\n     * @returns {Edge}\n     */\n    addVertex(pt, edge) {\n        let shapes = edge.shape.split(pt);\n        // if (shapes.length < 2) return;\n\n        if (shapes[0] === null)   // point incident to edge start vertex, return previous edge\n            return edge.prev;\n\n        if (shapes[1] === null)   // point incident to edge end vertex, return edge itself\n            return edge;\n\n        let newEdge = new Flatten.Edge(shapes[0]);\n        let edgeBefore = edge.prev;\n\n        /* Insert first split edge into linked list after edgeBefore */\n        edge.face.insert(newEdge, edgeBefore);\n\n        // Remove old edge from edges container and 2d index\n        this.edges.delete(edge);\n\n        // Insert new edge to the edges container and 2d index\n        this.edges.add(newEdge);\n\n        // Update edge shape with second split edge keeping links\n        edge.shape = shapes[1];\n\n        // Add updated edge to the edges container and 2d index\n        this.edges.add(edge);\n\n        return newEdge;\n    }\n\n    /**\n     * Merge given edge with next edge and remove vertex between them\n     * @param {Edge} edge\n     */\n    removeEndVertex(edge) {\n        const edge_next = edge.next;\n        if (edge_next === edge) return\n        edge.face.merge_with_next_edge(edge);\n        this.edges.delete(edge_next);\n    }\n\n    /**\n     * Cut polygon with multiline and return a new polygon\n     * @param {Multiline} multiline\n     * @returns {Polygon}\n     */\n    cut(multiline) {\n        let newPoly = this.clone();\n\n        // smart intersections\n        let intersections = {\n            int_points1: [],\n            int_points2: [],\n            int_points1_sorted: [],\n            int_points2_sorted: []\n        };\n\n        // intersect each edge of multiline with each edge of the polygon\n        // and create smart intersections\n        for (let edge1 of multiline.edges) {\n            for (let edge2 of newPoly.edges) {\n                let ip = intersectEdge2Edge(edge1, edge2);\n                // for each intersection point\n                for (let pt of ip) {\n                    addToIntPoints(edge1, pt, intersections.int_points1);\n                    addToIntPoints(edge2, pt, intersections.int_points2);\n                }\n            }\n        }\n\n        // No intersections - return a copy of the original polygon\n        if (intersections.int_points1.length === 0)\n            return newPoly;\n\n        // sort smart intersections\n        intersections.int_points1_sorted = getSortedArray(intersections.int_points1);\n        intersections.int_points2_sorted = getSortedArray(intersections.int_points2);\n\n        // split by intersection points\n        splitByIntersections(multiline, intersections.int_points1_sorted);\n        splitByIntersections(newPoly, intersections.int_points2_sorted);\n\n        // filter duplicated intersection points\n        filterDuplicatedIntersections(intersections);\n\n        // sort intersection points again after filtering\n        intersections.int_points1_sorted = getSortedArray(intersections.int_points1);\n        intersections.int_points2_sorted = getSortedArray(intersections.int_points2);\n\n        // initialize inclusion flags for edges of multiline incident to intersections\n        initializeInclusionFlags(intersections.int_points1);\n\n        // calculate inclusion flag for edges of multiline incident to intersections\n        calculateInclusionFlags(intersections.int_points1, newPoly);\n\n        // filter intersections between two edges that got same inclusion flag\n        for (let int_point1 of intersections.int_points1_sorted) {\n            if (int_point1.edge_before && int_point1.edge_after &&\n                int_point1.edge_before.bv === int_point1.edge_after.bv) {\n                intersections.int_points2[int_point1.id] = -1;   // to be filtered out\n                int_point1.id = -1;                              // to be filtered out\n            }\n        }\n        intersections.int_points1 = intersections.int_points1.filter( int_point => int_point.id >= 0);\n        intersections.int_points2 = intersections.int_points2.filter( int_point => int_point.id >= 0);\n\n        // No intersections left after filtering - return a copy of the original polygon\n        if (intersections.int_points1.length === 0)\n            return newPoly;\n\n        // sort intersection points 3d time after filtering\n        intersections.int_points1_sorted = getSortedArray(intersections.int_points1);\n        intersections.int_points2_sorted = getSortedArray(intersections.int_points2);\n\n        // Add new inner edges between intersection points\n        let int_point1_prev;\n        let int_point1_curr;\n        for (let i = 1; i <  intersections.int_points1_sorted.length; i++) {\n            int_point1_curr = intersections.int_points1_sorted[i];\n            int_point1_prev = intersections.int_points1_sorted[i-1];\n            if (int_point1_curr.edge_before && int_point1_curr.edge_before.bv === INSIDE$2) {\n                let edgeFrom = int_point1_prev.edge_after;\n                let edgeTo = int_point1_curr.edge_before;\n                let newEdges = multiline.getChain(edgeFrom, edgeTo);\n                insertBetweenIntPoints(intersections.int_points2[int_point1_prev.id], intersections.int_points2[int_point1_curr.id], newEdges);\n                newEdges.forEach(edge => newPoly.edges.add(edge));\n\n                newEdges = newEdges.reverse().map(edge => new Flatten.Edge(edge.shape.reverse()));\n                for (let k=0; k < newEdges.length-1; k++) {\n                    newEdges[k].next = newEdges[k+1];\n                    newEdges[k+1].prev = newEdges[k];\n                }\n                insertBetweenIntPoints(intersections.int_points2[int_point1_curr.id], intersections.int_points2[int_point1_prev.id], newEdges);\n                newEdges.forEach(edge => newPoly.edges.add(edge));\n            }\n\n        }\n\n        // Recreate faces\n        newPoly.recreateFaces();\n\n        return newPoly\n    }\n\n    /**\n     * A special case of cut() function\n     * The return is a polygon cut with line\n     * @param {Line} line - cutting line\n     * @returns {Polygon} newPoly - resulted polygon\n     */\n    cutWithLine(line) {\n        let multiline = new Multiline([line]);\n        return this.cut(multiline);\n    }\n\n    /**\n     * Returns the first found edge of polygon that contains given point\n     * If point is a vertex, return the edge where the point is an end vertex, not a start one\n     * @param {Point} pt\n     * @returns {Edge}\n     */\n    findEdgeByPoint(pt) {\n        let edge;\n        for (let face of this.faces) {\n            edge = face.findEdgeByPoint(pt);\n            if (edge !== undefined)\n                break;\n        }\n        return edge;\n    }\n\n    /**\n     * Split polygon into array of polygons, where each polygon is an outer face with all\n     * containing inner faces\n     * @returns {Flatten.Polygon[]}\n     */\n    splitToIslands() {\n        if (this.isEmpty()) return [];      // return empty array if polygon is empty\n        let polygons = this.toArray();      // split into array of one-loop polygons\n        /* Sort polygons by area in descending order */\n        polygons.sort((polygon1, polygon2) => polygon2.area() - polygon1.area());\n        /* define orientation of the island by orientation of the first polygon in array */\n        let orientation = [...polygons[0].faces][0].orientation();\n        /* Create output array from polygons with same orientation as a first polygon (array of islands) */\n        let newPolygons = polygons.filter(polygon => [...polygon.faces][0].orientation() === orientation);\n        for (let polygon of polygons) {\n            let face = [...polygon.faces][0];\n            if (face.orientation() === orientation) continue;  // skip same orientation\n            /* Proceed with opposite orientation */\n            /* Look if any of island polygons contains tested polygon as a hole */\n            for (let islandPolygon of newPolygons) {\n                if (face.shapes.every(shape => islandPolygon.contains(shape))) {\n                    islandPolygon.addFace(face.shapes);      // add polygon as a hole in islandPolygon\n                    break;\n                }\n            }\n        }\n        // TODO: assert if not all polygons added into output\n        return newPolygons;\n    }\n\n    /**\n     * Reverse orientation of all faces to opposite\n     * @returns {Polygon}\n     */\n    reverse() {\n        for (let face of this.faces) {\n            face.reverse();\n        }\n        return this;\n    }\n\n    /**\n     * Returns true if polygon contains shape: no point of shape lay outside of the polygon,\n     * false otherwise\n     * @param {Shape} shape - test shape\n     * @returns {boolean}\n     */\n    contains(shape) {\n        if (shape instanceof Flatten.Point) {\n            let rel = ray_shoot(this, shape);\n            return rel === INSIDE$2 || rel === BOUNDARY$1;\n        } else {\n            return cover(this, shape);\n        }\n    }\n\n    /**\n     * Return distance and shortest segment between polygon and other shape as array [distance, shortest_segment]\n     * @param {Shape} shape Shape of one of the types Point, Circle, Line, Segment, Arc or Polygon\n     * @returns {Number | Segment}\n     */\n    distanceTo(shape) {\n        // let {Distance} = Flatten;\n\n        if (shape instanceof Flatten.Point) {\n            let [dist, shortest_segment] = Flatten.Distance.point2polygon(shape, this);\n            shortest_segment = shortest_segment.reverse();\n            return [dist, shortest_segment];\n        }\n\n        if (shape instanceof Flatten.Circle ||\n            shape instanceof Flatten.Line ||\n            shape instanceof Flatten.Segment ||\n            shape instanceof Flatten.Arc) {\n            let [dist, shortest_segment] = Flatten.Distance.shape2polygon(shape, this);\n            shortest_segment = shortest_segment.reverse();\n            return [dist, shortest_segment];\n        }\n\n        /* this method is bit faster */\n        if (shape instanceof Flatten.Polygon) {\n            let min_dist_and_segment = [Number.POSITIVE_INFINITY, new Flatten.Segment()];\n            let dist, shortest_segment;\n\n            for (let edge of this.edges) {\n                // let [dist, shortest_segment] = Distance.shape2polygon(edge.shape, shape);\n                let min_stop = min_dist_and_segment[0];\n                [dist, shortest_segment] = Flatten.Distance.shape2planarSet(edge.shape, shape.edges, min_stop);\n                if (Flatten.Utils.LT(dist, min_stop)) {\n                    min_dist_and_segment = [dist, shortest_segment];\n                }\n            }\n            return min_dist_and_segment;\n        }\n    }\n\n    /**\n     * Return array of intersection points between polygon and other shape\n     * @param shape Shape of the one of supported types <br/>\n     * @returns {Point[]}\n     */\n    intersect(shape) {\n        if (shape instanceof Flatten.Point) {\n            return this.contains(shape) ? [shape] : [];\n        }\n\n        if (shape instanceof Flatten.Line) {\n            return intersectLine2Polygon(shape, this);\n        }\n\n        if (shape instanceof Flatten.Ray) {\n            return intersectRay2Polygon(shape, this);\n        }\n\n        if (shape instanceof Flatten.Circle) {\n            return intersectCircle2Polygon(shape, this);\n        }\n\n        if (shape instanceof Flatten.Segment) {\n            return intersectSegment2Polygon(shape, this);\n        }\n\n        if (shape instanceof Flatten.Arc) {\n            return intersectArc2Polygon(shape, this);\n        }\n\n        if (shape instanceof Flatten.Polygon) {\n            return intersectPolygon2Polygon(shape, this);\n        }\n    }\n\n    /**\n     * Returns new polygon translated by vector vec\n     * @param {Vector} vec\n     * @returns {Polygon}\n     */\n    translate(vec) {\n        let newPolygon = new Polygon();\n        for (let face of this.faces) {\n            newPolygon.addFace(face.shapes.map(shape => shape.translate(vec)));\n        }\n        return newPolygon;\n    }\n\n    /**\n     * Return new polygon rotated by given angle around given point\n     * If point omitted, rotate around origin (0,0)\n     * Positive value of angle defines rotation counterclockwise, negative - clockwise\n     * @param {number} angle - rotation angle in radians\n     * @param {Point} center - rotation center, default is (0,0)\n     * @returns {Polygon} - new rotated polygon\n     */\n    rotate(angle = 0, center = new Flatten.Point()) {\n        let newPolygon = new Polygon();\n        for (let face of this.faces) {\n            newPolygon.addFace(face.shapes.map(shape => shape.rotate(angle, center)));\n        }\n        return newPolygon;\n    }\n\n    /**\n     * Return new polygon with coordinates multiplied by scaling factor\n     * @param {number} sx - x-axis scaling factor\n     * @param {number} sy - y-axis scaling factor\n     * @returns {Polygon}\n     */\n    scale(sx, sy) {\n        let newPolygon = new Polygon();\n        for (let face of this.faces) {\n            newPolygon.addFace(face.shapes.map(shape => shape.scale(sx, sy)));\n        }\n        return newPolygon;\n    }\n\n    /**\n     * Return new polygon transformed using affine transformation matrix\n     * @param {Matrix} matrix - affine transformation matrix\n     * @returns {Polygon} - new polygon\n     */\n    transform(matrix = new Flatten.Matrix()) {\n        let newPolygon = new Polygon();\n        for (let face of this.faces) {\n            newPolygon.addFace(face.shapes.map(shape => shape.transform(matrix)));\n        }\n        return newPolygon;\n    }\n\n    /**\n     * This method returns an object that defines how data will be\n     * serialized when called JSON.stringify() method\n     * @returns {Object}\n     */\n    toJSON() {\n        return [...this.faces].map(face => face.toJSON());\n    }\n\n    /**\n     * Transform all faces into array of polygons\n     * @returns {Flatten.Polygon[]}\n     */\n    toArray() {\n        return [...this.faces].map(face => face.toPolygon());\n    }\n\n    /**\n     * Return string to draw polygon in svg\n     * @param attrs  - an object with attributes for svg path element\n     * @returns {string}\n     */\n    svg(attrs = {}) {\n        let svgStr = `\\n<path ${convertToString({fillRule: \"evenodd\", fill: \"lightcyan\", ...attrs})} d=\"`;\n        for (let face of this.faces) {\n            svgStr += face.svg();\n        }\n        svgStr += `\" >\\n</path>`;\n        return svgStr;\n    }\n}\n\nFlatten.Polygon = Polygon;\n\n/**\n * Shortcut method to create new polygon\n */\nconst polygon = (...args) => new Flatten.Polygon(...args);\nFlatten.polygon = polygon;\n\nconst {Circle, Line, Point, Vector, Utils} = Flatten;\n/**\n * Class Inversion represent operator of inversion in circle\n * Inversion is a transformation of the Euclidean plane that maps generalized circles\n * (where line is considered as a circle with infinite radius) into generalized circles\n * See also https://en.wikipedia.org/wiki/Inversive_geometry and\n * http://mathworld.wolfram.com/Inversion.html <br/>\n * @type {Inversion}\n */\nclass Inversion {\n    /**\n     * Inversion constructor\n     * @param {Circle} inversion_circle inversion circle\n     */\n    constructor(inversion_circle) {\n        this.circle = inversion_circle;\n    }\n\n\n    get inversion_circle() {\n        return this.circle;\n    }\n\n    static inversePoint(inversion_circle, point) {\n        const v = new Vector(inversion_circle.pc, point);\n        const k2 = inversion_circle.r * inversion_circle.r;\n        const len2 = v.dot(v);\n        const reflected_point = Utils.EQ_0(len2) ?\n            new Point(Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY) :\n            inversion_circle.pc.translate(v.multiply(k2 / len2));\n        return reflected_point;\n    }\n\n    static inverseCircle(inversion_circle, circle) {\n        const dist = inversion_circle.pc.distanceTo(circle.pc)[0];\n        if (Utils.EQ(dist, circle.r)) {     // Circle passing through inversion center mapped into line\n            let d = (inversion_circle.r * inversion_circle.r) / (2 * circle.r);\n            let v = new Vector(inversion_circle.pc, circle.pc);\n            v = v.normalize();\n            let pt = inversion_circle.pc.translate(v.multiply(d));\n\n            return new Line(pt, v);\n        } else {                           // Circle not passing through inversion center - map into another circle */\n            /* Taken from http://mathworld.wolfram.com */\n            let v = new Vector(inversion_circle.pc, circle.pc);\n            let s = inversion_circle.r * inversion_circle.r / (v.dot(v) - circle.r * circle.r);\n            let pc = inversion_circle.pc.translate(v.multiply(s));\n            let r = Math.abs(s) * circle.r;\n\n            return new Circle(pc, r);\n        }\n    }\n\n    static inverseLine(inversion_circle, line) {\n        const [dist, shortest_segment] = inversion_circle.pc.distanceTo(line);\n        if (Utils.EQ_0(dist)) {            // Line passing through inversion center, is mapping to itself\n            return line.clone();\n        } else {                           // Line not passing through inversion center is mapping into circle\n            let r = inversion_circle.r * inversion_circle.r / (2 * dist);\n            let v = new Vector(inversion_circle.pc, shortest_segment.end);\n            v = v.multiply(r / dist);\n            return new Circle(inversion_circle.pc.translate(v), r);\n        }\n    }\n\n    inverse(shape) {\n        if (shape instanceof Point) {\n            return Inversion.inversePoint(this.circle, shape);\n        }\n        else if (shape instanceof Circle) {\n            return Inversion.inverseCircle(this.circle, shape);\n        }\n        else if (shape instanceof Line) {\n            return Inversion.inverseLine(this.circle, shape);\n        }\n    }\n}\nFlatten.Inversion = Inversion;\n\n/**\n * Shortcut to create inversion operator\n * @param circle\n * @returns {Inversion}\n */\nconst inversion = (circle) => new Flatten.Inversion(circle);\nFlatten.inversion = inversion;\n\nclass Distance {\n    /**\n     * Calculate distance and shortest segment between points\n     * @param pt1\n     * @param pt2\n     * @returns {Number | Segment} - distance and shortest segment\n     */\n    static point2point(pt1, pt2) {\n        return pt1.distanceTo(pt2);\n    }\n\n    /**\n     * Calculate distance and shortest segment between point and line\n     * @param pt\n     * @param line\n     * @returns {Number | Segment} - distance and shortest segment\n     */\n    static point2line(pt, line) {\n        let closest_point = pt.projectionOn(line);\n        let vec = new Flatten.Vector(pt, closest_point);\n        return [vec.length, new Flatten.Segment(pt, closest_point)];\n    }\n\n    /**\n     * Calculate distance and shortest segment between point and circle\n     * @param pt\n     * @param circle\n     * @returns {Number | Segment} - distance and shortest segment\n     */\n    static point2circle(pt, circle) {\n        let [dist2center, shortest_dist] = pt.distanceTo(circle.center);\n        if (Flatten.Utils.EQ_0(dist2center)) {\n            return [circle.r, new Flatten.Segment(pt, circle.toArc().start)];\n        } else {\n            let dist = Math.abs(dist2center - circle.r);\n            let v = new Flatten.Vector(circle.pc, pt).normalize().multiply(circle.r);\n            let closest_point = circle.pc.translate(v);\n            return [dist, new Flatten.Segment(pt, closest_point)];\n        }\n    }\n\n    /**\n     * Calculate distance and shortest segment between point and segment\n     * @param pt\n     * @param segment\n     * @returns {Number | Segment} - distance and shortest segment\n     */\n    static point2segment(pt, segment) {\n        /* Degenerated case of zero-length segment */\n        if (segment.start.equalTo(segment.end)) {\n            return Distance.point2point(pt, segment.start);\n        }\n\n        let v_seg = new Flatten.Vector(segment.start, segment.end);\n        let v_ps2pt = new Flatten.Vector(segment.start, pt);\n        let v_pe2pt = new Flatten.Vector(segment.end, pt);\n        let start_sp = v_seg.dot(v_ps2pt);\n        /* dot product v_seg * v_ps2pt */\n        let end_sp = -v_seg.dot(v_pe2pt);\n        /* minus dot product v_seg * v_pe2pt */\n\n        let dist;\n        let closest_point;\n        if (Flatten.Utils.GE(start_sp, 0) && Flatten.Utils.GE(end_sp, 0)) {    /* point inside segment scope */\n            let v_unit = segment.tangentInStart(); // new Flatten.Vector(v_seg.x / this.length, v_seg.y / this.length);\n            /* unit vector ||v_unit|| = 1 */\n            dist = Math.abs(v_unit.cross(v_ps2pt));\n            /* dist = abs(v_unit x v_ps2pt) */\n            closest_point = segment.start.translate(v_unit.multiply(v_unit.dot(v_ps2pt)));\n            return [dist, new Flatten.Segment(pt, closest_point)];\n        } else if (start_sp < 0) {                             /* point is out of scope closer to ps */\n            return pt.distanceTo(segment.start);\n        } else {                                               /* point is out of scope closer to pe */\n            return pt.distanceTo(segment.end);\n        }\n    };\n\n    /**\n     * Calculate distance and shortest segment between point and arc\n     * @param pt\n     * @param arc\n     * @returns {Number | Segment} - distance and shortest segment\n     */\n    static point2arc(pt, arc) {\n        let circle = new Flatten.Circle(arc.pc, arc.r);\n        let dist_and_segment = [];\n        let dist, shortest_segment;\n        [dist, shortest_segment] = Distance.point2circle(pt, circle);\n        if (shortest_segment.end.on(arc)) {\n            dist_and_segment.push(Distance.point2circle(pt, circle));\n        }\n        dist_and_segment.push(Distance.point2point(pt, arc.start));\n        dist_and_segment.push(Distance.point2point(pt, arc.end));\n\n        Distance.sort(dist_and_segment);\n\n        return dist_and_segment[0];\n    }\n\n    /**\n     * Calculate distance and shortest segment between segment and line\n     * @param seg\n     * @param line\n     * @returns {Number | Segment}\n     */\n    static segment2line(seg, line) {\n        let ip = seg.intersect(line);\n        if (ip.length > 0) {\n            return [0, new Flatten.Segment(ip[0], ip[0])];   // distance = 0, closest point is the first point\n        }\n        let dist_and_segment = [];\n        dist_and_segment.push(Distance.point2line(seg.start, line));\n        dist_and_segment.push(Distance.point2line(seg.end, line));\n\n        Distance.sort(dist_and_segment);\n        return dist_and_segment[0];\n\n    }\n\n    /**\n     * Calculate distance and shortest segment between two segments\n     * @param seg1\n     * @param seg2\n     * @returns {Number | Segment} - distance and shortest segment\n     */\n    static segment2segment(seg1, seg2) {\n        let ip = intersectSegment2Segment(seg1, seg2);\n        if (ip.length > 0) {\n            return [0, new Flatten.Segment(ip[0], ip[0])];   // distance = 0, closest point is the first point\n        }\n\n        // Seg1 and seg2 not intersected\n        let dist_and_segment = [];\n        let dist_tmp, shortest_segment_tmp;\n        [dist_tmp, shortest_segment_tmp] = Distance.point2segment(seg2.start, seg1);\n        dist_and_segment.push([dist_tmp, shortest_segment_tmp.reverse()]);\n        [dist_tmp, shortest_segment_tmp] = Distance.point2segment(seg2.end, seg1);\n        dist_and_segment.push([dist_tmp, shortest_segment_tmp.reverse()]);\n        dist_and_segment.push(Distance.point2segment(seg1.start, seg2));\n        dist_and_segment.push(Distance.point2segment(seg1.end, seg2));\n\n        Distance.sort(dist_and_segment);\n        return dist_and_segment[0];\n    }\n\n    /**\n     * Calculate distance and shortest segment between segment and circle\n     * @param seg\n     * @param circle\n     * @returns {Number | Segment} - distance and shortest segment\n     */\n    static segment2circle(seg, circle) {\n        /* Case 1 Segment and circle intersected. Return the first point and zero distance */\n        let ip = seg.intersect(circle);\n        if (ip.length > 0) {\n            return [0, new Flatten.Segment(ip[0], ip[0])];\n        }\n\n        // No intersection between segment and circle\n\n        /* Case 2. Distance to projection of center point to line bigger than radius\n         * And projection point belong to segment\n          * Then measure again distance from projection to circle and return it */\n        let line = new Flatten.Line(seg.ps, seg.pe);\n        let [dist, shortest_segment] = Distance.point2line(circle.center, line);\n        if (Flatten.Utils.GE(dist, circle.r) && shortest_segment.end.on(seg)) {\n            return Distance.point2circle(shortest_segment.end, circle);\n        }\n        /* Case 3. Otherwise closest point is one of the end points of the segment */\n        else {\n            let [dist_from_start, shortest_segment_from_start] = Distance.point2circle(seg.start, circle);\n            let [dist_from_end, shortest_segment_from_end] = Distance.point2circle(seg.end, circle);\n            return Flatten.Utils.LT(dist_from_start, dist_from_end) ?\n                [dist_from_start, shortest_segment_from_start] :\n                [dist_from_end, shortest_segment_from_end];\n        }\n    }\n\n    /**\n     * Calculate distance and shortest segment between segment and arc\n     * @param seg\n     * @param arc\n     * @returns {Number | Segment} - distance and shortest segment\n     */\n    static segment2arc(seg, arc) {\n        /* Case 1 Segment and arc intersected. Return the first point and zero distance */\n        let ip = seg.intersect(arc);\n        if (ip.length > 0) {\n            return [0, new Flatten.Segment(ip[0], ip[0])];\n        }\n\n        // No intersection between segment and arc\n        let line = new Flatten.Line(seg.ps, seg.pe);\n        let circle = new Flatten.Circle(arc.pc, arc.r);\n\n        /* Case 2. Distance to projection of center point to line bigger than radius AND\n         * projection point belongs to segment AND\n           * distance from projection point to circle belongs to arc  =>\n           * return this distance from projection to circle */\n        let [dist_from_center, shortest_segment_from_center] = Distance.point2line(circle.center, line);\n        if (Flatten.Utils.GE(dist_from_center, circle.r) && shortest_segment_from_center.end.on(seg)) {\n            let [dist_from_projection, shortest_segment_from_projection] =\n                Distance.point2circle(shortest_segment_from_center.end, circle);\n            if (shortest_segment_from_projection.end.on(arc)) {\n                return [dist_from_projection, shortest_segment_from_projection];\n            }\n        }\n        /* Case 3. Otherwise closest point is one of the end points of the segment */\n        let dist_and_segment = [];\n        dist_and_segment.push(Distance.point2arc(seg.start, arc));\n        dist_and_segment.push(Distance.point2arc(seg.end, arc));\n\n        let dist_tmp, segment_tmp;\n        [dist_tmp, segment_tmp] = Distance.point2segment(arc.start, seg);\n        dist_and_segment.push([dist_tmp, segment_tmp.reverse()]);\n\n        [dist_tmp, segment_tmp] = Distance.point2segment(arc.end, seg);\n        dist_and_segment.push([dist_tmp, segment_tmp.reverse()]);\n\n        Distance.sort(dist_and_segment);\n        return dist_and_segment[0];\n    }\n\n    /**\n     * Calculate distance and shortest segment between two circles\n     * @param circle1\n     * @param circle2\n     * @returns {Number | Segment} - distance and shortest segment\n     */\n    static circle2circle(circle1, circle2) {\n        let ip = circle1.intersect(circle2);\n        if (ip.length > 0) {\n            return [0, new Flatten.Segment(ip[0], ip[0])];\n        }\n\n        // Case 1. Concentric circles. Convert to arcs and take distance between two arc starts\n        if (circle1.center.equalTo(circle2.center)) {\n            let arc1 = circle1.toArc();\n            let arc2 = circle2.toArc();\n            return Distance.point2point(arc1.start, arc2.start);\n        } else {\n            // Case 2. Not concentric circles\n            let line = new Flatten.Line(circle1.center, circle2.center);\n            let ip1 = line.intersect(circle1);\n            let ip2 = line.intersect(circle2);\n\n            let dist_and_segment = [];\n\n            dist_and_segment.push(Distance.point2point(ip1[0], ip2[0]));\n            dist_and_segment.push(Distance.point2point(ip1[0], ip2[1]));\n            dist_and_segment.push(Distance.point2point(ip1[1], ip2[0]));\n            dist_and_segment.push(Distance.point2point(ip1[1], ip2[1]));\n\n            Distance.sort(dist_and_segment);\n            return dist_and_segment[0];\n        }\n    }\n\n    /**\n     * Calculate distance and shortest segment between two circles\n     * @param circle\n     * @param line\n     * @returns {Number | Segment} - distance and shortest segment\n     */\n    static circle2line(circle, line) {\n        let ip = circle.intersect(line);\n        if (ip.length > 0) {\n            return [0, new Flatten.Segment(ip[0], ip[0])];\n        }\n\n        let [dist_from_center, shortest_segment_from_center] = Distance.point2line(circle.center, line);\n        let [dist, shortest_segment] = Distance.point2circle(shortest_segment_from_center.end, circle);\n        shortest_segment = shortest_segment.reverse();\n        return [dist, shortest_segment];\n    }\n\n    /**\n     * Calculate distance and shortest segment between arc and line\n     * @param arc\n     * @param line\n     * @returns {Number | Segment} - distance and shortest segment\n     */\n    static arc2line(arc, line) {\n        /* Case 1 Line and arc intersected. Return the first point and zero distance */\n        let ip = line.intersect(arc);\n        if (ip.length > 0) {\n            return [0, new Flatten.Segment(ip[0], ip[0])];\n        }\n\n        let circle = new Flatten.Circle(arc.center, arc.r);\n\n        /* Case 2. Distance to projection of center point to line bigger than radius AND\n         * projection point belongs to segment AND\n           * distance from projection point to circle belongs to arc  =>\n           * return this distance from projection to circle */\n        let [dist_from_center, shortest_segment_from_center] = Distance.point2line(circle.center, line);\n        if (Flatten.Utils.GE(dist_from_center, circle.r)) {\n            let [dist_from_projection, shortest_segment_from_projection] =\n                Distance.point2circle(shortest_segment_from_center.end, circle);\n            if (shortest_segment_from_projection.end.on(arc)) {\n                return [dist_from_projection, shortest_segment_from_projection];\n            }\n        } else {\n            let dist_and_segment = [];\n            dist_and_segment.push(Distance.point2line(arc.start, line));\n            dist_and_segment.push(Distance.point2line(arc.end, line));\n\n            Distance.sort(dist_and_segment);\n            return dist_and_segment[0];\n        }\n    }\n\n    /**\n     * Calculate distance and shortest segment between arc and circle\n     * @param arc\n     * @param circle2\n     * @returns {Number | Segment} - distance and shortest segment\n     */\n    static arc2circle(arc, circle2) {\n        let ip = arc.intersect(circle2);\n        if (ip.length > 0) {\n            return [0, new Flatten.Segment(ip[0], ip[0])];\n        }\n\n        let circle1 = new Flatten.Circle(arc.center, arc.r);\n\n        let [dist, shortest_segment] = Distance.circle2circle(circle1, circle2);\n        if (shortest_segment.start.on(arc)) {\n            return [dist, shortest_segment];\n        } else {\n            let dist_and_segment = [];\n\n            dist_and_segment.push(Distance.point2circle(arc.start, circle2));\n            dist_and_segment.push(Distance.point2circle(arc.end, circle2));\n\n            Distance.sort(dist_and_segment);\n\n            return dist_and_segment[0];\n        }\n    }\n\n    /**\n     * Calculate distance and shortest segment between two arcs\n     * @param arc1\n     * @param arc2\n     * @returns {Number | Segment} - distance and shortest segment\n     */\n    static arc2arc(arc1, arc2) {\n        let ip = arc1.intersect(arc2);\n        if (ip.length > 0) {\n            return [0, new Flatten.Segment(ip[0], ip[0])];\n        }\n\n        let circle1 = new Flatten.Circle(arc1.center, arc1.r);\n        let circle2 = new Flatten.Circle(arc2.center, arc2.r);\n\n        let [dist, shortest_segment] = Distance.circle2circle(circle1, circle2);\n        if (shortest_segment.start.on(arc1) && shortest_segment.end.on(arc2)) {\n            return [dist, shortest_segment];\n        } else {\n            let dist_and_segment = [];\n\n            let dist_tmp, segment_tmp;\n\n            [dist_tmp, segment_tmp] = Distance.point2arc(arc1.start, arc2);\n            if (segment_tmp.end.on(arc2)) {\n                dist_and_segment.push([dist_tmp, segment_tmp]);\n            }\n\n            [dist_tmp, segment_tmp] = Distance.point2arc(arc1.end, arc2);\n            if (segment_tmp.end.on(arc2)) {\n                dist_and_segment.push([dist_tmp, segment_tmp]);\n            }\n\n            [dist_tmp, segment_tmp] = Distance.point2arc(arc2.start, arc1);\n            if (segment_tmp.end.on(arc1)) {\n                dist_and_segment.push([dist_tmp, segment_tmp.reverse()]);\n            }\n\n            [dist_tmp, segment_tmp] = Distance.point2arc(arc2.end, arc1);\n            if (segment_tmp.end.on(arc1)) {\n                dist_and_segment.push([dist_tmp, segment_tmp.reverse()]);\n            }\n\n            [dist_tmp, segment_tmp] = Distance.point2point(arc1.start, arc2.start);\n            dist_and_segment.push([dist_tmp, segment_tmp]);\n\n            [dist_tmp, segment_tmp] = Distance.point2point(arc1.start, arc2.end);\n            dist_and_segment.push([dist_tmp, segment_tmp]);\n\n            [dist_tmp, segment_tmp] = Distance.point2point(arc1.end, arc2.start);\n            dist_and_segment.push([dist_tmp, segment_tmp]);\n\n            [dist_tmp, segment_tmp] = Distance.point2point(arc1.end, arc2.end);\n            dist_and_segment.push([dist_tmp, segment_tmp]);\n\n            Distance.sort(dist_and_segment);\n\n            return dist_and_segment[0];\n        }\n    }\n\n    /**\n     * Calculate distance and shortest segment between point and polygon\n     * @param point\n     * @param polygon\n     * @returns {Number | Segment} - distance and shortest segment\n     */\n    static point2polygon(point, polygon) {\n        let min_dist_and_segment = [Number.POSITIVE_INFINITY, new Flatten.Segment()];\n        for (let edge of polygon.edges) {\n            let [dist, shortest_segment] = (edge.shape instanceof Flatten.Segment) ?\n                Distance.point2segment(point, edge.shape) : Distance.point2arc(point, edge.shape);\n            if (Flatten.Utils.LT(dist, min_dist_and_segment[0])) {\n                min_dist_and_segment = [dist, shortest_segment];\n            }\n        }\n        return min_dist_and_segment;\n    }\n\n    static shape2polygon(shape, polygon) {\n        let min_dist_and_segment = [Number.POSITIVE_INFINITY, new Flatten.Segment()];\n        for (let edge of polygon.edges) {\n            let [dist, shortest_segment] = shape.distanceTo(edge.shape);\n            if (Flatten.Utils.LT(dist, min_dist_and_segment[0])) {\n                min_dist_and_segment = [dist, shortest_segment];\n            }\n        }\n        return min_dist_and_segment;\n    }\n\n    /**\n     * Calculate distance and shortest segment between two polygons\n     * @param polygon1\n     * @param polygon2\n     * @returns {Number | Segment} - distance and shortest segment\n     */\n    static polygon2polygon(polygon1, polygon2) {\n        let min_dist_and_segment = [Number.POSITIVE_INFINITY, new Flatten.Segment()];\n        for (let edge1 of polygon1.edges) {\n            for (let edge2 of polygon2.edges) {\n                let [dist, shortest_segment] = edge1.shape.distanceTo(edge2.shape);\n                if (Flatten.Utils.LT(dist, min_dist_and_segment[0])) {\n                    min_dist_and_segment = [dist, shortest_segment];\n                }\n            }\n        }\n        return min_dist_and_segment;\n    }\n\n    /**\n     * Returns [mindist, maxdist] array of squared minimal and maximal distance between boxes\n     * Minimal distance by x is\n     *    (box2.xmin - box1.xmax), if box1 is left to box2\n     *    (box1.xmin - box2.xmax), if box2 is left to box1\n     *    0,                       if box1 and box2 are intersected by x\n     * Minimal distance by y is defined in the same way\n     *\n     * Maximal distance is estimated as a sum of squared dimensions of the merged box\n     *\n     * @param box1\n     * @param box2\n     * @returns {Number | Number} - minimal and maximal distance\n     */\n    static box2box_minmax(box1, box2) {\n        let mindist_x = Math.max(Math.max(box1.xmin - box2.xmax, 0), Math.max(box2.xmin - box1.xmax, 0));\n        let mindist_y = Math.max(Math.max(box1.ymin - box2.ymax, 0), Math.max(box2.ymin - box1.ymax, 0));\n        let mindist = mindist_x * mindist_x + mindist_y * mindist_y;\n\n        let box = box1.merge(box2);\n        let dx = box.xmax - box.xmin;\n        let dy = box.ymax - box.ymin;\n        let maxdist = dx * dx + dy * dy;\n\n        return [mindist, maxdist];\n    }\n\n    static minmax_tree_process_level(shape, level, min_stop, tree) {\n        // Calculate minmax distance to each shape in current level\n        // Insert result into the interval tree for further processing\n        // update min_stop with maxdist, it will be the new stop distance\n        let mindist, maxdist;\n        for (let node of level) {\n\n            // [mindist, maxdist] = Distance.box2box_minmax(shape.box, node.max);\n            // if (Flatten.Utils.GT(mindist, min_stop))\n            //     continue;\n\n            // Estimate min-max dist to the shape stored in the node.item, using node.item.key which is shape's box\n            [mindist, maxdist] = Distance.box2box_minmax(shape.box, node.item.key);\n            if (node.item.value instanceof Flatten.Edge) {\n                tree.insert([mindist, maxdist], node.item.value.shape);\n            } else {\n                tree.insert([mindist, maxdist], node.item.value);\n            }\n            if (Flatten.Utils.LT(maxdist, min_stop)) {\n                min_stop = maxdist;                       // this will be the new distance estimation\n            }\n        }\n\n        if (level.length === 0)\n            return min_stop;\n\n        // Calculate new level from left and right children of the current\n        let new_level_left = level.map(node => node.left.isNil() ? undefined : node.left).filter(node => node !== undefined);\n        let new_level_right = level.map(node => node.right.isNil() ? undefined : node.right).filter(node => node !== undefined);\n        // Merge left and right subtrees and leave only relevant subtrees\n        let new_level = [...new_level_left, ...new_level_right].filter(node => {\n            // Node subtree quick reject, node.max is a subtree box\n            let [mindist, maxdist] = Distance.box2box_minmax(shape.box, node.max);\n            return (Flatten.Utils.LE(mindist, min_stop));\n        });\n\n        min_stop = Distance.minmax_tree_process_level(shape, new_level, min_stop, tree);\n        return min_stop;\n    }\n\n    /**\n     * Calculates sorted tree of [mindist, maxdist] intervals between query shape\n     * and shapes of the planar set.\n     * @param shape\n     * @param set\n     */\n    static minmax_tree(shape, set, min_stop) {\n        let tree = new IntervalTree();\n        let level = [set.index.root];\n        let squared_min_stop = min_stop < Number.POSITIVE_INFINITY ? min_stop * min_stop : Number.POSITIVE_INFINITY;\n        squared_min_stop = Distance.minmax_tree_process_level(shape, level, squared_min_stop, tree);\n        return tree;\n    }\n\n    static minmax_tree_calc_distance(shape, node, min_dist_and_segment) {\n        let min_dist_and_segment_new, stop;\n        if (node != null && !node.isNil()) {\n            [min_dist_and_segment_new, stop] = Distance.minmax_tree_calc_distance(shape, node.left, min_dist_and_segment);\n\n            if (stop) {\n                return [min_dist_and_segment_new, stop];\n            }\n\n            if (Flatten.Utils.LT(min_dist_and_segment_new[0], Math.sqrt(node.item.key.low))) {\n                return [min_dist_and_segment_new, true];   // stop condition\n            }\n\n            let [dist, shortest_segment] = Distance.distance(shape, node.item.value);\n            // console.log(dist)\n            if (Flatten.Utils.LT(dist, min_dist_and_segment_new[0])) {\n                min_dist_and_segment_new = [dist, shortest_segment];\n            }\n\n            [min_dist_and_segment_new, stop] = Distance.minmax_tree_calc_distance(shape, node.right, min_dist_and_segment_new);\n\n            return [min_dist_and_segment_new, stop];\n        }\n\n        return [min_dist_and_segment, false];\n    }\n\n    /**\n     * Calculates distance between shape and Planar Set of shapes\n     * @param shape\n     * @param {PlanarSet} set\n     * @param {Number} min_stop\n     * @returns {*}\n     */\n    static shape2planarSet(shape, set, min_stop = Number.POSITIVE_INFINITY) {\n        let min_dist_and_segment = [min_stop, new Flatten.Segment()];\n        let stop = false;\n        if (set instanceof Flatten.PlanarSet) {\n            let tree = Distance.minmax_tree(shape, set, min_stop);\n            [min_dist_and_segment, stop] = Distance.minmax_tree_calc_distance(shape, tree.root, min_dist_and_segment);\n        }\n        return min_dist_and_segment;\n    }\n\n    static sort(dist_and_segment) {\n        dist_and_segment.sort((d1, d2) => {\n            if (Flatten.Utils.LT(d1[0], d2[0])) {\n                return -1;\n            }\n            if (Flatten.Utils.GT(d1[0], d2[0])) {\n                return 1;\n            }\n            return 0;\n        });\n    }\n\n    static distance(shape1, shape2) {\n        return shape1.distanceTo(shape2);\n    }\n}\n\nFlatten.Distance = Distance;\n\n/**\n * Created by Alex Bol on 2/18/2017.\n */\n\n\nFlatten.BooleanOperations = BooleanOperations;\nFlatten.Relations = Relations;\n\nexport { Arc, BOUNDARY$1 as BOUNDARY, BooleanOperations, Box, CCW, CW, Circle$1 as Circle, Distance, Edge, Errors, Face, INSIDE$2 as INSIDE, Inversion, Line$1 as Line, Matrix, Multiline, ORIENTATION, OUTSIDE$1 as OUTSIDE, OVERLAP_OPPOSITE$1 as OVERLAP_OPPOSITE, OVERLAP_SAME$1 as OVERLAP_SAME, PlanarSet, Point$1 as Point, Polygon, Ray, Relations, Segment, smart_intersections as SmartIntersections, Utils$1 as Utils, Vector$1 as Vector, arc, box, circle, Flatten as default, inversion, line, matrix, multiline, point, polygon, ray, ray_shoot, segment, vector$1 as vector };\n","// /* eslint-disable no-unused-vars */\n// import Flatten from '../../node_modules/@flatten-js/core/dist/main.mjs';\nimport Flatten from '@flatten-js/core';\nconst {point, Polygon} = Flatten;\n\nconst { unify } = Flatten.BooleanOperations;\n\nlet polygon4 = new Polygon([0.5, ]);\nconsole.log(\"polygon4\", polygon4);\n\nfunction boolcall(){\n  console.log(\"BooleanUnion.js is called\");\n  return \"BooleanUnion.js called :~)\";\n}\n\nfunction getNumLayers(path0, path1){\n  //return larger number of layers\n  const layers0 = new Set();\n  const layers1 = new Set();\n  layers0.forEach(p => path0.add(p[2]));\n  layers1.forEach(p => path1.add(p[2]));\n  return Math.max(layers0.size, layers1.size);\n}\n\n\nfunction union(path0, path1, radius){ //revise\n  //assuming path0 is an array of points [x, y, z] -> [[1, 2, 3], [4, 5, 6], ...]\n  //Flattenjs doesn't take in a tolerance\n  let layers0 = getNumLayers(path0);\n\n  // let path = [];\n  let path = [43.0];\n\n  for(let layer = 0; layer < layers0.length; layer++){\n    let points0 = path0.filter(p => p[2] == layer).map(p => point([p[0], p[1]]));\n    let points1 = path1.filter(p => p[2] == layer).map(p => point([p[0], p[1]]));\n\n    let polygon0 = new Polygon(points0);\n    let polygon1 = new Polygon(points1);\n    \n    let combinedPolygon = unify(polygon0, polygon1);\n    let filletedPolygon = combinedPolygon.fillet(radius); \n    let combinedLayerPoints = filletedPolygon.vertices.map(vertex => [vertex.x, vertex.y]);\n    path.push(combinedLayerPoints);\n    path.push(3.0); //test\n  }\n  console.log(\"Union path\", path);\n  return path;\n}","var OVERLAY_ID = '__parcel__error__overlay__';\n\nvar OldModule = module.bundle.Module;\n\nfunction Module(moduleName) {\n  OldModule.call(this, moduleName);\n  this.hot = {\n    data: module.bundle.hotData,\n    _acceptCallbacks: [],\n    _disposeCallbacks: [],\n    accept: function (fn) {\n      this._acceptCallbacks.push(fn || function () {});\n    },\n    dispose: function (fn) {\n      this._disposeCallbacks.push(fn);\n    }\n  };\n\n  module.bundle.hotData = null;\n}\n\nmodule.bundle.Module = Module;\nvar checkedAssets, assetsToAccept;\n\nvar parent = module.bundle.parent;\nif ((!parent || !parent.isParcelRequire) && typeof WebSocket !== 'undefined') {\n  var hostname = process.env.HMR_HOSTNAME || location.hostname;\n  var protocol = location.protocol === 'https:' ? 'wss' : 'ws';\n  var ws = new WebSocket(protocol + '://' + hostname + ':' + process.env.HMR_PORT + '/');\n  ws.onmessage = function(event) {\n    checkedAssets = {};\n    assetsToAccept = [];\n\n    var data = JSON.parse(event.data);\n\n    if (data.type === 'update') {\n      var handled = false;\n      data.assets.forEach(function(asset) {\n        if (!asset.isNew) {\n          var didAccept = hmrAcceptCheck(global.parcelRequire, asset.id);\n          if (didAccept) {\n            handled = true;\n          }\n        }\n      });\n\n      // Enable HMR for CSS by default.\n      handled = handled || data.assets.every(function(asset) {\n        return asset.type === 'css' && asset.generated.js;\n      });\n\n      if (handled) {\n        console.clear();\n\n        data.assets.forEach(function (asset) {\n          hmrApply(global.parcelRequire, asset);\n        });\n\n        assetsToAccept.forEach(function (v) {\n          hmrAcceptRun(v[0], v[1]);\n        });\n      } else if (location.reload) { // `location` global exists in a web worker context but lacks `.reload()` function.\n        location.reload();\n      }\n    }\n\n    if (data.type === 'reload') {\n      ws.close();\n      ws.onclose = function () {\n        location.reload();\n      }\n    }\n\n    if (data.type === 'error-resolved') {\n      console.log('[parcel]  Error resolved');\n\n      removeErrorOverlay();\n    }\n\n    if (data.type === 'error') {\n      console.error('[parcel]   ' + data.error.message + '\\n' + data.error.stack);\n\n      removeErrorOverlay();\n\n      var overlay = createErrorOverlay(data);\n      document.body.appendChild(overlay);\n    }\n  };\n}\n\nfunction removeErrorOverlay() {\n  var overlay = document.getElementById(OVERLAY_ID);\n  if (overlay) {\n    overlay.remove();\n  }\n}\n\nfunction createErrorOverlay(data) {\n  var overlay = document.createElement('div');\n  overlay.id = OVERLAY_ID;\n\n  // html encode message and stack trace\n  var message = document.createElement('div');\n  var stackTrace = document.createElement('pre');\n  message.innerText = data.error.message;\n  stackTrace.innerText = data.error.stack;\n\n  overlay.innerHTML = (\n    '<div style=\"background: black; font-size: 16px; color: white; position: fixed; height: 100%; width: 100%; top: 0px; left: 0px; padding: 30px; opacity: 0.85; font-family: Menlo, Consolas, monospace; z-index: 9999;\">' +\n      '<span style=\"background: red; padding: 2px 4px; border-radius: 2px;\">ERROR</span>' +\n      '<span style=\"top: 2px; margin-left: 5px; position: relative;\"></span>' +\n      '<div style=\"font-size: 18px; font-weight: bold; margin-top: 20px;\">' + message.innerHTML + '</div>' +\n      '<pre>' + stackTrace.innerHTML + '</pre>' +\n    '</div>'\n  );\n\n  return overlay;\n\n}\n\nfunction getParents(bundle, id) {\n  var modules = bundle.modules;\n  if (!modules) {\n    return [];\n  }\n\n  var parents = [];\n  var k, d, dep;\n\n  for (k in modules) {\n    for (d in modules[k][1]) {\n      dep = modules[k][1][d];\n      if (dep === id || (Array.isArray(dep) && dep[dep.length - 1] === id)) {\n        parents.push(k);\n      }\n    }\n  }\n\n  if (bundle.parent) {\n    parents = parents.concat(getParents(bundle.parent, id));\n  }\n\n  return parents;\n}\n\nfunction hmrApply(bundle, asset) {\n  var modules = bundle.modules;\n  if (!modules) {\n    return;\n  }\n\n  if (modules[asset.id] || !bundle.parent) {\n    var fn = new Function('require', 'module', 'exports', asset.generated.js);\n    asset.isNew = !modules[asset.id];\n    modules[asset.id] = [fn, asset.deps];\n  } else if (bundle.parent) {\n    hmrApply(bundle.parent, asset);\n  }\n}\n\nfunction hmrAcceptCheck(bundle, id) {\n  var modules = bundle.modules;\n  if (!modules) {\n    return;\n  }\n\n  if (!modules[id] && bundle.parent) {\n    return hmrAcceptCheck(bundle.parent, id);\n  }\n\n  if (checkedAssets[id]) {\n    return;\n  }\n  checkedAssets[id] = true;\n\n  var cached = bundle.cache[id];\n\n  assetsToAccept.push([bundle, id]);\n\n  if (cached && cached.hot && cached.hot._acceptCallbacks.length) {\n    return true;\n  }\n\n  return getParents(global.parcelRequire, id).some(function (id) {\n    return hmrAcceptCheck(global.parcelRequire, id)\n  });\n}\n\nfunction hmrAcceptRun(bundle, id) {\n  var cached = bundle.cache[id];\n  bundle.hotData = {};\n  if (cached) {\n    cached.hot.data = bundle.hotData;\n  }\n\n  if (cached && cached.hot && cached.hot._disposeCallbacks.length) {\n    cached.hot._disposeCallbacks.forEach(function (cb) {\n      cb(bundle.hotData);\n    });\n  }\n\n  delete bundle.cache[id];\n  bundle(id);\n\n  cached = bundle.cache[id];\n  if (cached && cached.hot && cached.hot._acceptCallbacks.length) {\n    cached.hot._acceptCallbacks.forEach(function (cb) {\n      cb();\n    });\n    return true;\n  }\n}\n"]}