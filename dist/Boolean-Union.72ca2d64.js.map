{"version":3,"sources":["node_modules/flatten-js/utils/utils.js","node_modules/flatten-js/utils/errors.js","node_modules/flatten-js/classes/matrix.js","node_modules/flatten-interval-tree/classes/interval.js","node_modules/flatten-interval-tree/utils/constants.js","node_modules/flatten-interval-tree/classes/node.js","node_modules/flatten-interval-tree/index.js","node_modules/flatten-js/data_structures/planar_set.js","node_modules/flatten-js/classes/point.js","node_modules/flatten-js/classes/vector.js","node_modules/flatten-js/classes/line.js","node_modules/flatten-js/classes/circle.js","node_modules/flatten-js/classes/segment.js","node_modules/flatten-js/classes/arc.js","node_modules/flatten-js/classes/box.js","node_modules/flatten-js/classes/edge.js","node_modules/flatten-js/classes/face.js","node_modules/flatten-js/classes/ray.js","node_modules/flatten-js/algorithms/ray_shooting.js","node_modules/flatten-js/classes/polygon.js","node_modules/flatten-js/algorithms/distance.js","node_modules/flatten-js/index.js","coilcam-functions/boolean/Boolean-Union.js","node_modules/parcel-bundler/src/builtins/hmr-runtime.js"],"names":["DP_TOL","DECIMALS","module","exports","EQ_0","x","EQ","y","GT","GE","LT","LE","ILLEGAL_PARAMETERS","ReferenceError","ZERO_DIVISION","Error","Flatten","Matrix","constructor","a","b","c","d","tx","ty","clone","transform","vector","multiply","other_matrix","translate","args","length","Vector","Errors","rotate","angle","cos","Math","sin","scale","sx","sy","equalTo","matrix","Utils","IntervalTree","require","PlanarSet","Set","index","add","shape","size","node","insert","box","delete","deleted","remove","clear","search","resp","hit","point","Box","filter","on","svg","svgcontent","reduce","acc","Point","Array","arr","Object","name","vertices","pt","lessThan","center","x_rot","y_rot","m","projectionOn","line","vec","cross","norm","dist","dot","proj_vec","leftTo","onLeftSemiPlane","distanceTo","Distance","dx","dy","sqrt","Segment","Line","point2line","Circle","point2circle","point2segment","Arc","point2arc","Polygon","point2polygon","shape2planarSet","contains","attrs","r","stroke","strokeWidth","fill","id","className","id_str","concat","class_str","toJSON","assign","a1","a2","slope","atan2","PI","v","scalar","normalize","rpoint","rotate90CCW","rotate90CW","invert","subtract","angleTo","norm1","norm2","n","points2norm","standard","A","B","C","parallelTo","other_line","incidentTo","intersect","intersectLine2Line","intersectLine2Circle","intersectLine2Arc","intersectLine2Polygon","distance","shortest_segment","reverse","circle2line","segment2line","arc2line","shape2polygon","ip","intersectLine2Box","ps","pe","find","undefined","segment","pt1","pt2","unit","line1","line2","A1","B1","C1","A2","B2","C2","det","detX","detY","new_ip","push","circle","prj","pc","delta","v_trans","pts","xmin","ymin","xmax","ymax","segs","ips","seg","ips_tmp","arc","ip_tmp","toArc","counterclockwise","intersectCirle2Circle","intersectShape2Polygon","circle2circle","segment2circle","arc2circle","circle1","circle2","not_intersect","r1","r2","abs","mid_pt","h","fillOpacity","coords","start","end","min","max","distanceToPoint","intersectSegment2Line","intersectSegment2Segment","intersectSegment2Circle","intersectSegment2Arc","segment2segment","segment2arc","tangentInStart","tangentInEnd","split","middle","rest","definiteIntegral","dy1","dy2","isZeroLength","seg1","seg2","startAngle","endAngle","counterClockwise","CCW","sweep","PIx2","p0","func_arcs","breakToFunctional","merge","test_arc","chordHeight","intersectArc2Circle","intersectArc2Arc","arc2arc","func_arcs_array","angles","test_arcs","i","sort","arc1","arc2","prev_arc","new_arc","tangent","newStart","newEnd","newCenter","arcSE","f_arcs","area","circularSegmentDefiniteIntegral","onLeftSide","areaTrapez","areaCircularSegment","circularSegmentArea","largeArcFlag","sweepFlag","low","high","other_box","less_than","equal_to","output","maximal_val","box1","box2","val_less_than","set","width","height","Edge","next","prev","face","arc_length","bvStart","bvEnd","bv","overlap","isSegment","isArc","setInclusion","polygon","ray_shoot","OUTSIDE","INSIDE","bvMiddle","setOverlap","edge","flag","shape1","shape2","OVERLAP_SAME","OVERLAP_OPPOSITE","sign","halfArc1","halfArc2","Face","first","last","_box","_orientation","shapes","every","segments","points2segments","shapes2face","edges","flattenShapes","flattenShape","setArcLength","Symbol","iterator","value","done","face_edges","counter","points","append","isEmpty","newEdge","edgeBefore","edgeAfter","edge_tmp","orientation","signedArea","sArea","ORIENTATION","NOT_ORIENTABLE","CW","isSimple","getSelfIntersections","exitOnFirst","int_points","edge1","edge2","map","svgStr","Ray","Number","POSITIVE_INFINITY","intersectRay2Segment","intersectRay2Arc","ray","resp_edges","intersections","BOUNDARY","i1","i2","intersection","prev_edge","prev_tangent","prev_point","cur_tangent","cur_point","prev_on_the_left","cur_on_the_left","next_edge","next_tangent","next_point","next_on_the_left","faces","addFace","deleteFace","removeChain","edgeFrom","edgeTo","addVertex","rel","min_dist_and_segment","min_stop","intersectPolygon2Polygon","isValid","valid","newPolygon","polygon1","polygon2","fillRule","point2point","closest_point","dist2center","shortest_dist","v_seg","v_ps2pt","v_pe2pt","start_sp","end_sp","v_unit","dist_and_segment","dist_from_start","shortest_segment_from_start","dist_from_end","shortest_segment_from_end","dist_from_center","shortest_segment_from_center","dist_from_projection","shortest_segment_from_projection","dist_tmp","segment_tmp","ip1","ip2","polygon2polygon","box2box_minmax","mindist_x","mindist_y","mindist","maxdist","minmax_tree_process_level","level","tree","item","key","new_level_left","left","isNil","new_level_right","right","new_level","minmax_tree","root","squared_min_stop","minmax_tree_calc_distance","min_dist_and_segment_new","stop","d1","d2","CONTAINS","INTERLACE","f","_flattenJs","_interopRequireDefault","obj","__esModule","default","unify","BooleanOperations","getNumLayers","path0","path1","layers0","layers1","forEach","p","union","radius","path","_loop","layer","points0","points1","polygon0","combinedPolygon","filletedPolygon","fillet","combinedLayerPoints","vertex","console","log","OVERLAY_ID","OldModule","bundle","Module","moduleName","call","hot","data","hotData","_acceptCallbacks","_disposeCallbacks","accept","fn","dispose","checkedAssets","assetsToAccept","parent","isParcelRequire","WebSocket","hostname","location","protocol","ws","onmessage","event","JSON","parse","type","handled","assets","asset","isNew","didAccept","hmrAcceptCheck","global","parcelRequire","generated","js","hmrApply","hmrAcceptRun","reload","close","onclose","removeErrorOverlay","error","message","stack","overlay","createErrorOverlay","document","body","appendChild","getElementById","createElement","stackTrace","innerText","innerHTML","getParents","modules","parents","k","dep","isArray","Function","deps","cached","cache","some","cb"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAMA,MAAM,GAAG,QAAQ;AACvB,MAAMC,QAAQ,GAAG,CAAC;AAElBC,MAAM,CAACC,OAAO,GAAG;EACbH,MAAM,EAAEA,MAAM;EACd;AACJ;AACA;AACA;EACII,IAAI,EAAE,SAAAA,CAASC,CAAC,EAAE;IACd,OAAUA,CAAC,GAAIL,MAAM,IAAKK,CAAC,GAAI,CAACL,MAAM;EAC1C,CAAC;EACD;AACJ;AACA;AACA;EACIM,EAAE,EAAE,SAAAA,CAASD,CAAC,EAACE,CAAC,EAAE;IACd,OAAUF,CAAC,GAAGE,CAAE,GAAIP,MAAM,IAAKK,CAAC,GAAGE,CAAE,GAAG,CAACP,MAAM;EACnD,CAAC;EACD;AACJ;AACA;AACA;EACIQ,EAAE,EAAEA,CAACH,CAAC,EAACE,CAAC,KAAK;IACT,OAAUF,CAAC,GAAGE,CAAE,GAAIP,MAAM;EAC9B,CAAC;EACD;AACJ;AACA;AACA;EACIS,EAAE,EAAEA,CAACJ,CAAC,EAACE,CAAC,KAAK;IACT,OAAUF,CAAC,GAAGE,CAAE,GAAG,CAACP,MAAM;EAC9B,CAAC;EACD;AACJ;AACA;AACA;EACIU,EAAE,EAAEA,CAACL,CAAC,EAACE,CAAC,KAAK;IACT,OAAUF,CAAC,GAAGE,CAAE,GAAG,CAACP,MAAM;EAC9B,CAAC;EACD;AACJ;AACA;AACA;EACIW,EAAE,EAAEA,CAACN,CAAC,EAACE,CAAC,KAAK;IACT,OAAUF,CAAC,GAAGE,CAAE,GAAIP,MAAM;EAC9B;AACJ,CAAC;;ACxDD;AACA;AACA;AACAE,MAAM,CAACC,OAAO,GAAG;EACbS,kBAAkB,EAAE,IAAIC,cAAc,CAAC,oBAAoB,CAAC;EAC5DC,aAAa,EAAE,IAAIC,KAAK,CAAC,eAAe;AAC5C,CAAC;;ACND,YAAY;;AAEZb,MAAM,CAACC,OAAO,GAAG,UAASa,OAAO,EAAE;EAC/B;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIA,OAAO,CAACC,MAAM,GAAG,MAAMA,MAAM,CAAC;IAC1B;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACQC,WAAWA,CAACC,CAAC,GAAC,CAAC,EAACC,CAAC,GAAC,CAAC,EAACC,CAAC,GAAC,CAAC,EAACC,CAAC,GAAC,CAAC,EAACC,EAAE,GAAC,CAAC,EAACC,EAAE,GAAC,CAAC,EAAE;MACnC,IAAI,CAACL,CAAC,GAAGA,CAAC;MACV,IAAI,CAACC,CAAC,GAAGA,CAAC;MACV,IAAI,CAACC,CAAC,GAAGA,CAAC;MACV,IAAI,CAACC,CAAC,GAAGA,CAAC;MACV,IAAI,CAACC,EAAE,GAAGA,EAAE;MACZ,IAAI,CAACC,EAAE,GAAGA,EAAE;IAChB;;IAEA;AACR;AACA;AACA;IACQC,KAAKA,CAAA,EAAG;MACJ,OAAO,IAAIR,MAAM,CAAC,IAAI,CAACE,CAAC,EAAE,IAAI,CAACC,CAAC,EAAE,IAAI,CAACC,CAAC,EAAE,IAAI,CAACC,CAAC,EAAE,IAAI,CAACC,EAAE,EAAE,IAAI,CAACC,EAAE,CAAC;IACvE;IAEA;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACQE,SAASA,CAACC,MAAM,EAAE;MACd,OAAO,CACHA,MAAM,CAAC,CAAC,CAAC,GAAC,IAAI,CAACR,CAAC,GAACQ,MAAM,CAAC,CAAC,CAAC,GAAC,IAAI,CAACN,CAAC,GAAC,IAAI,CAACE,EAAE,EACzCI,MAAM,CAAC,CAAC,CAAC,GAAC,IAAI,CAACP,CAAC,GAACO,MAAM,CAAC,CAAC,CAAC,GAAC,IAAI,CAACL,CAAC,GAAC,IAAI,CAACE,EAAE,CAC5C;IACL;IAEA;AACR;AACA;AACA;AACA;IACQI,QAAQA,CAACC,YAAY,EAAE;MACnB,OAAO,IAAIZ,MAAM,CACb,IAAI,CAACE,CAAC,GAACU,YAAY,CAACV,CAAC,GAAG,IAAI,CAACE,CAAC,GAACQ,YAAY,CAACT,CAAC,EAC7C,IAAI,CAACA,CAAC,GAACS,YAAY,CAACV,CAAC,GAAG,IAAI,CAACG,CAAC,GAACO,YAAY,CAACT,CAAC,EAC7C,IAAI,CAACD,CAAC,GAACU,YAAY,CAACR,CAAC,GAAG,IAAI,CAACA,CAAC,GAACQ,YAAY,CAACP,CAAC,EAC7C,IAAI,CAACF,CAAC,GAACS,YAAY,CAACR,CAAC,GAAG,IAAI,CAACC,CAAC,GAACO,YAAY,CAACP,CAAC,EAC7C,IAAI,CAACH,CAAC,GAACU,YAAY,CAACN,EAAE,GAAG,IAAI,CAACF,CAAC,GAACQ,YAAY,CAACL,EAAE,GAAG,IAAI,CAACD,EAAE,EACzD,IAAI,CAACH,CAAC,GAACS,YAAY,CAACN,EAAE,GAAG,IAAI,CAACD,CAAC,GAACO,YAAY,CAACL,EAAE,GAAG,IAAI,CAACA,EAC3D,CAAC;IACL;IAEA;AACR;AACA;AACA;AACA;AACA;AACA;IACQM,SAASA,CAAC,GAAGC,IAAI,EAAE;MACf,IAAIR,EAAE,EAAEC,EAAE;MACV,IAAIO,IAAI,CAACC,MAAM,IAAI,CAAC,IAAKD,IAAI,CAAC,CAAC,CAAC,YAAYf,OAAO,CAACiB,MAAO,EAAE;QACzDV,EAAE,GAAGQ,IAAI,CAAC,CAAC,CAAC,CAAC1B,CAAC;QACdmB,EAAE,GAAGO,IAAI,CAAC,CAAC,CAAC,CAACxB,CAAC;MAClB,CAAC,MACI,IAAIwB,IAAI,CAACC,MAAM,IAAI,CAAC,IAAI,OAAOD,IAAI,CAAC,CAAC,CAAE,IAAI,QAAQ,IAAI,OAAOA,IAAI,CAAC,CAAC,CAAE,IAAI,QAAQ,EAAE;QACrFR,EAAE,GAAGQ,IAAI,CAAC,CAAC,CAAC;QACZP,EAAE,GAAGO,IAAI,CAAC,CAAC,CAAC;MAChB,CAAC,MACI;QACD,MAAMf,OAAO,CAACkB,MAAM,CAACtB,kBAAkB;MAC3C;MACA,OAAO,IAAI,CAACgB,QAAQ,CAAC,IAAIX,MAAM,CAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAACM,EAAE,EAACC,EAAE,CAAC,CAAC;IACnD;IAEA;AACR;AACA;AACA;AACA;AACA;AACA;IACQW,MAAMA,CAACC,KAAK,EAAE;MACV,IAAIC,GAAG,GAAGC,IAAI,CAACD,GAAG,CAACD,KAAK,CAAC;MACzB,IAAIG,GAAG,GAAGD,IAAI,CAACC,GAAG,CAACH,KAAK,CAAC;MACzB,OAAO,IAAI,CAACR,QAAQ,CAAC,IAAIX,MAAM,CAACoB,GAAG,EAACE,GAAG,EAAC,CAACA,GAAG,EAACF,GAAG,EAAC,CAAC,EAAC,CAAC,CAAC,CAAC;IAC1D;IAEA;AACR;AACA;AACA;AACA;AACA;AACA;IACQG,KAAKA,CAACC,EAAE,EAAEC,EAAE,EAAE;MACV,OAAO,IAAI,CAACd,QAAQ,CAAC,IAAIX,MAAM,CAACwB,EAAE,EAAC,CAAC,EAAC,CAAC,EAACC,EAAE,EAAC,CAAC,EAAC,CAAC,CAAC,CAAC;IACnD;IAEA;AACR;AACA;AACA;AACA;IACQC,OAAOA,CAACC,MAAM,EAAE;MACZ,IAAI,CAAC5B,OAAO,CAAC6B,KAAK,CAACvC,EAAE,CAAC,IAAI,CAACiB,EAAE,EAAEqB,MAAM,CAACrB,EAAE,CAAC,EAAE,OAAO,KAAK;MACvD,IAAI,CAACP,OAAO,CAAC6B,KAAK,CAACvC,EAAE,CAAC,IAAI,CAACkB,EAAE,EAAEoB,MAAM,CAACpB,EAAE,CAAC,EAAE,OAAO,KAAK;MACvD,IAAI,CAACR,OAAO,CAAC6B,KAAK,CAACvC,EAAE,CAAC,IAAI,CAACa,CAAC,EAAEyB,MAAM,CAACzB,CAAC,CAAC,EAAE,OAAO,KAAK;MACrD,IAAI,CAACH,OAAO,CAAC6B,KAAK,CAACvC,EAAE,CAAC,IAAI,CAACc,CAAC,EAAEwB,MAAM,CAACxB,CAAC,CAAC,EAAE,OAAO,KAAK;MACrD,IAAI,CAACJ,OAAO,CAAC6B,KAAK,CAACvC,EAAE,CAAC,IAAI,CAACe,CAAC,EAAEuB,MAAM,CAACvB,CAAC,CAAC,EAAE,OAAO,KAAK;MACrD,IAAI,CAACL,OAAO,CAAC6B,KAAK,CAACvC,EAAE,CAAC,IAAI,CAACgB,CAAC,EAAEsB,MAAM,CAACtB,CAAC,CAAC,EAAE,OAAO,KAAK;MACrD,OAAO,IAAI;IACf;EACJ,CAAC;;EAED;AACJ;AACA;AACA;EACIN,OAAO,CAAC4B,MAAM,GAAG,CAAC,GAAGb,IAAI,KAAK,IAAIf,OAAO,CAACC,MAAM,CAAC,GAAGc,IAAI,CAAC;AAC7D,CAAC;;AC/ID;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA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","file":"Boolean-Union.72ca2d64.js","sourceRoot":"..","sourcesContent":["/**\r\n * Created by Alex Bol on 2/18/2017.\r\n */\r\n\r\n/**\r\n * Global constant DP_TOL is used for comparison of floating point numbers.\r\n * It is set to 0.000001.\r\n * @type {number}\r\n */\r\nconst DP_TOL = 0.000001;\r\nconst DECIMALS = 3;\r\n\r\nmodule.exports = {\r\n    DP_TOL: DP_TOL,\r\n    /**\r\n     * Returns *true* if value comparable to zero\r\n     * @return {boolean}\r\n     */\r\n    EQ_0: function(x) {\r\n        return ( (x) < DP_TOL && (x) > -DP_TOL );\r\n    },\r\n    /**\r\n     * Returns *true* if two values are equal up to DP_TOL\r\n     * @return {boolean}\r\n     */\r\n    EQ: function(x,y) {\r\n        return ( (x)-(y) <  DP_TOL && (x)-(y) > -DP_TOL );\r\n    },\r\n    /**\r\n     * Returns *true* if first argument greater than second argument up to DP_TOL\r\n     * @return {boolean}\r\n     */\r\n    GT: (x,y) => {\r\n        return ( (x)-(y) >  DP_TOL );\r\n    },\r\n    /**\r\n     * Returns *true* if first argument greater than or equal to second argument up to DP_TOL\r\n     * @return {boolean}\r\n     */\r\n    GE: (x,y) => {\r\n        return ( (x)-(y) > -DP_TOL );\r\n    },\r\n    /**\r\n     * Returns *true* if first argument less than second argument up to DP_TOL\r\n     * @return {boolean}\r\n     */\r\n    LT: (x,y) => {\r\n        return ( (x)-(y) < -DP_TOL )\r\n    },\r\n    /**\r\n     * Returns *true* if first argument less than or equal to second argument up to DP_TOL\r\n     * @return {boolean}\r\n     */\r\n    LE: (x,y) => {\r\n        return ( (x)-(y) <  DP_TOL );\r\n    }\r\n};\r\n","/**\r\n * Created by Alex Bol on 2/19/2017.\r\n */\r\nmodule.exports = {\r\n    ILLEGAL_PARAMETERS: new ReferenceError('Illegal Parameters'),\r\n    ZERO_DIVISION: new Error('Zero division')\r\n};\r\n\r\n","\"use strict\";\r\n\r\nmodule.exports = function(Flatten) {\r\n    /**\r\n     * Class representing an affine transformation 3x3 matrix:\r\n     * <pre>\r\n     *      [ a  c  tx\r\n     * A =    b  d  ty\r\n     *        0  0  1  ]\r\n     * </pre\r\n     * @type {Matrix}\r\n     */\r\n    Flatten.Matrix = class Matrix {\r\n        /**\r\n         * Construct new instance of affine transformation matrix <br/>\r\n         * If parameters omitted, construct identity matrix a = 1, d = 1\r\n         * @param {number} a - position(0,0)   sx*cos(alpha)\r\n         * @param {number} b - position (0,1)  sx*sin(alpha)\r\n         * @param {number} c - position (1,0)  -sy*sin(alpha)\r\n         * @param {number} d - position (1,1)  sy*cos(alpha)\r\n         * @param {number} tx - position (2,0) translation by x\r\n         * @param {number} ty - position (2,1) translation by y\r\n         */\r\n        constructor(a=1,b=0,c=0,d=1,tx=0,ty=0) {\r\n            this.a = a;\r\n            this.b = b;\r\n            this.c = c;\r\n            this.d = d;\r\n            this.tx = tx;\r\n            this.ty = ty;\r\n        }\r\n\r\n        /**\r\n         * Returns a clone of the Matrix instance.\r\n         * @return {Matrix}\r\n         **/\r\n        clone() {\r\n            return new Matrix(this.a, this.b, this.c, this.d, this.tx, this.ty);\r\n        };\r\n\r\n        /**\r\n         * Transform vector [x,y] using transformation matrix. <br/>\r\n         * Vector [x,y] is an abstract array[2] of numbers and not a FlattenJS object <br/>\r\n         * The result is also an abstract vector [x',y'] = A * [x,y]:\r\n         * <code>\r\n         * [x'       [ ax + by + tx\r\n         *  y'   =     cx + dy + ty\r\n         *  1]                    1 ]\r\n         * </code>\r\n         * @param {number[]} vector - array[2] of numbers\r\n         * @returns {number[]} transformation result - array[2] of numbers\r\n         */\r\n        transform(vector) {\r\n            return [\r\n                vector[0]*this.a+vector[1]*this.c+this.tx,\r\n                vector[0]*this.b+vector[1]*this.d+this.ty\r\n            ]\r\n        };\r\n\r\n        /**\r\n         * Returns result of multiplication of this matrix by other matrix\r\n         * @param {Matrix} other_matrix - matrix to multiply by\r\n         * @returns {Matrix}\r\n         */\r\n        multiply(other_matrix) {\r\n            return new Matrix(\r\n                this.a*other_matrix.a + this.c*other_matrix.b,\r\n                this.b*other_matrix.a + this.d*other_matrix.b,\r\n                this.a*other_matrix.c + this.c*other_matrix.d,\r\n                this.b*other_matrix.c + this.d*other_matrix.d,\r\n                this.a*other_matrix.tx + this.c*other_matrix.ty + this.tx,\r\n                this.b*other_matrix.tx + this.d*other_matrix.ty + this.ty\r\n            )\r\n        };\r\n\r\n        /**\r\n         * Return new matrix as a result of multiplication of the current matrix\r\n         * by the matrix(1,0,0,1,tx,ty)\r\n         * @param {number} tx - translation by x\r\n         * @param {number} ty - translation by y\r\n         * @returns {Matrix}\r\n         */\r\n        translate(...args) {\r\n            let tx, ty;\r\n            if (args.length == 1 && (args[0] instanceof Flatten.Vector)) {\r\n                tx = args[0].x;\r\n                ty = args[0].y;\r\n            }\r\n            else if (args.length == 2 && typeof(args[0]) == \"number\" && typeof(args[1]) == \"number\") {\r\n                tx = args[0];\r\n                ty = args[1];\r\n            }\r\n            else {\r\n                throw Flatten.Errors.ILLEGAL_PARAMETERS;\r\n            }\r\n            return this.multiply(new Matrix(1,0,0,1,tx,ty))\r\n        };\r\n\r\n        /**\r\n         * Return new matrix as a result of multiplication of the current matrix\r\n         * by the matrix that defines rotation by given angle (in radians) around\r\n         * point (0,0) in counter clockwise direction\r\n         * @param angle\r\n         * @returns {Matrix}\r\n         */\r\n        rotate(angle) {\r\n            let cos = Math.cos(angle);\r\n            let sin = Math.sin(angle);\r\n            return this.multiply(new Matrix(cos,sin,-sin,cos,0,0));\r\n        };\r\n\r\n        /**\r\n         * Return new matrix as a result of multiplication of the current matrix\r\n         * by the matrix (sx,0,0,sy,0,0) that defines scaling\r\n         * @param sx\r\n         * @param sy\r\n         * @returns {Matrix}\r\n         */\r\n        scale(sx, sy) {\r\n            return this.multiply(new Matrix(sx,0,0,sy,0,0));\r\n        };\r\n\r\n        /**\r\n         * Returns true if two matrix are equal parameter by parameter\r\n         * @param {Matrix} matrix - other matrix\r\n         * @returns {boolean} true if equal, false otherwise\r\n         */\r\n        equalTo(matrix) {\r\n            if (!Flatten.Utils.EQ(this.tx, matrix.tx)) return false;\r\n            if (!Flatten.Utils.EQ(this.ty, matrix.ty)) return false;\r\n            if (!Flatten.Utils.EQ(this.a, matrix.a)) return false;\r\n            if (!Flatten.Utils.EQ(this.b, matrix.b)) return false;\r\n            if (!Flatten.Utils.EQ(this.c, matrix.c)) return false;\r\n            if (!Flatten.Utils.EQ(this.d, matrix.d)) return false;\r\n            return true;\r\n        };\r\n    };\r\n\r\n    /**\r\n     * Function to create matrix equivalent to \"new\" constructor\r\n     * @param args\r\n     */\r\n    Flatten.matrix = (...args) => new Flatten.Matrix(...args);\r\n};\r\n","/**\r\n * Created by Alex Bol on 4/1/2017.\r\n */\r\n\r\nlet Interval = class Interval {\r\n    constructor(low, high) {\r\n        this.low = low;\r\n        this.high = high;\r\n    }\r\n\r\n    get max() {\r\n        return this.high;\r\n    }\r\n\r\n    interval(low, high) {\r\n        return new Interval(low, high);\r\n    }\r\n\r\n    clone() {\r\n        return new Interval(this.low, this.high);\r\n    }\r\n\r\n    less_than(other_interval) {\r\n        return this.low < other_interval.low ||\r\n            this.low == other_interval.low && this.high < other_interval.high;\r\n    }\r\n\r\n    equal_to(other_interval) {\r\n        return this.low == other_interval.low && this.high == other_interval.high;\r\n    }\r\n\r\n    intersect(other_interval) {\r\n        return !this.not_intersect(other_interval);\r\n    }\r\n\r\n    not_intersect(other_interval) {\r\n        return (this.high < other_interval.low || other_interval.high < this.low);\r\n    }\r\n\r\n    output() {\r\n        return [this.low, this.high];\r\n    }\r\n\r\n    maximal_val(val1, val2) {\r\n        return Math.max(val1, val2);\r\n    }\r\n\r\n    val_less_than(val1, val2 ) {     // trait to compare max property with item ?\r\n        return val1 < val2;\r\n    }\r\n};\r\n\r\nmodule.exports = Interval;\r\n","/**\r\n * Created by Alex Bol on 3/28/2017.\r\n */\r\n\r\n'use strict';\r\n\r\nmodule.exports = {\r\n    RB_TREE_COLOR_RED: 0,\r\n    RB_TREE_COLOR_BLACK: 1\r\n};","/**\r\n * Created by Alex Bol on 4/1/2017.\r\n */\r\n\r\n'use strict';\r\n\r\n// let defaultTraits = require('../utils/numeric_traits');\r\nlet Interval = require('../classes/interval');\r\nlet {RB_TREE_COLOR_RED, RB_TREE_COLOR_BLACK} = require('../utils/constants');\r\n\r\nlet Node = class Node {\r\n    constructor(key = undefined, value = undefined,\r\n                left = null, right = null, parent = null, color = RB_TREE_COLOR_BLACK) {\r\n        this.left = left;                     // reference to left child node\r\n        this.right = right;                   // reference to right child node\r\n        this.parent = parent;                 // reference to parent node\r\n        this.color = color;\r\n\r\n        this.item = {key: key, value: value};   // key is supposed to be       instance of Interval\r\n\r\n        /* If not, this should by an array of two numbers */\r\n        if (key && key instanceof Array && key.length == 2) {\r\n            if (!Number.isNaN(key[0]) && !Number.isNaN(key[1])) {\r\n                this.item.key = new Interval(Math.min(key[0], key[1]), Math.max(key[0], key[1]));\r\n            }\r\n        }\r\n        this.max = this.item.key ? this.item.key.max : undefined;\r\n    }\r\n\r\n    isNil() {\r\n        return (this.item.key === undefined && this.item.value === undefined &&\r\n            this.left === null && this.right === null && this.color === RB_TREE_COLOR_BLACK);\r\n    }\r\n\r\n    less_than(other_node) {\r\n        return this.item.key.less_than(other_node.item.key);\r\n    }\r\n\r\n    equal_to(other_node) {\r\n        let value_equal = true;\r\n        if (this.item.value && other_node.item.value) {\r\n            value_equal = this.item.value.equal_to ? this.item.value.equal_to(other_node.item.value) :\r\n                this.item.value == other_node.item.value;\r\n        }\r\n        return this.item.key.equal_to(other_node.item.key) && value_equal;\r\n    }\r\n\r\n    intersect(other_node) {\r\n        return this.item.key.intersect(other_node.item.key);\r\n    }\r\n\r\n    copy_data(other_node) {\r\n        this.item.key = other_node.item.key.clone();\r\n        this.item.value = other_node.item.value;\r\n    }\r\n\r\n    update_max() {\r\n        // use key (Interval) max property instead of key.high\r\n        this.max = this.item.key ? this.item.key.max : undefined;\r\n        if (this.right && this.right.max) {\r\n            let maximal_val = this.item.key.maximal_val;\r\n            this.max = maximal_val(this.max, this.right.max);\r\n        }\r\n        if (this.left && this.left.max) {\r\n            let maximal_val = this.item.key.maximal_val;\r\n            this.max = maximal_val(this.max, this.left.max);\r\n        }\r\n    }\r\n\r\n    // Other_node does not intersect any node of left subtree, if this.left.max < other_node.item.key.low\r\n    not_intersect_left_subtree(search_node) {\r\n        let val_less_than = this.item.key.val_less_than;\r\n        let high = this.left.max.high ? this.left.max.high : this.left.max;\r\n        return val_less_than(high, search_node.item.key.low);\r\n    }\r\n\r\n    // Other_node does not intersect right subtree if other_node.item.key.high < this.right.key.low\r\n    not_intersect_right_subtree(search_node) {\r\n        let val_less_than = this.item.key.val_less_than;\r\n        let low = this.right.max.low ? this.right.max.low : this.right.item.key.low;\r\n        return val_less_than(search_node.item.key.high, low);\r\n    }\r\n};\r\n\r\nmodule.exports = Node;\r\n\r\n","/**\r\n * Created by Alex Bol on 3/31/2017.\r\n */\r\n'use strict';\r\n\r\nlet Node = require('./classes/node');\r\nlet {RB_TREE_COLOR_RED, RB_TREE_COLOR_BLACK} = require('./utils/constants');\r\n\r\nlet nil_node = new Node();\r\n\r\n/**\r\n * Implementation of interval binary search tree <br/>\r\n * Interval tree may store items which are couples of {key:interval, value: value} <br/>\r\n * Interval is an object with high and low properties or simply array of numeric [low,high] values <br />\r\n * If interval is an object, it should implement and expose methods less_than, equals_to, intersect and others,\r\n * see documentation {link}\r\n * @type {IntervalTree}\r\n */\r\nlet IntervalTree = class IntervalTree {\r\n    /**\r\n     * Construct new empty instance of IntervalTree\r\n     */\r\n    constructor() {\r\n        this.root = null;\r\n    }\r\n\r\n    /**\r\n     * Returns number of items stored in the interval tree\r\n     * @returns {number}\r\n     */\r\n    get size() {\r\n        let count = 0;\r\n        this.tree_walk(this.root, () => count++);\r\n        return count;\r\n    }\r\n\r\n    /**\r\n     * Returns array of sorted keys in the ascending order\r\n     * @returns {Array}\r\n     */\r\n    get keys() {\r\n        let res = [];\r\n        this.tree_walk(this.root, (node) => res.push(node.item.key.output()));\r\n        return res;\r\n    }\r\n\r\n    /**\r\n     * Return array of values in the ascending keys order\r\n     * @returns {Array}\r\n     */\r\n    get values() {\r\n        let res = [];\r\n        this.tree_walk(this.root, (node) => res.push(node.item.value));\r\n        return res;\r\n    }\r\n\r\n    /**\r\n     * Returns array of items (<key,value> pairs) in the ascended keys order\r\n     * @returns {Array}\r\n     */\r\n    get items() {\r\n        let res = [];\r\n        this.tree_walk(this.root, (node) => res.push({key: node.item.key.output(), value: node.item.value}));\r\n        return res;\r\n    }\r\n\r\n    /**\r\n     * Returns true if tree is empty\r\n     * @returns {boolean}\r\n     */\r\n    get isEmpty() {\r\n        return (this.root == null || this.root == nil_node);\r\n    }\r\n\r\n    /**\r\n     * Insert new item into interval tree\r\n     * @param key - interval object or array of two numbers [low, high]\r\n     * @param value - value representing any object (optional)\r\n     * @returns {Node} - returns reference to inserted node as an object {key:interval, value: value}\r\n     */\r\n    insert(key, value = key) {\r\n        if (key === undefined) return;\r\n        let insert_node = new Node(key, value, nil_node, nil_node, null, RB_TREE_COLOR_RED);\r\n        this.tree_insert(insert_node);\r\n        this.recalc_max(insert_node);\r\n        return insert_node;\r\n    }\r\n\r\n    /**\r\n     * Returns true if item {key,value} exist in the tree\r\n     * @param key - interval correspondent to keys stored in the tree\r\n     * @param value - value object to be checked\r\n     * @returns {boolean} - true if item {key, value} exist in the tree, false otherwise\r\n     */\r\n    exist(key, value) {\r\n        let search_node = new Node(key, value);\r\n        return this.tree_search(this.root, search_node) ? true : false;\r\n    }\r\n\r\n    /**\r\n     * Remove entry {key, value} from the tree\r\n     * @param key - interval correspondent to keys stored in the tree\r\n     * @param value - - value object\r\n     * @returns {boolean} - true if item {key, value} deleted, false if not found\r\n     */\r\n    remove(key, value) {\r\n        let search_node = new Node(key, value);\r\n        let delete_node = this.tree_search(this.root, search_node);\r\n        if (delete_node) {\r\n            this.tree_delete(delete_node);\r\n        }\r\n        return delete_node;\r\n    }\r\n\r\n    /**\r\n     * Returns array of entry values which keys intersect with given interval <br/>\r\n     * If no values stored in the tree, returns array of keys which intersect given interval\r\n     * @param interval - search interval, or array [low, high]\r\n     * @returns {Array}\r\n     */\r\n    search(interval) {\r\n        let search_node = new Node(interval);\r\n        let resp_nodes = [];\r\n        this.tree_search_interval(this.root, search_node, resp_nodes);\r\n        let resp = [];\r\n        resp_nodes.forEach((node) => {\r\n            if (node.item.value) {         // if there are values, return only values\r\n                resp.push(node.item.value);\r\n            }\r\n            else {                         // otherwise, return keys\r\n                resp.push(node.item.key.output());\r\n            }\r\n        }, []);\r\n        return resp;\r\n    }\r\n\r\n    /**\r\n     * Tree visitor. For each node implement a callback function. <br/>\r\n     * Method calls a callback function with two parameters (key, value)\r\n     * @param visitor(key,value) - function to be called for each tree item\r\n     */\r\n    forEach(visitor) {\r\n        this.tree_walk(this.root, (node) => visitor(node.item.key, node.item.value));\r\n    }\r\n    \r\n    /** Value Mapper. Walk through every node and map node value to another value\r\n     * @param callback(value, key) - function to be called for each tree item\r\n     */\r\n    map(callback) {\r\n        const tree = new IntervalTree();\r\n        this.tree_walk(this.root, (node) => tree.insert(node.item.key, callback(node.item.value, node.item.key)));\r\n        return tree;\r\n    }\r\n\r\n    recalc_max(node) {\r\n        let node_current = node;\r\n        while (node_current.parent != null) {\r\n            node_current.parent.update_max();\r\n            node_current = node_current.parent;\r\n        }\r\n    }\r\n\r\n    tree_insert(insert_node) {\r\n        let current_node = this.root;\r\n        let parent_node = null;\r\n\r\n        if (this.root == null || this.root == nil_node) {\r\n            this.root = insert_node;\r\n        }\r\n        else {\r\n            while (current_node != nil_node) {\r\n                parent_node = current_node;\r\n                if (insert_node.less_than(current_node)) {\r\n                    current_node = current_node.left;\r\n                }\r\n                else {\r\n                    current_node = current_node.right;\r\n                }\r\n            }\r\n\r\n            insert_node.parent = parent_node;\r\n\r\n            if (insert_node.less_than(parent_node)) {\r\n                parent_node.left = insert_node;\r\n            }\r\n            else {\r\n                parent_node.right = insert_node;\r\n            }\r\n        }\r\n\r\n        this.insert_fixup(insert_node);\r\n    }\r\n\r\n// After insertion insert_node may have red-colored parent, and this is a single possible violation\r\n// Go upwords to the root and re-color until violation will be resolved\r\n    insert_fixup(insert_node) {\r\n        let current_node;\r\n        let uncle_node;\r\n\r\n        current_node = insert_node;\r\n        while (current_node != this.root && current_node.parent.color == RB_TREE_COLOR_RED) {\r\n            if (current_node.parent == current_node.parent.parent.left) {   // parent is left child of grandfather\r\n                uncle_node = current_node.parent.parent.right;              // right brother of parent\r\n                if (uncle_node.color == RB_TREE_COLOR_RED) {             // Case 1. Uncle is red\r\n                    // re-color father and uncle into black\r\n                    current_node.parent.color = RB_TREE_COLOR_BLACK;\r\n                    uncle_node.color = RB_TREE_COLOR_BLACK;\r\n                    current_node.parent.parent.color = RB_TREE_COLOR_RED;\r\n                    current_node = current_node.parent.parent;\r\n                }\r\n                else {                                                    // Case 2 & 3. Uncle is black\r\n                    if (current_node == current_node.parent.right) {     // Case 2. Current if right child\r\n                        // This case is transformed into Case 3.\r\n                        current_node = current_node.parent;\r\n                        this.rotate_left(current_node);\r\n                    }\r\n                    current_node.parent.color = RB_TREE_COLOR_BLACK;    // Case 3. Current is left child.\r\n                    // Re-color father and grandfather, rotate grandfather right\r\n                    current_node.parent.parent.color = RB_TREE_COLOR_RED;\r\n                    this.rotate_right(current_node.parent.parent);\r\n                }\r\n            }\r\n            else {                                                         // parent is right child of grandfather\r\n                uncle_node = current_node.parent.parent.left;              // left brother of parent\r\n                if (uncle_node.color == RB_TREE_COLOR_RED) {             // Case 4. Uncle is red\r\n                    // re-color father and uncle into black\r\n                    current_node.parent.color = RB_TREE_COLOR_BLACK;\r\n                    uncle_node.color = RB_TREE_COLOR_BLACK;\r\n                    current_node.parent.parent.color = RB_TREE_COLOR_RED;\r\n                    current_node = current_node.parent.parent;\r\n                }\r\n                else {\r\n                    if (current_node == current_node.parent.left) {             // Case 5. Current is left child\r\n                        // Transform into case 6\r\n                        current_node = current_node.parent;\r\n                        this.rotate_right(current_node);\r\n                    }\r\n                    current_node.parent.color = RB_TREE_COLOR_BLACK;    // Case 6. Current is right child.\r\n                    // Re-color father and grandfather, rotate grandfather left\r\n                    current_node.parent.parent.color = RB_TREE_COLOR_RED;\r\n                    this.rotate_left(current_node.parent.parent);\r\n                }\r\n            }\r\n        }\r\n\r\n        this.root.color = RB_TREE_COLOR_BLACK;\r\n    }\r\n\r\n    tree_delete(delete_node) {\r\n        let cut_node;   // node to be cut - either delete_node or successor_node  (\"y\" from 14.4)\r\n        let fix_node;   // node to fix rb tree property   (\"x\" from 14.4)\r\n\r\n        if (delete_node.left == nil_node || delete_node.right == nil_node) {  // delete_node has less then 2 children\r\n            cut_node = delete_node;\r\n        }\r\n        else {                                                    // delete_node has 2 children\r\n            cut_node = this.tree_successor(delete_node);\r\n        }\r\n\r\n        // fix_node if single child of cut_node\r\n        if (cut_node.left != nil_node) {\r\n            fix_node = cut_node.left;\r\n        }\r\n        else {\r\n            fix_node = cut_node.right;\r\n        }\r\n\r\n        // remove cut_node from parent\r\n        /*if (fix_node != nil_node) {*/\r\n            fix_node.parent = cut_node.parent;\r\n        /*}*/\r\n\r\n        if (cut_node == this.root) {\r\n            this.root = fix_node;\r\n        }\r\n        else {\r\n            if (cut_node == cut_node.parent.left) {\r\n                cut_node.parent.left = fix_node;\r\n            }\r\n            else {\r\n                cut_node.parent.right = fix_node;\r\n            }\r\n            cut_node.parent.update_max();        // update max property of the parent\r\n        }\r\n\r\n        this.recalc_max(fix_node);              // update max property upward from fix_node to root\r\n\r\n        // COPY DATA !!!\r\n        // Delete_node becomes cut_node, it means that we cannot hold reference\r\n        // to node in outer structure and we will have to delete by key, additional search need\r\n        if (cut_node != delete_node) {\r\n            delete_node.copy_data(cut_node);\r\n            delete_node.update_max();           // update max property of the cut node at the new place\r\n            this.recalc_max(delete_node);       // update max property upward from delete_node to root\r\n        }\r\n\r\n        if (/*fix_node != nil_node && */cut_node.color == RB_TREE_COLOR_BLACK) {\r\n            this.delete_fixup(fix_node);\r\n        }\r\n    }\r\n\r\n    delete_fixup(fix_node) {\r\n        let current_node = fix_node;\r\n        let brother_node;\r\n\r\n        while (current_node != this.root && current_node.parent != null && current_node.color == RB_TREE_COLOR_BLACK) {\r\n            if (current_node == current_node.parent.left) {          // fix node is left child\r\n                brother_node = current_node.parent.right;\r\n                if (brother_node.color == RB_TREE_COLOR_RED) {   // Case 1. Brother is red\r\n                    brother_node.color = RB_TREE_COLOR_BLACK;         // re-color brother\r\n                    current_node.parent.color = RB_TREE_COLOR_RED;    // re-color father\r\n                    this.rotate_left(current_node.parent);\r\n                    brother_node = current_node.parent.right;                      // update brother\r\n                }\r\n                // Derive to cases 2..4: brother is black\r\n                if (brother_node.left.color == RB_TREE_COLOR_BLACK &&\r\n                    brother_node.right.color == RB_TREE_COLOR_BLACK) {  // case 2: both nephews black\r\n                    brother_node.color = RB_TREE_COLOR_RED;              // re-color brother\r\n                    current_node = current_node.parent;                  // continue iteration\r\n                }\r\n                else {\r\n                    if (brother_node.right.color == RB_TREE_COLOR_BLACK) {   // case 3: left nephew red, right nephew black\r\n                        brother_node.color = RB_TREE_COLOR_RED;          // re-color brother\r\n                        brother_node.left.color = RB_TREE_COLOR_BLACK;   // re-color nephew\r\n                        this.rotate_right(brother_node);\r\n                        brother_node = current_node.parent.right;                     // update brother\r\n                        // Derive to case 4: left nephew black, right nephew red\r\n                    }\r\n                    // case 4: left nephew black, right nephew red\r\n                    brother_node.color = current_node.parent.color;\r\n                    current_node.parent.color = RB_TREE_COLOR_BLACK;\r\n                    brother_node.right.color = RB_TREE_COLOR_BLACK;\r\n                    this.rotate_left(current_node.parent);\r\n                    current_node = this.root;                         // exit from loop\r\n                }\r\n            }\r\n            else {                                             // fix node is right child\r\n                brother_node = current_node.parent.left;\r\n                if (brother_node.color == RB_TREE_COLOR_RED) {   // Case 1. Brother is red\r\n                    brother_node.color = RB_TREE_COLOR_BLACK;         // re-color brother\r\n                    current_node.parent.color = RB_TREE_COLOR_RED;    // re-color father\r\n                    this.rotate_right(current_node.parent);\r\n                    brother_node = current_node.parent.left;                        // update brother\r\n                }\r\n                // Go to cases 2..4\r\n                if (brother_node.left.color == RB_TREE_COLOR_BLACK &&\r\n                    brother_node.right.color == RB_TREE_COLOR_BLACK) {   // case 2\r\n                    brother_node.color = RB_TREE_COLOR_RED;             // re-color brother\r\n                    current_node = current_node.parent;                              // continue iteration\r\n                }\r\n                else {\r\n                    if (brother_node.left.color == RB_TREE_COLOR_BLACK) {  // case 3: right nephew red, left nephew black\r\n                        brother_node.color = RB_TREE_COLOR_RED;            // re-color brother\r\n                        brother_node.right.color = RB_TREE_COLOR_BLACK;    // re-color nephew\r\n                        this.rotate_left(brother_node);\r\n                        brother_node = current_node.parent.left;                        // update brother\r\n                        // Derive to case 4: right nephew black, left nephew red\r\n                    }\r\n                    // case 4: right nephew black, left nephew red\r\n                    brother_node.color = current_node.parent.color;\r\n                    current_node.parent.color = RB_TREE_COLOR_BLACK;\r\n                    brother_node.left.color = RB_TREE_COLOR_BLACK;\r\n                    this.rotate_right(current_node.parent);\r\n                    current_node = this.root;                               // force exit from loop\r\n                }\r\n            }\r\n        }\r\n\r\n        current_node.color = RB_TREE_COLOR_BLACK;\r\n    }\r\n\r\n    tree_search(node, search_node) {\r\n        if (node == null || node == nil_node)\r\n            return undefined;\r\n\r\n        if (search_node.equal_to(node)) {\r\n            return node;\r\n        }\r\n        if (search_node.less_than(node)) {\r\n            return this.tree_search(node.left, search_node);\r\n        }\r\n        else {\r\n            return this.tree_search(node.right, search_node);\r\n        }\r\n    }\r\n\r\n    // Original search_interval method; container res support push() insertion\r\n    // Search all intervals intersecting given one\r\n    tree_search_interval(node, search_node, res) {\r\n        if (node != null && node != nil_node) {\r\n            // if (node->left != nil_node && node->left->max >= low) {\r\n            if (node.left != nil_node && !node.not_intersect_left_subtree(search_node)) {\r\n                this.tree_search_interval(node.left, search_node, res);\r\n            }\r\n            // if (low <= node->high && node->low <= high) {\r\n            if (node.intersect(search_node)) {\r\n                res.push(node);\r\n            }\r\n            // if (node->right != nil_node && node->low <= high) {\r\n            if (node.right != nil_node && !node.not_intersect_right_subtree(search_node)) {\r\n                this.tree_search_interval(node.right, search_node, res);\r\n            }\r\n        }\r\n    }\r\n\r\n    local_minimum(node) {\r\n        let node_min = node;\r\n        while (node_min.left != null && node_min.left != nil_node) {\r\n            node_min = node_min.left;\r\n        }\r\n        return node_min;\r\n    }\r\n\r\n    // not in use\r\n    local_maximum(node) {\r\n        let node_max = node;\r\n        while (node_max.right != null && node_max.right != nil_node) {\r\n            node_max = node_max.right;\r\n        }\r\n        return node_max;\r\n    }\r\n\r\n    tree_successor(node) {\r\n        let node_successor;\r\n        let current_node;\r\n        let parent_node;\r\n\r\n        if (node.right != nil_node) {\r\n            node_successor = this.local_minimum(node.right);\r\n        }\r\n        else {\r\n            current_node = node;\r\n            parent_node = node.parent;\r\n            while (parent_node != null && parent_node.right == current_node) {\r\n                current_node = parent_node;\r\n                parent_node = parent_node.parent;\r\n            }\r\n            node_successor = parent_node;\r\n        }\r\n        return node_successor;\r\n    }\r\n\r\n    //           |            right-rotate(T,y)       |\r\n    //           y            ---------------.       x\r\n    //          / \\                                  / \\\r\n    //         x   c          left-rotate(T,x)      a   y\r\n    //        / \\             <---------------         / \\\r\n    //       a   b                                    b   c\r\n\r\n    rotate_left(x) {\r\n        let y = x.right;\r\n\r\n        x.right = y.left;           // b goes to x.right\r\n\r\n        if (y.left != nil_node) {\r\n            y.left.parent = x;     // x becomes parent of b\r\n        }\r\n        y.parent = x.parent;       // move parent\r\n\r\n        if (x == this.root) {\r\n            this.root = y;           // y becomes root\r\n        }\r\n        else {                        // y becomes child of x.parent\r\n            if (x == x.parent.left) {\r\n                x.parent.left = y;\r\n            }\r\n            else {\r\n                x.parent.right = y;\r\n            }\r\n        }\r\n        y.left = x;                 // x becomes left child of y\r\n        x.parent = y;               // and y becomes parent of x\r\n\r\n        if (x != null && x != nil_node) {\r\n            x.update_max();\r\n        }\r\n\r\n        y = x.parent;\r\n        if (y != null && y != nil_node) {\r\n            y.update_max();\r\n        }\r\n    }\r\n\r\n    rotate_right(y) {\r\n        let x = y.left;\r\n\r\n        y.left = x.right;           // b goes to y.left\r\n\r\n        if (x.right != nil_node) {\r\n            x.right.parent = y;        // y becomes parent of b\r\n        }\r\n        x.parent = y.parent;          // move parent\r\n\r\n        if (y == this.root) {        // x becomes root\r\n            this.root = x;\r\n        }\r\n        else {                        // y becomes child of x.parent\r\n            if (y == y.parent.left) {\r\n                y.parent.left = x;\r\n            }\r\n            else {\r\n                y.parent.right = x;\r\n            }\r\n        }\r\n        x.right = y;                 // y becomes right child of x\r\n        y.parent = x;               // and x becomes parent of y\r\n\r\n        if (y != null && y != nil_node) {\r\n            y.update_max();\r\n        }\r\n\r\n        x = y.parent;\r\n        if (x != null && x != nil_node) {\r\n            x.update_max();\r\n        }\r\n    }\r\n\r\n    tree_walk(node, action) {\r\n        if (node != null && node != nil_node) {\r\n            this.tree_walk(node.left, action);\r\n            // arr.push(node.output());\r\n            action(node);\r\n            this.tree_walk(node.right, action);\r\n        }\r\n    }\r\n\r\n    /* Return true if all red nodes have exactly two black child nodes */\r\n    testRedBlackProperty() {\r\n        let res = true;\r\n        this.tree_walk(this.root, function (node) {\r\n            if (node.color == RB_TREE_COLOR_RED) {\r\n                if (!(node.left.color == RB_TREE_COLOR_BLACK && node.right.color == RB_TREE_COLOR_BLACK)) {\r\n                    res = false;\r\n                }\r\n            }\r\n        });\r\n        return res;\r\n    }\r\n\r\n    /* Throw error if not every path from root to bottom has same black height */\r\n    testBlackHeightProperty(node) {\r\n        let height = 0;\r\n        let heightLeft = 0;\r\n        let heightRight = 0;\r\n        if (node.color == RB_TREE_COLOR_BLACK) {\r\n            height++;\r\n        }\r\n        if (node.left != nil_node) {\r\n            heightLeft = this.testBlackHeightProperty(node.left);\r\n        }\r\n        else {\r\n            heightLeft = 1;\r\n        }\r\n        if (node.right != nil_node) {\r\n            heightRight = this.testBlackHeightProperty(node.right);\r\n        }\r\n        else {\r\n            heightRight = 1;\r\n        }\r\n        if (heightLeft != heightRight) {\r\n            throw new Error('Red-black height property violated');\r\n        }\r\n        height += heightLeft;\r\n        return height;\r\n    };\r\n};\r\n\r\nmodule.exports = IntervalTree;\r\n","/**\r\n * Created by Alex Bol on 3/12/2017.\r\n */\r\n\r\n\"use strict\";\r\n\r\n// require(\"babel-polyfill\");\r\n\r\nlet IntervalTree = require('flatten-interval-tree');\r\n\r\nmodule.exports = function (Flatten) {\r\n    /**\r\n     * Class representing a planar set - a generic container with ability to keep and retrieve shapes and\r\n     * perform spatial queries. Planar set is an extension of Set container, so it supports\r\n     * Set properties and methods\r\n     */\r\n    Flatten.PlanarSet = class PlanarSet extends Set {\r\n        /**\r\n         * Create new empty instance of PlanarSet\r\n         */\r\n        constructor() {\r\n            super();\r\n            this.index = new IntervalTree();\r\n        }\r\n\r\n        /**\r\n         * Add new shape to planar set and to its spatial index.<br/>\r\n         * If shape already exist, it will not be added again.\r\n         * This happens with no error, it is possible to use <i>size</i> property to check if\r\n         * a shape was actually added.<br/>\r\n         * Method returns planar set object updated and may be chained\r\n         * @param {Shape} shape - shape to be added, should have valid <i>box</i> property\r\n         * @returns {PlanarSet}\r\n         */\r\n        add(shape) {\r\n            let size = this.size;\r\n            super.add(shape);\r\n            // size not changed - item not added, probably trying to add same item twice\r\n            if (this.size > size) {\r\n                let node = this.index.insert(shape.box, shape);\r\n            }\r\n            return this;         // in accordance to Set.add interface\r\n        }\r\n\r\n        /**\r\n         * Delete shape from planar set. Returns true if shape was actually deleted, false otherwise\r\n         * @param {Shape} shape - shape to be deleted\r\n         * @returns {boolean}\r\n         */\r\n        delete(shape) {\r\n            let deleted = super.delete(shape);\r\n            if (deleted) {\r\n                this.index.remove(shape.box, shape);\r\n            }\r\n            return deleted;\r\n        }\r\n\r\n        /**\r\n         * Clear planar set\r\n         */\r\n        clear() {\r\n            super.clear();\r\n            this.index = new IntervalTree();\r\n        }\r\n\r\n        /**\r\n         * 2d range search in planar set.<br/>\r\n         * Returns array of all shapes in planar set which bounding box is intersected with query box\r\n         * @param {Box} box - query box\r\n         * @returns {Shapes[]}\r\n         */\r\n        search(box) {\r\n            let resp = this.index.search(box);\r\n            return resp;\r\n        }\r\n\r\n        /**\r\n         * Point location test. Returns array of shapes which contains given point\r\n         * @param {Point} point - query point\r\n         * @returns {Array}\r\n         */\r\n        hit(point) {\r\n            let box = new Flatten.Box(point.x - 1, point.y - 1, point.x + 1, point.y + 1);\r\n            let resp = this.index.search(box);\r\n            return resp.filter((shape) => point.on(shape));\r\n        }\r\n\r\n        /**\r\n         * Returns svg string to draw all shapes in planar set\r\n         * @returns {String}\r\n         */\r\n        svg() {\r\n            let svgcontent = [...this].reduce((acc, shape) => acc + shape.svg(), \"\");\r\n            return svgcontent;\r\n        }\r\n    }\r\n};\r\n\r\n","/**\r\n * Created by Alex Bol on 2/18/2017.\r\n */\r\n\r\n/**\r\n *\r\n * @param Flatten\r\n */\r\nmodule.exports = function(Flatten) {\r\n    /**\r\n     *\r\n     * Class representing a point\r\n     * @type {Point}\r\n     */\r\n    Flatten.Point = class Point {\r\n        /**\r\n         * Point may be constructed by two numbers, or by array of two numbers\r\n         * @param {number} x - x-coordinate (float number)\r\n         * @param {number} y - y-coordinate (float number)\r\n         */\r\n        constructor(...args) {\r\n            /**\r\n             * x-coordinate (float number)\r\n             * @type {number}\r\n             */\r\n            this.x = 0;\r\n            /**\r\n             * y-coordinate (float number)\r\n             * @type {number}\r\n             */\r\n            this.y = 0;\r\n\r\n            if (args.length === 0) {\r\n                return;\r\n            }\r\n\r\n            if (args.length === 1 && args[0] instanceof Array && args[0].length === 2) {\r\n                let arr = args[0];\r\n                if (typeof(arr[0]) == \"number\" && typeof(arr[1]) == \"number\") {\r\n                    this.x = arr[0];\r\n                    this.y = arr[1];\r\n                    return;\r\n                }\r\n            }\r\n\r\n            if (args.length === 1 && args[0] instanceof Object && args[0].name === \"point\") {\r\n                let {x, y} = args[0];\r\n                this.x = x;\r\n                this.y = y;\r\n                return;\r\n            }\r\n\r\n            if (args.length === 2) {\r\n                if (typeof(args[0]) == \"number\" && typeof(args[1]) == \"number\") {\r\n                    this.x = args[0];\r\n                    this.y = args[1];\r\n                    return;\r\n                }\r\n            }\r\n\r\n            throw Flatten.Errors.ILLEGAL_PARAMETERS;\r\n\r\n        }\r\n\r\n        /**\r\n         * Returns bounding box of a point\r\n         * @returns {Box}\r\n         */\r\n        get box() {\r\n            return new Flatten.Box(this.x, this.y, this.x, this.y);\r\n        }\r\n\r\n        /**\r\n         * Method clone returns new copied instance of point\r\n         * @returns {Point}\r\n         */\r\n        clone() {\r\n            return new Flatten.Point(this.x, this.y);\r\n        }\r\n\r\n        get vertices() {\r\n            return [this.clone()];\r\n        }\r\n\r\n        /**\r\n         * Returns true if points are equal up to [Flatten.Utils.DP_TOL]{@link DP_TOL} tolerance\r\n         * @param {Point} pt Query point\r\n         * @returns {boolean}\r\n         */\r\n        equalTo(pt) {\r\n            return Flatten.Utils.EQ(this.x, pt.x) && Flatten.Utils.EQ(this.y, pt.y);\r\n        }\r\n\r\n        /**\r\n         * Defines predicate \"less than\" between points. Returns true if the point is less than query points, false otherwise <br/>\r\n         * By definition point1 < point2 if {point1.y < point2.y || point1.y == point2.y && point1.x < point2.y <br/>\r\n         * Numeric values compared with [Flatten.Utils.DP_TOL]{@link DP_TOL} tolerance\r\n         * @param {Point} pt Query point\r\n         * @returns {boolean}\r\n         */\r\n        lessThan(pt) {\r\n            if (Flatten.Utils.LT(this.y, pt.y))\r\n                return true;\r\n            if (Flatten.Utils.EQ(this.y, pt.y) && Flatten.Utils.LT(this.x, pt.x))\r\n                return true;\r\n            return false;\r\n        }\r\n\r\n        /**\r\n         * Returns new point rotated by given angle around given center point.\r\n         * If center point is omitted, rotates around zero point (0,0).\r\n         * Positive value of angle defines rotation in counter clockwise direction,\r\n         * negative angle defines rotation in clockwise clockwise direction\r\n         * @param {number} angle - angle in radians\r\n         * @param {Point} [center=(0,0)] center\r\n         * @returns {Point}\r\n         */\r\n        rotate(angle, center = {x:0, y:0}) {\r\n            var x_rot = center.x + (this.x - center.x) * Math.cos(angle) - (this.y - center.y) * Math.sin(angle);\r\n            var y_rot = center.y + (this.x - center.x) * Math.sin(angle) + (this.y - center.y) * Math.cos(angle);\r\n\r\n            return new Flatten.Point(x_rot, y_rot);\r\n        }\r\n\r\n        /**\r\n         * Returns new point translated by given vector.\r\n         * Translation vector may by also defined by a pair of numbers.\r\n         * @param {Vector} vector - Translation vector defined as Flatten.Vector or\r\n         * @param {number|number} - Translation vector defined as pair of numbers\r\n         * @returns {Point}\r\n         */\r\n        translate(...args) {\r\n            if (args.length == 1 && (args[0] instanceof Flatten.Vector)) {\r\n                return new Flatten.Point(this.x + args[0].x, this.y + args[0].y);\r\n            }\r\n\r\n            if (args.length == 2 && typeof(args[0]) == \"number\" && typeof(args[1]) == \"number\") {\r\n                return new Flatten.Point(this.x + args[0], this.y + args[1]);\r\n            }\r\n\r\n            throw Flatten.Errors.ILLEGAL_PARAMETERS;\r\n        }\r\n\r\n        /**\r\n         * Return new point transformed by affine transformation matrix m\r\n         * @param {Matrix} m - affine transformation matrix (a,b,c,d,tx,ty)\r\n         * @returns {Point}\r\n         */\r\n        transform(m) {\r\n            // let [x,y] = m.transform([this.x,this.y]);\r\n            return new Flatten.Point(m.transform([this.x,this.y]))\r\n        }\r\n\r\n        /**\r\n         * Returns projection point on given line\r\n         * @param {Line} line Line this point be projected on\r\n         * @returns {Point}\r\n         */\r\n        projectionOn(line) {\r\n            if (this.equalTo(line.pt))                   // this point equal to line anchor point\r\n                return this.clone();\r\n\r\n            let vec = new Flatten.Vector(this, line.pt);\r\n            if (Flatten.Utils.EQ_0(vec.cross(line.norm)))    // vector to point from anchor point collinear to normal vector\r\n                return line.pt.clone();\r\n\r\n            let dist = vec.dot(line.norm);             // signed distance\r\n            let proj_vec = line.norm.multiply(dist);\r\n            return this.translate(proj_vec);\r\n        }\r\n\r\n        /**\r\n         * Returns true if point belongs to the \"left\" semi-plane, which means, point belongs to the same semi plane where line normal vector points to\r\n         * Return false if point belongs to the \"right\" semi-plane or to the line itself\r\n         * @param {Line} line Query line\r\n         * @returns {boolean}\r\n         */\r\n        leftTo(line) {\r\n            let vec = new Flatten.Vector(line.pt, this);\r\n            let onLeftSemiPlane = Flatten.Utils.GT(vec.dot(line.norm), 0);\r\n            return onLeftSemiPlane;\r\n        }\r\n\r\n        /**\r\n         * Calculate distance and shortest segment from point to shape and return as array [distance, shortest segment]\r\n         * @param {Shape} shape Shape of the one of supported types Point, Line, Circle, Segment, Arc, Polygon or Planar Set\r\n         * @returns {number} distance from point to shape\r\n         * @returns {Segment} shortest segment between point and shape (started at point, ended at shape)\r\n         */\r\n        distanceTo(shape) {\r\n            let {Distance} = Flatten;\r\n\r\n            if (shape instanceof Point) {\r\n                let dx = shape.x - this.x;\r\n                let dy = shape.y - this.y;\r\n                return [Math.sqrt(dx*dx + dy*dy), new Flatten.Segment(this, shape)];\r\n            }\r\n\r\n            if (shape instanceof Flatten.Line) {\r\n                return Distance.point2line(this, shape);\r\n            }\r\n\r\n            if (shape instanceof Flatten.Circle) {\r\n                return Distance.point2circle(this, shape);\r\n            }\r\n\r\n            if (shape instanceof Flatten.Segment) {\r\n                return Distance.point2segment(this, shape);\r\n            }\r\n\r\n            if (shape instanceof Flatten.Arc) {\r\n                // let [dist, ...rest] = Distance.point2arc(this, shape);\r\n                // return dist;\r\n                return Distance.point2arc(this, shape);\r\n            }\r\n\r\n            if (shape instanceof Flatten.Polygon) {\r\n                // let [dist, ...rest] = Distance.point2polygon(this, shape);\r\n                // return dist;\r\n                return Distance.point2polygon(this, shape);\r\n            }\r\n\r\n            if (shape instanceof Flatten.PlanarSet) {\r\n                return Distance.shape2planarSet(this, shape);\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Returns true if point is on a shape, false otherwise\r\n         * @param {Shape} shape Shape of the one of supported types Point, Line, Circle, Segment, Arc, Polygon\r\n         * @returns {boolean}\r\n         */\r\n        on(shape) {\r\n            if (shape instanceof Flatten.Point) {\r\n                return this.equalTo(shape);\r\n            }\r\n\r\n            if (shape instanceof Flatten.Line) {\r\n                return shape.contains(this);\r\n            }\r\n\r\n            if (shape instanceof Flatten.Circle) {\r\n                return shape.contains(this);\r\n            }\r\n\r\n            if (shape instanceof  Flatten.Segment) {\r\n                return shape.contains(this);\r\n            }\r\n\r\n            if (shape instanceof Flatten.Arc) {\r\n                return shape.contains(this);\r\n            }\r\n\r\n            if (shape instanceof Flatten.Polygon) {\r\n                return shape.contains(this);\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Return string to draw point in svg as circle with radius \"r\" <br/>\r\n         * Accept any valid attributes of svg elements as svg object\r\n         * Defaults attribues are: <br/>\r\n         * {\r\n         *    r:\"3\",\r\n         *    stroke:\"black\",\r\n         *    strokeWidth:\"1\",\r\n         *    fill:\"red\"\r\n         * }\r\n         * @param {Object} attrs - Any valid attributes of svg circle element, like \"r\", \"stroke\", \"strokeWidth\", \"fill\"\r\n         * @returns {String}\r\n         */\r\n        svg(attrs = {}) {\r\n            let {r, stroke, strokeWidth, fill, id, className} = attrs;\r\n            // let rest_str = Object.keys(rest).reduce( (acc, key) => acc += ` ${key}=\"${rest[key]}\"`, \"\");\r\n            let id_str = (id && id.length > 0) ? `id=\"${id}\"` : \"\";\r\n            let class_str = (className && className.length > 0) ? `class=\"${className}\"` : \"\";\r\n            return `\\n<circle cx=\"${this.x}\" cy=\"${this.y}\" r=\"${r || 3}\" stroke=\"${stroke || \"black\"}\" stroke-width=\"${strokeWidth || 1}\" fill=\"${fill || \"red\"}\" ${id_str} ${class_str} />`;\r\n        }\r\n\r\n        /**\r\n         * This method returns an object that defines how data will be\r\n         * serialized when called JSON.stringify() method\r\n         * @returns {Object}\r\n         */\r\n        toJSON() {\r\n            return Object.assign({},this,{name:\"point\"});\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Function to create point equivalent to \"new\" constructor\r\n     * @param args\r\n     */\r\n    Flatten.point = (...args) => new Flatten.Point(...args);\r\n};\r\n","/**\r\n * Created by Alex Bol on 2/19/2017.\r\n */\r\n\r\n\"use strict\";\r\n\r\nmodule.exports = function(Flatten) {\r\n    /**\r\n     * Class representing a vector\r\n     * @type {Vector}\r\n     */\r\n    Flatten.Vector = class Vector {\r\n        /**\r\n         * Vector may be constructed by two points, or by two float numbers,\r\n         * or by array of two numbers\r\n         * @param {Point} ps - start point\r\n         * @param {Point} pe - end point\r\n         */\r\n        constructor(...args) {\r\n            /**\r\n             * x-coordinate of a vector (float number)\r\n             * @type {number}\r\n             */\r\n            this.x = 0;\r\n            /**\r\n             * y-coordinate of a vector (float number)\r\n             * @type {number}\r\n             */\r\n            this.y = 0;\r\n\r\n            /* return zero vector */\r\n            if (args.length === 0) {\r\n                return;\r\n            }\r\n\r\n            if (args.length === 1 && args[0] instanceof Array && args[0].length === 2) {\r\n                let arr = args[0];\r\n                if (typeof(arr[0]) == \"number\" && typeof(arr[1]) == \"number\") {\r\n                    this.x = arr[0];\r\n                    this.y = arr[1];\r\n                    return;\r\n                }\r\n            }\r\n\r\n            if (args.length === 1 && args[0] instanceof Object && args[0].name === \"vector\") {\r\n                let {x, y} = args[0];\r\n                this.x = x;\r\n                this.y = y;\r\n                return;\r\n            }\r\n\r\n            if (args.length === 2) {\r\n                let a1 = args[0];\r\n                let a2 = args[1];\r\n\r\n                if (typeof(a1) == \"number\" && typeof(a2) == \"number\") {\r\n                    this.x = a1;\r\n                    this.y = a2;\r\n                    return;\r\n                }\r\n\r\n                if (a1 instanceof Flatten.Point && a2 instanceof Flatten.Point) {\r\n                    this.x = a2.x - a1.x;\r\n                    this.y = a2.y - a1.y;\r\n                    return;\r\n                }\r\n\r\n            }\r\n\r\n            throw Flatten.Errors.ILLEGAL_PARAMETERS;\r\n        }\r\n\r\n        /**\r\n         * Method clone returns new instance of Vector\r\n         * @returns {Vector}\r\n         */\r\n        clone() {\r\n            return new Vector(this.x, this.y);\r\n        }\r\n\r\n        /**\r\n         * Slope of the vector in radians from 0 to 2PI\r\n         * @returns {number}\r\n         */\r\n        get slope() {\r\n            let angle = Math.atan2(this.y, this.x);\r\n            if (angle<0) angle = 2*Math.PI + angle;\r\n            return angle;\r\n        }\r\n\r\n        /**\r\n         * Length of vector\r\n         * @returns {number}\r\n         */\r\n        get length() {\r\n            return Math.sqrt(this.dot(this));\r\n        }\r\n\r\n        /**\r\n         * Returns true if vectors are equal up to [DP_TOL]{@link http://localhost:63342/flatten-js/docs/global.html#DP_TOL}\r\n         * tolerance\r\n         * @param {Vector} v\r\n         * @returns {boolean}\r\n         */\r\n        equalTo(v) {\r\n            return Flatten.Utils.EQ(this.x, v.x) && Flatten.Utils.EQ(this.y, v.y);\r\n        }\r\n\r\n        /**\r\n         * Returns new vector multiplied by scalar\r\n         * @param {number} scalar\r\n         * @returns {Vector}\r\n         */\r\n        multiply(scalar) {\r\n            return ( new Vector(scalar * this.x, scalar * this.y) );\r\n        }\r\n\r\n        /**\r\n         * Returns scalar product (dot product) of two vectors <br/>\r\n         * <code>dot_product = (this * v)</code>\r\n         * @param {Vector} v Other vector\r\n         * @returns {number}\r\n         */\r\n        dot(v) {\r\n            return ( this.x * v.x + this.y * v.y );\r\n        }\r\n\r\n        /**\r\n         * Returns vector product (cross product) of two vectors <br/>\r\n         * <code>cross_product = (this x v)</code>\r\n         * @param {Vector} v Other vector\r\n         * @returns {number}\r\n         */\r\n        cross(v) {\r\n            return ( this.x * v.y - this.y * v.x );\r\n        }\r\n\r\n        /**\r\n         * Returns unit vector.<br/>\r\n         * Throw error if given vector has zero length\r\n         * @returns {Vector}\r\n         */\r\n        normalize() {\r\n            if (!Flatten.Utils.EQ_0(this.length)) {\r\n                return ( new Vector(this.x / this.length, this.y / this.length) );\r\n            }\r\n            throw Flatten.Errors.ZERO_DIVISION;\r\n        }\r\n\r\n        /**\r\n         * Returns new vector rotated by given angle,\r\n         * positive angle defines rotation in counter clockwise direction,\r\n         * negative - in clockwise direction\r\n         * @param {number} angle - Angle in radians\r\n         * @returns {Vector}\r\n         */\r\n        rotate(angle) {\r\n            let point = new Flatten.Point(this.x, this.y);\r\n            let rpoint = point.rotate(angle);\r\n            return new Flatten.Vector(rpoint.x, rpoint.y);\r\n        }\r\n\r\n        /**\r\n         * Returns vector rotated 90 degrees counter clockwise\r\n         * @returns {Vector}\r\n         */\r\n        rotate90CCW() {\r\n            return new Flatten.Vector(-this.y, this.x);\r\n        };\r\n\r\n        /**\r\n         * Returns vector rotated 90 degrees clockwise\r\n         * @returns {Vector}\r\n         */\r\n        rotate90CW() {\r\n            return new Flatten.Vector(this.y, -this.x);\r\n        };\r\n\r\n        /**\r\n         * Return inverted vector\r\n         * @returns {Vector}\r\n         */\r\n        invert() {\r\n            return new Flatten.Vector(-this.x, -this.y);\r\n        }\r\n\r\n        /**\r\n         * Return result of addition of other vector to this vector as a new vector\r\n         * @param {Vector} v Other vector\r\n         * @returns {Vector}\r\n         */\r\n        add(v) {\r\n            return new Flatten.Vector(this.x + v.x, this.y + v.y);\r\n        }\r\n\r\n        /**\r\n         * Return result of subtraction of other vector from current vector as a new vector\r\n         * @param {Vector} v Another vector\r\n         * @returns {Vector}\r\n         */\r\n        subtract(v) {\r\n            return new Flatten.Vector(this.x - v.x, this.y - v.y);\r\n        }\r\n\r\n        /**\r\n         * Return angle between this vector and other vector. <br/>\r\n         * Angle is measured from 0 to 2*PI in the counter clockwise direction\r\n         * from current vector to other.\r\n         * @param {Vector} v Another vector\r\n         * @returns {number}\r\n         */\r\n        angleTo(v) {\r\n            let norm1 = this.normalize();\r\n            let norm2 = v.normalize();\r\n            let angle = Math.atan2(norm1.cross(norm2), norm1.dot(norm2));\r\n            if (angle<0) angle += 2*Math.PI;\r\n            return angle;\r\n        }\r\n\r\n        /**\r\n         * Return vector projection of the current vector on another vector\r\n         * @param {Vector} v Another vector\r\n         * @returns {Vector}\r\n         */\r\n        projectionOn(v){\r\n            let n = v.normalize();\r\n            let d = this.dot(n);\r\n            return n.multiply(d);\r\n        }\r\n\r\n        /**\r\n         * This method returns an object that defines how data will be\r\n         * serialized when called JSON.stringify() method\r\n         * @returns {Object}\r\n         */\r\n        toJSON() {\r\n            return Object.assign({},this,{name:\"vector\"});\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Function to create vector equivalent to \"new\" constructor\r\n     * @param args\r\n     */\r\n    Flatten.vector = (...args) => new Flatten.Vector(...args);\r\n};\r\n","/**\r\n * Created by Alex Bol on 2/20/2017.\r\n */\r\n\"use strict\";\r\n\r\nmodule.exports = function(Flatten) {\r\n    /**\r\n     * Class representing a line\r\n     * @type {Line}\r\n     */\r\n    Flatten.Line = class Line {\r\n        /**\r\n         * Line may be constructed by point and normal vector or by two points that a line passes through\r\n         * @param {Point} pt - point that a line passes through\r\n         * @param {Vector|Point} norm - normal vector to a line or second point a line passes through\r\n         */\r\n        constructor(...args) {\r\n            /**\r\n             * Point a line passes through\r\n             * @type {Point}\r\n             */\r\n            this.pt = new Flatten.Point();\r\n            /**\r\n             * Normal vector to a line <br/>\r\n             * Vector is normalized (length == 1)\r\n             * @type {Vector}\r\n             */\r\n            this.norm = new Flatten.Vector(0,1);\r\n\r\n            if (args.length == 0) {\r\n                return;\r\n            }\r\n\r\n            if (args.length == 1 && args[0] instanceof Object && args[0].name === \"line\") {\r\n                let {pt, norm} = args[0];\r\n                this.pt = new Flatten.Point(pt);\r\n                this.norm = new Flatten.Vector(norm);\r\n                return;\r\n            }\r\n\r\n            if (args.length == 2) {\r\n                let a1 = args[0];\r\n                let a2 = args[1];\r\n\r\n                if (a1 instanceof Flatten.Point && a2 instanceof Flatten.Point) {\r\n                    this.pt = a1;\r\n                    this.norm = Line.points2norm(a1, a2);\r\n                    return;\r\n                }\r\n\r\n                if (a1 instanceof Flatten.Point && a2 instanceof Flatten.Vector) {\r\n                    if (Flatten.Utils.EQ_0(a2.x) && Flatten.Utils.EQ_0(a2.y)) {\r\n                        throw Flatten.Errors.ILLEGAL_PARAMETERS;\r\n                    }\r\n                    this.pt = a1.clone();\r\n                    this.norm = a2.clone();\r\n                    this.norm = this.norm.normalize();\r\n                    return;\r\n                }\r\n\r\n                if (a1 instanceof Flatten.Vector && a2 instanceof Flatten.Point) {\r\n                    if (Flatten.Utils.EQ_0(a1.x) && Flatten.Utils.EQ_0(a1.y)) {\r\n                        throw Flatten.Errors.ILLEGAL_PARAMETERS;\r\n                    }\r\n                    this.pt = a2.clone();\r\n                    this.norm = a1.clone();\r\n                    this.norm = this.norm.normalize();\r\n                    return;\r\n                }\r\n            }\r\n\r\n            throw Flatten.Errors.ILLEGAL_PARAMETERS;\r\n        }\r\n\r\n        /**\r\n         * Returns cloned new instance of a line\r\n         * @returns {Line}\r\n         */\r\n        clone() {\r\n            return new Flatten.Line(this.pt, this.norm);\r\n        }\r\n\r\n        /**\r\n         * Slope of the line - angle in radians between line and axe x from 0 to 2PI\r\n         * @returns {number} - slope of the line\r\n         */\r\n        get slope() {\r\n            let vec = new Flatten.Vector(this.norm.y, -this.norm.x);\r\n            return vec.slope;\r\n        }\r\n\r\n        /**\r\n         * Get coefficients [A,B,C] of a standard line equation in the form Ax + By = C\r\n         * @code [A, B, C] = line.standard\r\n         * @returns {number[]} - array of coefficients\r\n         */\r\n        get standard() {\r\n            let A = this.norm.x;\r\n            let B = this.norm.y;\r\n            let C = this.norm.dot(this.pt);\r\n\r\n            return [A,B,C];\r\n        }\r\n\r\n        /**\r\n         * Return true if parallel or incident to other line\r\n         * @param {Line} other_line - line to check\r\n         * @returns {boolean}\r\n         */\r\n        parallelTo(other_line) {\r\n            return Flatten.Utils.EQ_0(this.norm.cross(other_line.norm));\r\n        }\r\n\r\n        /**\r\n         * Returns true if incident to other line\r\n         * @param {Line} other_line - line to check\r\n         * @returns {boolean}\r\n         */\r\n        incidentTo(other_line) {\r\n            return this.parallelTo(other_line) && this.pt.on(other_line);\r\n        }\r\n\r\n        /**\r\n         * Returns true if point belongs to line\r\n         * @param {Point} pt Query point\r\n         * @returns {boolean}\r\n         */\r\n        contains(pt) {\r\n            if (this.pt.equalTo(pt)) {\r\n                return true;\r\n            }\r\n            /* Line contains point if vector to point is orthogonal to the line normal vector */\r\n            let vec = new Flatten.Vector(this.pt, pt);\r\n            return Flatten.Utils.EQ_0(this.norm.dot(vec));\r\n        }\r\n\r\n        /**\r\n         * Returns array of intersection points\r\n         * @param {Shape} shape - shape to intersect with\r\n         * @returns {Point[]}\r\n         */\r\n        intersect(shape) {\r\n            if (shape instanceof Flatten.Point) {\r\n                return this.contains(shape) ? [shape] : [];\r\n            }\r\n\r\n            if (shape instanceof Flatten.Line) {\r\n                return Line.intersectLine2Line(this, shape);\r\n            }\r\n\r\n            if (shape instanceof Flatten.Circle) {\r\n                return Line.intersectLine2Circle(this, shape);\r\n            }\r\n\r\n            if (shape instanceof Flatten.Segment) {\r\n                return shape.intersect(this);\r\n            }\r\n\r\n            if (shape instanceof Flatten.Arc) {\r\n                return Line.intersectLine2Arc(this, shape);\r\n            }\r\n\r\n            if (shape instanceof Flatten.Polygon) {\r\n                return Flatten.Polygon.intersectLine2Polygon(this, shape);\r\n            }\r\n\r\n        }\r\n\r\n        /**\r\n         * Calculate distance and shortest segment from line to shape and returns array [distance, shortest_segment]\r\n         * @param {Shape} shape Shape of the one of the types Point, Circle, Segment, Arc, Polygon\r\n         * @returns {Number}\r\n         * @returns {Segment}\r\n         */\r\n        distanceTo(shape) {\r\n            let {Distance} = Flatten;\r\n\r\n            if (shape instanceof Flatten.Point) {\r\n                let [distance, shortest_segment] = Distance.point2line(shape, this);\r\n                shortest_segment = shortest_segment.reverse();\r\n                return [distance, shortest_segment];\r\n            }\r\n\r\n            if (shape instanceof Flatten.Circle) {\r\n                let [distance, shortest_segment] = Distance.circle2line(shape, this);\r\n                shortest_segment = shortest_segment.reverse();\r\n                return [distance, shortest_segment];\r\n            }\r\n\r\n            if (shape instanceof Flatten.Segment) {\r\n                let [distance, shortest_segment] = Distance.segment2line(shape, this);\r\n                return [distance, shortest_segment.reverse()];\r\n            }\r\n\r\n            if (shape instanceof Flatten.Arc) {\r\n                let [distance, shortest_segment] = Distance.arc2line(shape, this);\r\n                return [distance, shortest_segment.reverse()];\r\n            }\r\n\r\n            if (shape instanceof Flatten.Polygon) {\r\n                let [distance, shortest_segment] = Distance.shape2polygon(this, shape);\r\n                return [distance, shortest_segment];\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Return string to draw svg segment representing line inside given box\r\n         * @param {Box} box Box representing drawing area\r\n         * @param {Object} attrs - an object with attributes of svg circle element\r\n         */\r\n        svg(box, attrs = {}) {\r\n            let ip = Line.intersectLine2Box(this, box);\r\n            if (ip.length === 0)\r\n                return \"\";\r\n            let ps = ip[0];\r\n            let pe = ip.length == 2 ? ip[1] : ip.find( pt => !pt.equalTo(ps) );\r\n            if (pe === undefined) pe = ps;\r\n            let segment = new Flatten.Segment(ps, pe);\r\n            return segment.svg(attrs);\r\n        }\r\n\r\n        /**\r\n         * This method returns an object that defines how data will be\r\n         * serialized when called JSON.stringify() method\r\n         * @returns {Object}\r\n         */\r\n        toJSON() {\r\n            return Object.assign({},this,{name:\"line\"});\r\n        }\r\n\r\n        static points2norm(pt1, pt2) {\r\n            if (pt1.equalTo(pt2)) {\r\n                throw Flatten.Errors.ILLEGAL_PARAMETERS;\r\n            }\r\n            let vec = new Flatten.Vector(pt1, pt2);\r\n            let unit = vec.normalize();\r\n            return unit.rotate90CCW();\r\n        }\r\n\r\n        static intersectLine2Line(line1, line2) {\r\n            let ip = [];\r\n\r\n            let [A1, B1, C1] = line1.standard;\r\n            let [A2, B2, C2] = line2.standard;\r\n\r\n            /* Cramer's rule */\r\n            let det = A1*B2 - B1*A2;\r\n            let detX = C1*B2 - B1*C2;\r\n            let detY = A1*C2 - C1*A2;\r\n\r\n            if (!Flatten.Utils.EQ_0(det)) {\r\n                let new_ip = new Flatten.Point( detX/det, detY/det );\r\n                ip.push(new_ip);\r\n            }\r\n            return ip;\r\n        }\r\n\r\n        static intersectLine2Circle(line, circle) {\r\n            let ip = [];\r\n            let prj = circle.pc.projectionOn(line);            // projection of circle center on line\r\n            let dist = circle.pc.distanceTo(prj)[0];           // distance from circle center to projection\r\n\r\n            if (Flatten.Utils.EQ(dist, circle.r)) {            // line tangent to circle - return single intersection point\r\n                ip.push(prj);\r\n            }\r\n            else if (Flatten.Utils.LT(dist, circle.r)) {       // return two intersection points\r\n                let delta = Math.sqrt(circle.r*circle.r - dist*dist);\r\n                let v_trans, pt;\r\n\r\n                v_trans = line.norm.rotate90CCW().multiply(delta);\r\n                pt = prj.translate(v_trans);\r\n                ip.push(pt);\r\n\r\n                v_trans = line.norm.rotate90CW().multiply(delta);\r\n                pt = prj.translate(v_trans);\r\n                ip.push(pt);\r\n            }\r\n            return ip;\r\n        }\r\n\r\n        static intersectLine2Box(line, box) {\r\n            let pts = [\r\n                new Flatten.Point(box.xmin, box.ymin),\r\n                new Flatten.Point(box.xmax, box.ymin),\r\n                new Flatten.Point(box.xmax, box.ymax),\r\n                new Flatten.Point(box.xmin, box.ymax)\r\n            ];\r\n            let segs = [\r\n                new Flatten.Segment(pts[0], pts[1]),\r\n                new Flatten.Segment(pts[1], pts[2]),\r\n                new Flatten.Segment(pts[2], pts[3]),\r\n                new Flatten.Segment(pts[3], pts[0])\r\n            ];\r\n\r\n            let ips =  [];\r\n\r\n            for(let seg of segs) {\r\n                let ips_tmp = seg.intersect(line);\r\n                for (let ip of ips_tmp) {\r\n                    ips.push(ip);\r\n                }\r\n            };\r\n            return ips;\r\n        }\r\n\r\n        static intersectLine2Arc(line, arc) {\r\n            let ip = [];\r\n\r\n            if (Line.intersectLine2Box(line, arc.box).length == 0) {\r\n                return ip;\r\n            }\r\n\r\n            let circle = new Flatten.Circle(arc.pc, arc.r);\r\n            let ip_tmp = line.intersect(circle);\r\n            for (let pt of ip_tmp) {\r\n                if (pt.on(arc)) {\r\n                    ip.push(pt);\r\n                }\r\n            }\r\n\r\n            return ip;\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Function to create line equivalent to \"new\" constructor\r\n     * @param args\r\n     */\r\n    Flatten.line = (...args) => new Flatten.Line(...args);\r\n};\r\n","/**\r\n * Created by Alex Bol on 3/6/2017.\r\n */\r\n\r\n\"use strict\";\r\n\r\nmodule.exports = function(Flatten) {\r\n    let {Arc,vector} = Flatten;\r\n    /**\r\n     * Class representing a circle\r\n     * @type {Circle}\r\n     */\r\n    Flatten.Circle = class Circle {\r\n        /**\r\n         *\r\n         * @param {Point} pc - circle center point\r\n         * @param {number} r - circle radius\r\n         */\r\n        constructor(...args) {\r\n            /**\r\n             * Circle center\r\n             * @type {Point}\r\n             */\r\n            this.pc = new Flatten.Point();\r\n            /**\r\n             * Circle radius\r\n             * @type {number}\r\n             */\r\n            this.r = 1;\r\n\r\n            if (args.length == 1 && args[0] instanceof Object && args[0].name === \"circle\") {\r\n                let {pc, r} = args[0];\r\n                this.pc = new Flatten.Point(pc);\r\n                this.r = r;\r\n                return;\r\n            }\r\n            else {\r\n                let [pc, r] = [...args];\r\n                if (pc && pc instanceof Flatten.Point) this.pc = pc.clone();\r\n                if (r !== undefined) this.r = r;\r\n                return;\r\n            }\r\n\r\n            throw Flatten.Errors.ILLEGAL_PARAMETERS;\r\n        }\r\n\r\n        /**\r\n         * Method clone returns new instance of a Circle\r\n         * @returns {Circle}\r\n         */\r\n        clone() {\r\n            return new Flatten.Circle(this.pc.clone(), this.r);\r\n        }\r\n\r\n        /**\r\n         * Circle center\r\n         * @returns {Point}\r\n         */\r\n        get center() {\r\n            return this.pc;\r\n        }\r\n\r\n        /**\r\n         * Circle bounding box\r\n         * @returns {Box}\r\n         */\r\n        get box() {\r\n            return new Flatten.Box(\r\n                this.pc.x - this.r,\r\n                this.pc.y - this.r,\r\n                this.pc.x + this.r,\r\n                this.pc.y + this.r\r\n            );\r\n        }\r\n\r\n        /**\r\n         * Return true if circle contains point\r\n         * @param {Point} pt - test point\r\n         * @returns {boolean}\r\n         */\r\n        contains(pt) {\r\n            return Flatten.Utils.LE(pt.distanceTo(this.center)[0], this.r);\r\n        }\r\n\r\n        /**\r\n         * Transform circle to closed arc\r\n         * @param {boolean} counterclockwise\r\n         * @returns {Arc}\r\n         */\r\n        toArc(counterclockwise=true) {\r\n            return new Flatten.Arc(this.center, this.r, Math.PI, -Math.PI, counterclockwise);\r\n        }\r\n\r\n        /**\r\n         * Returns array of intersection points between circle and other shape\r\n         * @param {Shape} shape Shape of the one of supported types\r\n         * @returns {Point[]}\r\n         */\r\n        intersect(shape) {\r\n            if (shape instanceof Flatten.Point) {\r\n                return this.contains(shape) ? [shape] : [];\r\n            }\r\n            if (shape instanceof Flatten.Line) {\r\n                return shape.intersect(this);\r\n            }\r\n\r\n            if (shape instanceof Flatten.Segment) {\r\n                return shape.intersect(this);\r\n            }\r\n\r\n            if (shape instanceof Flatten.Circle) {\r\n                return Circle.intersectCirle2Circle(this, shape);\r\n            }\r\n\r\n            if (shape instanceof Flatten.Arc) {\r\n                return shape.intersect(this);\r\n            }\r\n            if (shape instanceof Flatten.Polygon) {\r\n                return Flatten.Polygon.intersectShape2Polygon(this, shape);\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Calculate distance and shortest segment from circle to shape and return array [distance, shortest segment]\r\n         * @param {Shape} shape Shape of the one of supported types Point, Line, Circle, Segment, Arc, Polygon or Planar Set\r\n         * @returns {number} distance from circle to shape\r\n         * @returns {Segment} shortest segment between circle and shape (started at circle, ended at shape)\r\n\r\n         */\r\n        distanceTo(shape) {\r\n            let {Distance} = Flatten;\r\n            let {point2circle, circle2circle, circle2line, segment2circle, arc2circle} = Distance;\r\n\r\n            if (shape instanceof Flatten.Point) {\r\n                let [distance, shortest_segment] = point2circle(shape, this);\r\n                shortest_segment = shortest_segment.reverse();\r\n                return [distance, shortest_segment];\r\n            }\r\n\r\n            if (shape instanceof Flatten.Circle) {\r\n                let [distance, shortest_segment] = circle2circle(this, shape);\r\n                return [distance, shortest_segment];\r\n            }\r\n\r\n            if (shape instanceof Flatten.Line) {\r\n                let [distance, shortest_segment] = circle2line(this, shape);\r\n                return [distance, shortest_segment];\r\n            }\r\n\r\n            if (shape instanceof Flatten.Segment) {\r\n                let [distance, shortest_segment] = segment2circle(shape, this);\r\n                shortest_segment = shortest_segment.reverse();\r\n                return [distance, shortest_segment];\r\n            }\r\n\r\n            if (shape instanceof Flatten.Arc) {\r\n                let [distance, shortest_segment] = arc2circle(shape, this);\r\n                shortest_segment = shortest_segment.reverse();\r\n                return [distance, shortest_segment];\r\n            }\r\n\r\n            if (shape instanceof Flatten.Polygon) {\r\n                let [distance, shortest_segment] = Distance.shape2polygon(this, shape);\r\n                return [distance, shortest_segment];\r\n            }\r\n\r\n            if (shape instanceof Flatten.PlanarSet) {\r\n                let [dist, shortest_segment] = Distance.shape2planarSet(this, shape);\r\n                return [dist, shortest_segment];\r\n            }\r\n        }\r\n\r\n        static intersectCirle2Circle(circle1, circle2) {\r\n            let ip = [];\r\n\r\n            if (circle1.box.not_intersect(circle2.box)) {\r\n                return ip;\r\n            }\r\n\r\n            let vec = new Flatten.Vector(circle1.pc, circle2.pc);\r\n\r\n            let r1 = circle1.r;\r\n            let r2 = circle2.r;\r\n\r\n            // Degenerated circle\r\n            if (Flatten.Utils.EQ_0(r1) || Flatten.Utils.EQ_0(r2))\r\n                return ip;\r\n\r\n            // In case of equal circles return one leftmost point\r\n            if (Flatten.Utils.EQ_0(vec.x) && Flatten.Utils.EQ_0(vec.y) && Flatten.Utils.EQ(r1, r2)) {\r\n                ip.push(circle1.pc.translate(-r1, 0));\r\n                return ip;\r\n            }\r\n\r\n            let dist = circle1.pc.distanceTo(circle2.pc)[0];\r\n\r\n            if (Flatten.Utils.GT(dist, r1 + r2))               // circles too far, no intersections\r\n                return ip;\r\n\r\n            if (Flatten.Utils.LT(dist, Math.abs(r1 - r2)))     // one circle is contained within another, no intersections\r\n                return ip;\r\n\r\n            // Normalize vector.\r\n            vec.x /= dist;\r\n            vec.y /= dist;\r\n\r\n            let pt;\r\n\r\n            // Case of touching from outside or from inside - single intersection point\r\n            // TODO: check this specifically not sure if correct\r\n            if (Flatten.Utils.EQ(dist, r1 + r2) || Flatten.Utils.EQ(dist, Math.abs(r1 - r2))) {\r\n                pt = circle1.pc.translate(r1*vec.x, r1*vec.y);\r\n                ip.push(pt);\r\n                return ip;\r\n            }\r\n\r\n            // Case of two intersection points\r\n\r\n            // Distance from first center to center of common chord:\r\n            //   a = (r1^2 - r2^2 + d^2) / 2d\r\n            // Separate for better accuracy\r\n            let a = (r1*r1)/(2*dist) - (r2*r2)/(2*dist) + dist/2;\r\n\r\n            let mid_pt = circle1.pc.translate(a*vec.x, a*vec.y);\r\n            let h = Math.sqrt(r1*r1 - a*a);\r\n            // let norm;\r\n\r\n            // norm = vec.rotate90CCW().multiply(h);\r\n            pt = mid_pt.translate(vec.rotate90CCW().multiply(h));\r\n            ip.push(pt);\r\n\r\n            // norm = vec.rotate90CW();\r\n            pt = mid_pt.translate(vec.rotate90CW().multiply(h));\r\n            ip.push(pt);\r\n\r\n            return ip;\r\n        }\r\n\r\n        /**\r\n         * Return string to draw circle in svg\r\n         * @param {Object} attrs - an object with attributes of svg circle element,\r\n         * like \"stroke\", \"strokeWidth\", \"fill\" <br/>\r\n         * Defaults are stroke:\"black\", strokeWidth:\"1\", fill:\"none\"\r\n         * @returns {string}\r\n         */\r\n        svg(attrs = {}) {\r\n            let {stroke, strokeWidth, fill, fillOpacity, id, className} = attrs;\r\n            // let rest_str = Object.keys(rest).reduce( (acc, key) => acc += ` ${key}=\"${rest[key]}\"`, \"\");\r\n            let id_str = (id && id.length > 0) ? `id=\"${id}\"` : \"\";\r\n            let class_str = (className && className.length > 0) ? `class=\"${className}\"` : \"\";\r\n\r\n            return `\\n<circle cx=\"${this.pc.x}\" cy=\"${this.pc.y}\" r=\"${this.r}\" stroke=\"${stroke || \"black\"}\" stroke-width=\"${strokeWidth || 1}\" fill=\"${fill || \"none\"}\" fill-opacity=\"${fillOpacity || 1.0}\" ${id_str} ${class_str} />`;\r\n        }\r\n\r\n        /**\r\n         * This method returns an object that defines how data will be\r\n         * serialized when called JSON.stringify() method\r\n         * @returns {Object}\r\n         */\r\n        toJSON() {\r\n            return Object.assign({},this,{name:\"circle\"});\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Shortcut to create new circle\r\n     * @param args\r\n     */\r\n    Flatten.circle = (...args) => new Flatten.Circle(...args);\r\n};","/**\r\n * Created by Alex Bol on 3/10/2017.\r\n */\r\n\r\n\r\n\"use strict\";\r\n\r\nmodule.exports = function (Flatten) {\r\n    /**\r\n     * Class representing a segment\r\n     * @type {Segment}\r\n     */\r\n    Flatten.Segment = class Segment {\r\n        /**\r\n         *\r\n         * @param {Point} ps - start point\r\n         * @param {Point} pe - end point\r\n         */\r\n        constructor(...args) {\r\n            /**\r\n             * Start point\r\n             * @type {Point}\r\n             */\r\n            this.ps = new Flatten.Point();\r\n            /**\r\n             * End Point\r\n             * @type {Point}\r\n             */\r\n            this.pe = new Flatten.Point();\r\n\r\n            if (args.length == 0) {\r\n                return;\r\n            }\r\n\r\n            if (args.length == 1 && args[0] instanceof Array && args[0].length == 4) {\r\n                let coords = args[0];\r\n                this.ps = new Flatten.Point(coords[0], coords[1]);\r\n                this.pe = new Flatten.Point(coords[2], coords[3]);\r\n                return;\r\n            }\r\n\r\n            if (args.length == 1 && args[0] instanceof Object && args[0].name === \"segment\") {\r\n                let {ps,pe} = args[0];\r\n                this.ps = new Flatten.Point(ps.x, ps.y);\r\n                this.pe = new Flatten.Point(pe.x, pe.y);\r\n                return;\r\n            }\r\n\r\n            if (args.length == 2 && args[0] instanceof Flatten.Point && args[1] instanceof Flatten.Point) {\r\n                this.ps = args[0].clone();\r\n                this.pe = args[1].clone();\r\n                return;\r\n            }\r\n\r\n            if (args.length == 4) {\r\n                this.ps = new Flatten.Point(args[0], args[1]);\r\n                this.pe = new Flatten.Point(args[2], args[3]);\r\n                return;\r\n            }\r\n\r\n            throw Flatten.Errors.ILLEGAL_PARAMETERS;\r\n        }\r\n\r\n        /**\r\n         * Method clone copies segment and returns a new instance\r\n         * @returns {Segment}\r\n         */\r\n        clone() {\r\n            return new Flatten.Segment(this.start, this.end);\r\n        }\r\n\r\n        /**\r\n         * Start point\r\n         * @returns {Point}\r\n         */\r\n        get start() {\r\n            return this.ps;\r\n        }\r\n\r\n        /**\r\n         * End point\r\n         * @returns {Point}\r\n         */\r\n        get end() {\r\n            return this.pe;\r\n        }\r\n\r\n\r\n        /**\r\n         * Returns array of start and end point\r\n         * @returns [Point,Point]\r\n         */\r\n        get vertices() {\r\n            return [this.ps.clone(), this.pe.clone()];\r\n        }\r\n\r\n        /**\r\n         * Length of a segment\r\n         * @returns {number}\r\n         */\r\n        get length() {\r\n            return this.start.distanceTo(this.end)[0];\r\n        }\r\n\r\n        /**\r\n         * Slope of the line - angle to axe x in radians from 0 to 2PI\r\n         * @returns {number}\r\n         */\r\n        get slope() {\r\n            let vec = new Flatten.Vector(this.start, this.end);\r\n            return vec.slope;\r\n        }\r\n\r\n        /**\r\n         * Bounding box\r\n         * @returns {Box}\r\n         */\r\n        get box() {\r\n            return new Flatten.Box(\r\n                Math.min(this.start.x, this.end.x),\r\n                Math.min(this.start.y, this.end.y),\r\n                Math.max(this.start.x, this.end.x),\r\n                Math.max(this.start.y, this.end.y)\r\n            )\r\n        }\r\n\r\n        /**\r\n         * Returns true if equals to query segment, false otherwise\r\n         * @param {Seg} seg - query segment\r\n         * @returns {boolean}\r\n         */\r\n        equalTo(seg) {\r\n            return this.ps.equalTo(seg.ps) && this.pe.equalTo(seg.pe);\r\n        }\r\n\r\n        /**\r\n         * Returns true if segment contains point\r\n         * @param {Point} pt Query point\r\n         * @returns {boolean}\r\n         */\r\n        contains(pt) {\r\n            return Flatten.Utils.EQ_0(this.distanceToPoint(pt));\r\n        }\r\n\r\n        /**\r\n         * Returns array of intersection points between segment and other shape\r\n         * @param {Shape} shape - Shape of the one of supported types <br/>\r\n         * @returns {Point[]}\r\n         */\r\n        intersect(shape) {\r\n            if (shape instanceof Flatten.Point) {\r\n                return this.contains(shape) ? [shape] : [];\r\n            }\r\n\r\n            if (shape instanceof Flatten.Line) {\r\n                return Segment.intersectSegment2Line(this, shape);\r\n            }\r\n\r\n            if (shape instanceof Flatten.Segment) {\r\n                return Segment.intersectSegment2Segment(this, shape);\r\n            }\r\n\r\n            if (shape instanceof Flatten.Circle) {\r\n                return Segment.intersectSegment2Circle(this, shape);\r\n            }\r\n\r\n            if (shape instanceof Flatten.Arc) {\r\n                return Segment.intersectSegment2Arc(this, shape);\r\n            }\r\n\r\n            if (shape instanceof Flatten.Polygon) {\r\n                return Flatten.Polygon.intersectShape2Polygon(this, shape);\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Calculate distance and shortest segment from segment to shape and return as array [distance, shortest segment]\r\n         * @param {Shape} shape Shape of the one of supported types Point, Line, Circle, Segment, Arc, Polygon or Planar Set\r\n         * @returns {number} distance from segment to shape\r\n         * @returns {Segment} shortest segment between segment and shape (started at segment, ended at shape)\r\n         */\r\n        distanceTo(shape) {\r\n            let {Distance} = Flatten;\r\n\r\n            if (shape instanceof Flatten.Point) {\r\n                let [dist, shortest_segment] = Distance.point2segment(shape, this);\r\n                shortest_segment = shortest_segment.reverse();\r\n                return [dist, shortest_segment];\r\n            }\r\n\r\n            if (shape instanceof Flatten.Circle) {\r\n                let [dist, shortest_segment] = Distance.segment2circle(this, shape);\r\n                return [dist, shortest_segment];\r\n            }\r\n\r\n            if (shape instanceof Flatten.Line) {\r\n                let [dist, shortest_segment] = Distance.segment2line(this, shape);\r\n                return [dist, shortest_segment];\r\n            }\r\n\r\n            if (shape instanceof Flatten.Segment) {\r\n                let [dist, shortest_segment] = Distance.segment2segment(this, shape);\r\n                return [dist, shortest_segment];\r\n            }\r\n\r\n            if (shape instanceof Flatten.Arc) {\r\n                let [dist, shortest_segment] = Distance.segment2arc(this, shape);\r\n                return [dist, shortest_segment];\r\n            }\r\n\r\n            if (shape instanceof Flatten.Polygon) {\r\n                let [dist, shortest_segment] = Distance.shape2polygon(this, shape);\r\n                return [dist, shortest_segment];\r\n            }\r\n\r\n            if (shape instanceof Flatten.PlanarSet) {\r\n                let [dist, shortest_segment] = Distance.shape2planarSet(this, shape);\r\n                return [dist, shortest_segment];\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Returns unit vector in the direction from start to end\r\n         * @returns {Vector}\r\n         */\r\n        tangentInStart() {\r\n            let vec = new Flatten.Vector(this.start, this.end);\r\n            return vec.normalize();\r\n        }\r\n\r\n        /**\r\n         * Return unit vector in the direction from end to start\r\n         * @returns {Vector}\r\n         */\r\n        tangentInEnd() {\r\n            let vec = new Flatten.Vector(this.end, this.start);\r\n            return vec.normalize();\r\n        }\r\n\r\n        /**\r\n         * Returns new segment with swapped start and end points\r\n         * @returns {Segment}\r\n         */\r\n        reverse() {\r\n            return new Segment(this.end, this.start);\r\n        }\r\n\r\n        /**\r\n         * When point belongs to segment, return array of two segments split by given point,\r\n         * if point is inside segment. Returns clone of this segment if query point is incident\r\n         * to start or end point of the segment. Returns empty array if point does not belong to segment\r\n         * @param {Point} pt Query point\r\n         * @returns {Segment[]}\r\n         */\r\n        split(pt) {\r\n            if (!this.contains(pt))\r\n                return [];\r\n\r\n            if (this.start.equalTo(this.end))\r\n                return [this.clone()];\r\n\r\n            if (this.start.equalTo(pt) || this.end.equalTo(pt))\r\n                return [this];\r\n\r\n            return [\r\n                new Flatten.Segment(this.start, pt),\r\n                new Flatten.Segment(pt, this.end)\r\n            ]\r\n        }\r\n\r\n        /**\r\n         * Return middle point of the segment\r\n         * @returns {Point}\r\n         */\r\n        middle() {\r\n            return new Flatten.Point((this.start.x + this.end.x)/2, (this.start.y + this.end.y)/2);\r\n        }\r\n\r\n        distanceToPoint(pt) {\r\n            let [dist, ...rest] = Flatten.Distance.point2segment(pt, this);\r\n            return dist;\r\n        };\r\n\r\n        definiteIntegral(ymin = 0.0) {\r\n            let dx = this.end.x - this.start.x;\r\n            let dy1 = this.start.y - ymin;\r\n            let dy2 = this.end.y - ymin;\r\n            return ( dx * (dy1 + dy2) / 2 );\r\n        }\r\n\r\n        /**\r\n         * Returns new segment translated by vector vec\r\n         * @param {Vector} vec\r\n         * @returns {Segment}\r\n         */\r\n        translate(...args) {\r\n            return new Segment(this.ps.translate(...args), this.pe.translate(...args));\r\n        }\r\n\r\n        /**\r\n         * Return new segment rotated by given angle around given point\r\n         * If point omitted, rotate around origin (0,0)\r\n         * Positive value of angle defines rotation counter clockwise, negative - clockwise\r\n         * @param {number} angle - rotation angle in radians\r\n         * @param {Point} center - center point, default is (0,0)\r\n         * @returns {Segment}\r\n         */\r\n        rotate(angle = 0, center = new Flatten.Point()) {\r\n            let m = new Flatten.Matrix();\r\n            m = m.translate(center.x, center.y).rotate(angle).translate(-center.x, -center.y);\r\n            return this.transform(m);\r\n        }\r\n\r\n        /**\r\n         * Return new segment transformed using affine transformation matrix\r\n         * @param {Matrix} matrix - affine transformation matrix\r\n         * @returns {Segment} - transformed segment\r\n         */\r\n        transform(matrix = new Flatten.Matrix()) {\r\n            return new Segment(this.ps.transform(matrix), this.pe.transform(matrix))\r\n        }\r\n\r\n        /**\r\n         * Returns true if segment start is equal to segment end up to DP_TOL\r\n         * @returns {boolean}\r\n         */\r\n        isZeroLength() {\r\n            return this.ps.equalTo(this.pe)\r\n        }\r\n\r\n        static intersectSegment2Line(seg, line) {\r\n            let ip = [];\r\n\r\n            // Boundary cases\r\n            if (seg.ps.on(line)) {\r\n                ip.push(seg.ps);\r\n            }\r\n            // If both ends lay on line, return two intersection points\r\n            if (seg.pe.on(line) && !seg.isZeroLength()) {\r\n                ip.push(seg.pe);\r\n            }\r\n\r\n            if (ip.length > 0) {\r\n                return ip;          // done, intersection found\r\n            }\r\n\r\n            // If zero-length segment and nothing found, return no intersections\r\n            if (seg.isZeroLength()) {\r\n                return ip;\r\n            }\r\n\r\n            // Not a boundary case, check if both points are on the same side and\r\n            // hence there is no intersection\r\n            if (seg.ps.leftTo(line) && seg.pe.leftTo(line) ||\r\n                !seg.ps.leftTo(line) && !seg.pe.leftTo(line)) {\r\n                return ip;\r\n            }\r\n\r\n            // Calculate intersection between lines\r\n            let line1 = new Flatten.Line(seg.ps, seg.pe);\r\n            return line1.intersect(line);\r\n        }\r\n\r\n        static intersectSegment2Segment(seg1, seg2) {\r\n            let ip = [];\r\n\r\n            // quick reject\r\n            if (seg1.box.not_intersect(seg2.box)) {\r\n                return ip;\r\n            }\r\n\r\n            // Special case of seg1 zero length\r\n            if (seg1.isZeroLength()) {\r\n                if (seg1.ps.on(seg2)) {\r\n                    ip.push(seg1.ps);\r\n                }\r\n                return ip;\r\n            }\r\n\r\n            // Special case of seg2 zero length\r\n            if (seg2.isZeroLength()) {\r\n                if (seg2.ps.on(seg1)) {\r\n                    ip.push(seg2.ps);\r\n                }\r\n                return ip;\r\n            }\r\n\r\n            // Neither seg1 nor seg2 is zero length\r\n            let line1 = new Flatten.Line(seg1.ps, seg1.pe);\r\n            let line2 = new Flatten.Line(seg2.ps, seg2.pe);\r\n\r\n            // Check overlapping between segments in case of incidence\r\n            // If segments touching, add one point. If overlapping, add two points\r\n            if (line1.incidentTo(line2)) {\r\n                if (seg1.ps.on(seg2)) {\r\n                    ip.push(seg1.ps);\r\n                }\r\n                if (seg1.pe.on(seg2)) {\r\n                    ip.push(seg1.pe);\r\n                }\r\n                if (seg2.ps.on(seg1) && !seg2.ps.equalTo(seg1.ps) && !seg2.ps.equalTo(seg1.pe)) {\r\n                    ip.push(seg2.ps);\r\n                }\r\n                if (seg2.pe.on(seg1) && !seg2.pe.equalTo(seg1.ps) && !seg2.pe.equalTo(seg1.pe)) {\r\n                    ip.push(seg2.pe);\r\n                }\r\n            }\r\n            else {                /* not incident - parallel or intersect */\r\n                // Calculate intersection between lines\r\n                let new_ip = line1.intersect(line2);\r\n                if (new_ip.length > 0 && new_ip[0].on(seg1) && new_ip[0].on(seg2)) {\r\n                    ip.push(new_ip[0]);\r\n                }\r\n            }\r\n\r\n            return ip;\r\n        }\r\n\r\n        static intersectSegment2Circle(segment, circle) {\r\n            let ips = [];\r\n\r\n            if (segment.box.not_intersect(circle.box)) {\r\n                return ips;\r\n            }\r\n\r\n            // Special case of zero length segment\r\n            if (segment.isZeroLength()) {\r\n                let [dist,shortest_segment] = segment.ps.distanceTo(circle.pc);\r\n                if (Flatten.Utils.EQ(dist, circle.r)) {\r\n                    ips.push(segment.ps);\r\n                }\r\n                return ips;\r\n            }\r\n\r\n            // Non zero-length segment\r\n            let line = new Flatten.Line(segment.ps, segment.pe);\r\n\r\n            let ips_tmp = line.intersect(circle);\r\n\r\n            for (let ip of ips_tmp) {\r\n                if (ip.on(segment)) {\r\n                    ips.push(ip);\r\n                }\r\n            }\r\n\r\n            return ips;\r\n        }\r\n\r\n        static intersectSegment2Arc(segment, arc) {\r\n            let ip = [];\r\n\r\n            if (segment.box.not_intersect(arc.box)) {\r\n                return ip;\r\n            }\r\n\r\n            // Special case of zero-length segment\r\n            if (segment.isZeroLength()) {\r\n                if (segment.ps.on(arc)) {\r\n                    ip.push(segment.ps);\r\n                }\r\n                return ip;\r\n            }\r\n\r\n            // Non-zero length segment\r\n            let line = new Flatten.Line(segment.ps, segment.pe);\r\n            let circle = new Flatten.Circle(arc.pc, arc.r);\r\n\r\n            let ip_tmp = line.intersect(circle);\r\n\r\n            for (let pt of ip_tmp) {\r\n                if (pt.on(segment) && pt.on(arc)) {\r\n                    ip.push(pt);\r\n                }\r\n            }\r\n            return ip;\r\n\r\n        }\r\n\r\n        /**\r\n         * Return string to draw segment in svg\r\n         * @param {Object} attrs - an object with attributes for svg path element,\r\n         * like \"stroke\", \"strokeWidth\" <br/>\r\n         * Defaults are stroke:\"black\", strokeWidth:\"1\"\r\n         * @returns {string}\r\n         */\r\n        svg(attrs = {}) {\r\n            let {stroke, strokeWidth, id, className} = attrs;\r\n            // let rest_str = Object.keys(rest).reduce( (acc, key) => acc += ` ${key}=\"${rest[key]}\"`, \"\");\r\n            let id_str = (id && id.length > 0) ? `id=\"${id}\"` : \"\";\r\n            let class_str = (className && className.length > 0) ? `class=\"${className}\"` : \"\";\r\n\r\n            return `\\n<line x1=\"${this.start.x}\" y1=\"${this.start.y}\" x2=\"${this.end.x}\" y2=\"${this.end.y}\" stroke=\"${stroke || \"black\"}\" stroke-width=\"${strokeWidth || 1}\" ${id_str} ${class_str} />`;\r\n\r\n        }\r\n\r\n        /**\r\n         * This method returns an object that defines how data will be\r\n         * serialized when called JSON.stringify() method\r\n         * @returns {Object}\r\n         */\r\n        toJSON() {\r\n            return Object.assign({},this,{name:\"segment\"});\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Shortcut method to create new segment\r\n     */\r\n    Flatten.segment = (...args) => new Flatten.Segment(...args);\r\n};","/**\r\n * Created by Alex Bol on 3/10/2017.\r\n */\r\n\r\n\"use strict\";\r\n\r\nmodule.exports = function(Flatten) {\r\n    /**\r\n     * Class representing a circular arc\r\n     * @type {Arc}\r\n     */\r\n    Flatten.Arc = class Arc {\r\n        /**\r\n         *\r\n         * @param {Point} pc - arc center\r\n         * @param {number} r - arc radius\r\n         * @param {number} startAngle - start angle in radians from 0 to 2*PI\r\n         * @param {number} endAngle - end angle in radians from 0 to 2*PI\r\n         * @param {boolean} counterClockwise - arc direction, true - clockwise, false - counter clockwise\r\n         */\r\n        constructor(...args) {\r\n            /**\r\n             * Arc center\r\n             * @type {Point}\r\n             */\r\n            this.pc = new Flatten.Point();\r\n            /**\r\n             * Arc radius\r\n             * @type {number}\r\n             */\r\n            this.r = 1;\r\n            /**\r\n             * Arc start angle in radians\r\n             * @type {number}\r\n             */\r\n            this.startAngle = 0;\r\n            /**\r\n             * Arc end angle in radians\r\n             * @type {number}\r\n             */\r\n            this.endAngle = 2*Math.PI;\r\n            /**\r\n             * Arc orientation\r\n             * @type {boolean}\r\n             */\r\n            this.counterClockwise = Flatten.CCW;\r\n\r\n            if (args.length == 0)\r\n                return;\r\n\r\n            if (args.length == 1 && args[0] instanceof Object && args[0].name === \"arc\") {\r\n                let {pc, r, startAngle, endAngle, counterClockwise} = args[0];\r\n                this.pc = new Flatten.Point(pc.x, pc.y);\r\n                this.r = r;\r\n                this.startAngle = startAngle;\r\n                this.endAngle = endAngle;\r\n                this.counterClockwise = counterClockwise;\r\n                return;\r\n            }\r\n            else {\r\n                let [pc, r, startAngle, endAngle, counterClockwise] = [...args];\r\n                if (pc && pc instanceof Flatten.Point) this.pc = pc.clone();\r\n                if (r !== undefined) this.r = r;\r\n                if (startAngle !== undefined) this.startAngle = startAngle;\r\n                if (endAngle!== undefined) this.endAngle = endAngle;\r\n                if (counterClockwise !== undefined) this.counterClockwise = counterClockwise;\r\n                return;\r\n            }\r\n\r\n            throw Flatten.Errors.ILLEGAL_PARAMETERS;\r\n        }\r\n\r\n        /**\r\n         * Return new instance of arc\r\n         * @returns {Arc}\r\n         */\r\n        clone() {\r\n            return new Flatten.Arc(this.pc.clone(), this.r, this.startAngle, this.endAngle, this.counterClockwise);\r\n        }\r\n\r\n        /**\r\n         * Get sweep angle in radians. Sweep angle is non-negative number from 0 to 2*PI\r\n         * @returns {number}\r\n         */\r\n        get sweep() {\r\n            if (Flatten.Utils.EQ(this.startAngle, this.endAngle))\r\n                return 0.0;\r\n            if (Flatten.Utils.EQ(Math.abs(this.startAngle - this.endAngle), Flatten.PIx2)) {\r\n                return Flatten.PIx2;\r\n            }\r\n            let sweep;\r\n            if (this.counterClockwise) {\r\n                sweep = Flatten.Utils.GT(this.endAngle, this.startAngle) ?\r\n                    this.endAngle - this.startAngle : this.endAngle - this.startAngle + Flatten.PIx2;\r\n            } else {\r\n                sweep = Flatten.Utils.GT(this.startAngle, this.endAngle) ?\r\n                    this.startAngle - this.endAngle : this.startAngle - this.endAngle + Flatten.PIx2;\r\n            }\r\n\r\n            if ( Flatten.Utils.GT(sweep, Flatten.PIx2) ) {\r\n                sweep -= Flatten.PIx2;\r\n            }\r\n            if ( Flatten.Utils.LT(sweep, 0) ) {\r\n                sweep += Flatten.PIx2;\r\n            }\r\n            return sweep;\r\n        }\r\n\r\n        /**\r\n         * Get start point of arc\r\n         * @returns {Point}\r\n         */\r\n        get start() {\r\n            let p0 = new Flatten.Point(this.pc.x + this.r, this.pc.y);\r\n            return p0.rotate(this.startAngle, this.pc);\r\n        }\r\n\r\n        /**\r\n         * Get end point of arc\r\n         * @returns {Point}\r\n         */\r\n        get end() {\r\n            let p0 = new Flatten.Point(this.pc.x + this.r, this.pc.y);\r\n            return p0.rotate(this.endAngle, this.pc);\r\n        }\r\n\r\n        /**\r\n         * Get center of arc\r\n         * @returns {Point}\r\n         */\r\n        get center() {\r\n            return this.pc.clone();\r\n        }\r\n\r\n        get vertices() {\r\n            return [this.start.clone(), this.end.clone()];\r\n        }\r\n\r\n        /**\r\n         * Get arc length\r\n         * @returns {number}\r\n         */\r\n        get length() {\r\n            return Math.abs(this.sweep*this.r);\r\n        }\r\n\r\n        /**\r\n         * Get bounding box of the arc\r\n         * @returns {Box}\r\n         */\r\n        get box() {\r\n            let func_arcs = this.breakToFunctional();\r\n            let box = func_arcs.reduce( (acc, arc) => acc.merge(arc.start.box), new Flatten.Box() );\r\n            box = box.merge(this.end.box);\r\n            return box;\r\n        }\r\n\r\n        /**\r\n         * Returns true if arc contains point, false otherwise\r\n         * @param {Point} pt - point to test\r\n         * @returns {boolean}\r\n         */\r\n        contains(pt) {\r\n            // first check if  point on circle (pc,r)\r\n            if (!Flatten.Utils.EQ(this.pc.distanceTo(pt)[0], this.r))\r\n                return false;\r\n\r\n            // point on circle\r\n\r\n            if (pt.equalTo(this.start))\r\n                return true;\r\n\r\n            let angle = new Flatten.Vector(this.pc, pt).slope;\r\n            let test_arc = new Flatten.Arc(this.pc, this.r, this.startAngle, angle, this.counterClockwise);\r\n            return Flatten.Utils.LE(test_arc.length, this.length);\r\n        }\r\n\r\n        /**\r\n         * When given point belongs to arc, return array of two arcs split by this point. If points is incident\r\n         * to start or end point of the arc, return clone of the arc. If point does not belong to the arcs, return\r\n         * empty array.\r\n         * @param {Point} pt Query point\r\n         * @returns {Arc[]}\r\n         */\r\n        split(pt) {\r\n            if (!this.contains(pt))\r\n                return [];\r\n\r\n            if (Flatten.Utils.EQ_0(this.sweep))\r\n                return [this.clone()];\r\n\r\n            if (this.start.equalTo(pt) || this.end.equalTo(pt))\r\n                return [this.clone()];\r\n\r\n            let angle = new Flatten.Vector(this.pc, pt).slope;\r\n\r\n            return [\r\n                new Flatten.Arc(this.pc, this.r, this.startAngle, angle, this.counterClockwise),\r\n                new Flatten.Arc(this.pc, this.r, angle, this.endAngle, this.counterClockwise)\r\n            ]\r\n        }\r\n\r\n        /**\r\n         * Return middle point of the arc\r\n         * @returns {Point}\r\n         */\r\n        middle() {\r\n            let endAngle = this.counterClockwise ? this.startAngle + this.sweep/2 : this.startAngle - this.sweep/2;\r\n            let arc = new Flatten.Arc(this.pc, this.r, this.startAngle, endAngle, this.counterClockwise);\r\n            return arc.end;\r\n        }\r\n\r\n        /**\r\n         * Returns chord height (\"sagitta\") of the arc\r\n         * @returns {number}\r\n         */\r\n        chordHeight() {\r\n            return  (1.0 - Math.cos(Math.abs(this.sweep/2.0))) * this.r;\r\n        }\r\n\r\n        /**\r\n         * Returns array of intersection points between arc and other shape\r\n         * @param {Shape} shape Shape of the one of supported types <br/>\r\n         * @returns {Points[]}\r\n         */\r\n        intersect(shape) {\r\n            if (shape instanceof Flatten.Point) {\r\n                return this.contains(shape) ? [shape] : [];\r\n            }\r\n            if (shape instanceof Flatten.Line) {\r\n                return shape.intersect(this);\r\n            }\r\n            if (shape instanceof Flatten.Circle) {\r\n                return Arc.intersectArc2Circle(this, shape);\r\n            }\r\n            if (shape instanceof Flatten.Segment) {\r\n                return shape.intersect(this);\r\n            }\r\n            if (shape instanceof Flatten.Arc) {\r\n                return Arc.intersectArc2Arc(this, shape);\r\n            }\r\n            if (shape instanceof Flatten.Polygon) {\r\n                return Flatten.Polygon.intersectShape2Polygon(this, shape);\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Calculate distance and shortest segment from arc to shape and return array [distance, shortest segment]\r\n         * @param {Shape} shape Shape of the one of supported types Point, Line, Circle, Segment, Arc, Polygon or Planar Set\r\n         * @returns {number} distance from arc to shape\r\n         * @returns {Segment} shortest segment between arc and shape (started at arc, ended at shape)\r\n\r\n         */\r\n        distanceTo(shape) {\r\n            let {Distance} = Flatten;\r\n\r\n            if (shape instanceof Flatten.Point) {\r\n                let [dist, shortest_segment] = Distance.point2arc(shape, this);\r\n                shortest_segment = shortest_segment.reverse();\r\n                return [dist, shortest_segment];\r\n            }\r\n\r\n            if (shape instanceof Flatten.Circle) {\r\n                let [dist, shortest_segment] = Distance.arc2circle(this, shape);\r\n                return [dist, shortest_segment];\r\n            }\r\n\r\n            if (shape instanceof Flatten.Line) {\r\n                let [dist, shortest_segment] = Distance.arc2line(this, shape);\r\n                return [dist, shortest_segment];\r\n            }\r\n\r\n            if (shape instanceof Flatten.Segment) {\r\n                let [dist, shortest_segment] = Distance.segment2arc(shape, this);\r\n                shortest_segment = shortest_segment.reverse();\r\n                return [dist, shortest_segment];\r\n            }\r\n\r\n            if (shape instanceof Flatten.Arc) {\r\n                let [dist, shortest_segment] = Distance.arc2arc(this, shape);\r\n                return [dist, shortest_segment];\r\n            }\r\n\r\n            if (shape instanceof Flatten.Polygon) {\r\n                let [dist, shortest_segment] = Distance.shape2polygon(this, shape);\r\n                return [dist, shortest_segment];\r\n            }\r\n\r\n            if (shape instanceof Flatten.PlanarSet) {\r\n                let [dist, shortest_segment] = Distance.shape2planarSet(this, shape);\r\n                return [dist, shortest_segment];\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Breaks arc in extreme point 0, pi/2, pi, 3*pi/2 and returns array of sub-arcs\r\n         * @returns {Arcs[]}\r\n         */\r\n        breakToFunctional() {\r\n            let func_arcs_array = [];\r\n            let angles = [0, Math.PI/2, 2*Math.PI/2, 3*Math.PI/2];\r\n            let pts = [\r\n                this.pc.translate(this.r,0),\r\n                this.pc.translate(0,this.r),\r\n                this.pc.translate(-this.r,0),\r\n                this.pc.translate(0,-this.r)\r\n            ];\r\n\r\n            // If arc contains extreme point,\r\n            // create test arc started at start point and ended at this extreme point\r\n            let test_arcs = [];\r\n            for (let i=0; i < 4; i++) {\r\n                if (pts[i].on(this)) {\r\n                    test_arcs.push(new Flatten.Arc(this.pc, this.r, this.startAngle, angles[i], this.counterClockwise));\r\n                }\r\n            }\r\n\r\n            if (test_arcs.length == 0) {                  // arc does contain any extreme point\r\n                func_arcs_array.push(this.clone());\r\n            }\r\n            else {                                        // arc passes extreme point\r\n                // sort these arcs by length\r\n                test_arcs.sort((arc1, arc2) => arc1.length - arc2.length);\r\n\r\n                for (let i = 0; i < test_arcs.length; i++) {\r\n                    let prev_arc = func_arcs_array.length > 0 ? func_arcs_array[func_arcs_array.length - 1] : undefined;\r\n                    let new_arc;\r\n                    if (prev_arc) {\r\n                        new_arc = new Flatten.Arc(this.pc, this.r, prev_arc.endAngle, test_arcs[i].endAngle, this.counterClockwise);\r\n                    }\r\n                    else {\r\n                        new_arc = new Flatten.Arc(this.pc, this.r, this.startAngle, test_arcs[i].endAngle, this.counterClockwise);\r\n                    }\r\n                    if (!Flatten.Utils.EQ_0(new_arc.length)) {\r\n                        func_arcs_array.push(new_arc.clone());\r\n                    }\r\n                }\r\n\r\n                // add last sub arc\r\n                let prev_arc = func_arcs_array.length > 0 ? func_arcs_array[func_arcs_array.length - 1] : undefined;\r\n                let new_arc;\r\n                if (prev_arc) {\r\n                    new_arc = new Flatten.Arc(this.pc, this.r, prev_arc.endAngle, this.endAngle, this.counterClockwise);\r\n                }\r\n                else {\r\n                    new_arc = new Flatten.Arc(this.pc, this.r, this.startAngle, this.endAngle, this.counterClockwise);\r\n                }\r\n                if (!Flatten.Utils.EQ_0(new_arc.length)) {\r\n                    func_arcs_array.push(new_arc.clone());\r\n                }\r\n            }\r\n            return func_arcs_array;\r\n        }\r\n\r\n        /**\r\n         * Return tangent unit vector in the start point in the direction from start to end\r\n         * @returns {Vector}\r\n         */\r\n        tangentInStart() {\r\n            let vec = new Flatten.Vector(this.pc, this.start);\r\n            let angle = this.counterClockwise ? Math.PI/2. : -Math.PI/2.;\r\n            let tangent = vec.rotate(angle).normalize();\r\n            return tangent;\r\n        }\r\n\r\n        /**\r\n         * Return tangent unit vector in the end point in the direction from end to start\r\n         * @returns {Vector}\r\n         */\r\n        tangentInEnd() {\r\n            let vec = new Flatten.Vector(this.pc, this.end);\r\n            let angle = this.counterClockwise ? -Math.PI/2. : Math.PI/2.;\r\n            let tangent = vec.rotate(angle).normalize();\r\n            return tangent;\r\n        }\r\n\r\n        /**\r\n         * Returns new arc with swapped start and end angles and reversed direction\r\n         * @returns {Arc}\r\n         */\r\n        reverse() {\r\n            return new Arc(this.pc, this.r, this.endAngle, this.startAngle, !this.counterClockwise);\r\n        }\r\n\r\n        /**\r\n         * Returns new arc translated by vector vec\r\n         * @param {Vector} vec\r\n         * @returns {Segment}\r\n         */\r\n        translate(...args) {\r\n            let arc = this.clone();\r\n            arc.pc = this.pc.translate(...args);\r\n            return arc;\r\n        }\r\n\r\n        /**\r\n         * Return new segment rotated by given angle around given point\r\n         * If point omitted, rotate around origin (0,0)\r\n         * Positive value of angle defines rotation counter clockwise, negative - clockwise\r\n         * @param {number} angle - rotation angle in radians\r\n         * @param {Point} center - center point, default is (0,0)\r\n         * @returns {Arc}\r\n         */\r\n        rotate(angle = 0, center = new Flatten.Point()) {\r\n            let m = new Flatten.Matrix();\r\n            m = m.translate(center.x, center.y).rotate(angle).translate(-center.x, -center.y);\r\n            return this.transform(m);\r\n        }\r\n\r\n        /**\r\n         * Return new arc transformed using affine transformation matrix <br/>\r\n         * Note, that non-equal scaling by x and y (matrix[0] != matrix[3]) produce illegal result\r\n         * TODO: support non-equal scaling arc to ellipse or throw exception ?\r\n         * @param {Matrix} matrix - affine transformation matrix\r\n         * @returns {Arc}\r\n         */\r\n        transform(matrix = new Flatten.Matrix()) {\r\n            let newStart = this.start.transform(matrix);\r\n            let newEnd = this.end.transform(matrix);\r\n            let newCenter = this.pc.transform(matrix);\r\n            let arc = Arc.arcSE(newCenter, newStart, newEnd, this.counterClockwise);\r\n            return arc;\r\n        }\r\n\r\n        static arcSE(center, start, end, counterClockwise) {\r\n            let {vector} = Flatten;\r\n            let startAngle = vector(center,start).slope;\r\n            let endAngle = vector(center, end).slope;\r\n            if (Flatten.Utils.EQ(startAngle, endAngle)) {\r\n                endAngle += 2*Math.PI;\r\n                counterClockwise = true;\r\n            }\r\n            let r = vector(center, start).length;\r\n\r\n            return new Arc(center, r, startAngle, endAngle, counterClockwise);\r\n        }\r\n\r\n        static intersectArc2Arc(arc1, arc2) {\r\n            var ip = [];\r\n\r\n            if (arc1.box.not_intersect(arc2.box)) {\r\n                return ip;\r\n            }\r\n\r\n            // Special case: overlapping arcs\r\n            // May return up to 4 intersection points\r\n            if (arc1.pc.equalTo(arc2.pc) && Flatten.Utils.EQ(arc1.r, arc2.r)) {\r\n                let pt;\r\n\r\n                pt = arc1.start;\r\n                if (pt.on(arc2))\r\n                    ip.push(pt);\r\n\r\n                pt = arc1.end;\r\n                if (pt.on(arc2))\r\n                    ip.push(pt);\r\n\r\n                pt = arc2.start;\r\n                if (pt.on(arc1)) ip.push(pt);\r\n\r\n                pt = arc2.end;\r\n                if (pt.on(arc1)) ip.push(pt);\r\n\r\n                return ip;\r\n            }\r\n\r\n            // Common case\r\n            let circle1 = new Flatten.Circle(arc1.pc, arc1.r);\r\n            let circle2 = new Flatten.Circle(arc2.pc, arc2.r);\r\n            let ip_tmp =  circle1.intersect(circle2);\r\n            for (let pt of ip_tmp) {\r\n                if (pt.on(arc1) && pt.on(arc2)) {\r\n                    ip.push(pt);\r\n                }\r\n            }\r\n            return ip;\r\n        }\r\n\r\n        static intersectArc2Circle(arc, circle) {\r\n            let ip = [];\r\n\r\n            if (arc.box.not_intersect(circle.box)) {\r\n                return ip;\r\n            }\r\n\r\n            // Case when arc center incident to circle center\r\n            // Return arc's end points as 2 intersection points\r\n            if (circle.pc.equalTo(arc.pc) && Flatten.Utils.EQ(circle.r, arc.r)) {\r\n                ip.push(arc.start);\r\n                ip.push(arc.end);\r\n                return ip;\r\n            }\r\n\r\n            // Common case\r\n            let circle1 = circle;\r\n            let circle2 = new Flatten.Circle(arc.pc, arc.r);\r\n            let ip_tmp = circle1.intersect(circle2);\r\n            for (let pt of ip_tmp) {\r\n                if (pt.on(arc)) {\r\n                    ip.push(pt);\r\n                }\r\n            }\r\n            return ip;\r\n        }\r\n\r\n        definiteIntegral(ymin=0) {\r\n            let f_arcs = this.breakToFunctional();\r\n            let area = f_arcs.reduce( (acc, arc) => acc + arc.circularSegmentDefiniteIntegral(ymin), 0.0 );\r\n            return area;\r\n        }\r\n\r\n        circularSegmentDefiniteIntegral(ymin) {\r\n            let line = new Flatten.Line(this.start, this.end);\r\n            let onLeftSide = this.pc.leftTo(line);\r\n            let segment = new Flatten.Segment(this.start, this.end);\r\n            let areaTrapez = segment.definiteIntegral(ymin);\r\n            let areaCircularSegment = this.circularSegmentArea();\r\n            let area = onLeftSide ? areaTrapez - areaCircularSegment : areaTrapez + areaCircularSegment;\r\n            return area;\r\n        }\r\n\r\n        circularSegmentArea() {\r\n            return (0.5*this.r*this.r*(this.sweep - Math.sin(this.sweep)))\r\n        }\r\n\r\n        /**\r\n         * Return string to draw arc in svg\r\n         * @param {Object} attrs - an object with attributes of svg path element,\r\n         * like \"stroke\", \"strokeWidth\", \"fill\" <br/>\r\n         * Defaults are stroke:\"black\", strokeWidth:\"1\", fill:\"none\"\r\n         * @returns {string}\r\n         */\r\n        svg(attrs = {}) {\r\n            let largeArcFlag = this.sweep <= Math.PI ? \"0\" : \"1\";\r\n            let sweepFlag = this.counterClockwise ? \"1\" : \"0\";\r\n            let {stroke, strokeWidth, fill, id, className} = attrs;\r\n            // let rest_str = Object.keys(rest).reduce( (acc, key) => acc += ` ${key}=\"${rest[key]}\"`, \"\");\r\n            let id_str = (id && id.length > 0) ? `id=\"${id}\"` : \"\";\r\n            let class_str = (className && className.length > 0) ? `class=\"${className}\"` : \"\";\r\n\r\n            if (Flatten.Utils.EQ(this.sweep, 2*Math.PI)) {\r\n                let circle = new Flatten.Circle(this.pc, this.r);\r\n                return circle.svg(attrs);\r\n            }\r\n            else {\r\n                return `\\n<path d=\"M${this.start.x},${this.start.y}\r\n                             A${this.r},${this.r} 0 ${largeArcFlag},${sweepFlag} ${this.end.x},${this.end.y}\"\r\n                    stroke=\"${stroke || \"black\"}\" stroke-width=\"${strokeWidth || 1}\" fill=\"${fill || \"none\"}\" ${id_str} ${class_str} />`\r\n            }\r\n        }\r\n\r\n        /**\r\n         * This method returns an object that defines how data will be\r\n         * serialized when called JSON.stringify() method\r\n         * @returns {Object}\r\n         */\r\n        toJSON() {\r\n            return Object.assign({},this,{name:\"arc\"});\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Function to create arc equivalent to \"new\" constructor\r\n     * @param args\r\n     */\r\n    Flatten.arc = (...args) => new Flatten.Arc(...args);\r\n};","/**\r\n * Created by Alex Bol on 3/7/2017.\r\n */\r\n\"use strict\";\r\n\r\nmodule.exports = function(Flatten) {\r\n    /**\r\n     * Class Box represent bounding box of the shape\r\n     * @type {Box}\r\n     */\r\n    Flatten.Box = class Box {\r\n        /**\r\n         *\r\n         * @param {number} xmin - minimal x coordinate\r\n         * @param {number} ymin - minimal y coordinate\r\n         * @param {number} xmax - maximal x coordinate\r\n         * @param {number} ymax - maximal y coordinate\r\n         */\r\n        constructor(xmin=undefined, ymin=undefined, xmax=undefined, ymax=undefined) {\r\n            /**\r\n             * Minimal x coordinate\r\n             * @type {number}\r\n             */\r\n            this.xmin = xmin;\r\n            /**\r\n             * Minimal y coordinate\r\n             * @type {number}\r\n             */\r\n            this.ymin = ymin;\r\n            /**\r\n             * Maximal x coordinate\r\n             * @type {number}\r\n             */\r\n            this.xmax = xmax;\r\n            /**\r\n             * Maximal y coordinate\r\n             * @type {number}\r\n             */\r\n            this.ymax = ymax;\r\n        }\r\n\r\n        /**\r\n         * Clones and returns new instance of box\r\n         * @returns {Box}\r\n         */\r\n        clone() {\r\n            return new Box(this.xmin, this.ymin, this.xmax, this.ymax);\r\n        }\r\n\r\n        /**\r\n         * Property low need for interval tree interface\r\n         * @returns {Point}\r\n         */\r\n        get low() {\r\n            return new Flatten.Point(this.xmin, this.ymin);\r\n        }\r\n\r\n        /**\r\n         * Property high need for interval tree interface\r\n         * @returns {Point}\r\n         */\r\n        get high() {\r\n            return new Flatten.Point(this.xmax, this.ymax);\r\n        }\r\n\r\n        /**\r\n         * Property max returns the box itself !\r\n         * @returns {Box}\r\n         */\r\n        get max() {\r\n            return this.clone();\r\n        }\r\n\r\n        /**\r\n         * Return center of the box\r\n         * @returns {Point}\r\n         */\r\n        get center() {\r\n            return new Flatten.Point( (this.xmin + this.xmax)/2, (this.ymin + this.ymax)/2 );\r\n        }\r\n\r\n        /**\r\n         * Returns true if not intersected with other box\r\n         * @param {Box} other_box - other box to test\r\n         * @returns {boolean}\r\n         */\r\n        not_intersect(other_box) {\r\n            return (\r\n                this.xmax < other_box.xmin ||\r\n                this.xmin > other_box.xmax ||\r\n                this.ymax < other_box.ymin ||\r\n                this.ymin > other_box.ymax\r\n            );\r\n        }\r\n\r\n        /**\r\n         * Returns true if intersected with other box\r\n         * @param {Box} other_box - Query box\r\n         * @returns {boolean}\r\n         */\r\n        intersect(other_box) {\r\n            return !this.not_intersect(other_box);\r\n        }\r\n\r\n        /**\r\n         * Returns new box merged with other box\r\n         * @param {Box} other_box - Other box to merge with\r\n         * @returns {Box}\r\n         */\r\n        merge(other_box) {\r\n            return new Box(\r\n                this.xmin === undefined ? other_box.xmin : Math.min(this.xmin, other_box.xmin),\r\n                this.ymin === undefined ? other_box.ymin : Math.min(this.ymin, other_box.ymin),\r\n                this.xmax === undefined ? other_box.xmax : Math.max(this.xmax, other_box.xmax),\r\n                this.ymax === undefined ? other_box.ymax : Math.max(this.ymax, other_box.ymax)\r\n            );\r\n        }\r\n\r\n        /**\r\n         * Defines predicate \"less than\" between two boxes. Need for interval index\r\n         * @param {Box} other_box - other box\r\n         * @returns {boolean} - true if this box less than other box, false otherwise\r\n         */\r\n        less_than(other_box) {\r\n            if (this.low.lessThan(other_box.low))\r\n                return true;\r\n            if (this.low.equalTo(other_box.low) && this.high.lessThan(other_box.high))\r\n                return true;\r\n            return false;\r\n        }\r\n\r\n        /**\r\n         * Returns true if this box is equal to other box, false otherwise\r\n         * @param {Box} other_box - query box\r\n         * @returns {boolean}\r\n         */\r\n        equal_to(other_box) {\r\n            return (this.low.equalTo(other_box.low) && this.high.equalTo(other_box.high));\r\n        }\r\n\r\n        output() {\r\n            return this.clone();\r\n        }\r\n\r\n        maximal_val(box1, box2) {\r\n            // return pt1.lessThan(pt2) ? pt2.clone() : pt1.clone();\r\n            return box1.merge(box2);\r\n        }\r\n\r\n        val_less_than(pt1, pt2) {\r\n            return pt1.lessThan(pt2);\r\n        }\r\n\r\n        /**\r\n         * Set new values to the box object\r\n         * @param {number} xmin - miminal x coordinate\r\n         * @param {number} ymin - minimal y coordinate\r\n         * @param {number} xmax - maximal x coordinate\r\n         * @param {number} ymax - maximal y coordinate\r\n         */\r\n        set(xmin, ymin, xmax, ymax) {\r\n            this.xmin = xmin;\r\n            this.ymin = ymin;\r\n            this.xmax = xmax;\r\n            this.ymax = ymax;\r\n        }\r\n\r\n        /**\r\n         * Return string to draw circle in svg\r\n         * @param {Object} attrs - an object with attributes of svg rectangle element,\r\n         * like \"stroke\", \"strokeWidth\", \"fill\" <br/>\r\n         * Defaults are stroke:\"black\", strokeWidth:\"1\", fill:\"none\"\r\n         * @returns {string}\r\n         */\r\n        svg(attrs = {}) {\r\n            let {stroke, strokeWidth, fill, id, className} = attrs;\r\n            // let rest_str = Object.keys(rest).reduce( (acc, key) => acc += ` ${key}=\"${rest[key]}\"`, \"\");\r\n            let id_str = (id && id.length > 0) ? `id=\"${id}\"` : \"\";\r\n            let class_str = (className && className.length > 0) ? `class=\"${className}\"` : \"\";\r\n            let width = this.xmax - this.xmin;\r\n            let height = this.ymax - this.ymin;\r\n\r\n            return `\\n<rect x=\"${this.xmin}\" y=\"${this.ymin}\" width=${width} height=${height} stroke=\"${stroke || \"black\"}\" stroke-width=\"${strokeWidth || 1}\" fill=\"${fill || \"none\"}\" ${id_str} ${class_str} />`;\r\n        };\r\n    };\r\n\r\n    /**\r\n     * Shortcut to create new circle\r\n     * @param args\r\n     * @returns {Box}\r\n     */\r\n    Flatten.box = (...args) => new Flatten.Box(...args);\r\n\r\n};\r\n","/**\r\n * Created by Alex Bol on 3/17/2017.\r\n */\r\n\r\nmodule.exports = function(Flatten) {\r\n    /**\r\n     * Class representing an edge of polygon. Edge shape may be Segment or Arc.\r\n     * Each edge contains references to the next and previous edges in the face of the polygon.\r\n     *\r\n     * @type {Edge}\r\n     */\r\n    Flatten.Edge = class Edge {\r\n        /**\r\n         * Construct new instance of edge\r\n         * @param {Shape} shape Shape of type Segment of Arc\r\n         */\r\n        constructor(shape) {\r\n            /**\r\n             * Shape of the edge: Segment or Arc\r\n             */\r\n            this.shape = shape;\r\n            /**\r\n             * Pointer to the next edge in the face\r\n             */\r\n            this.next;\r\n            /**\r\n             * Pointer to the previous edge in the face\r\n             */\r\n            this.prev;\r\n            /**\r\n             * Pointer to the face containing this edge\r\n             * @type {Face}\r\n             */\r\n            this.face;\r\n            /**\r\n             * \"Arc distance\" from the face start\r\n             * @type {number}\r\n             */\r\n            this.arc_length = 0;\r\n            /**\r\n             * Start inclusion flag (inside/outside/boundary)\r\n             * @type {Boolean}\r\n             */\r\n            this.bvStart = undefined;\r\n            /**\r\n             * End inclusion flag (inside/outside/boundary)\r\n             * @type {Boolean}\r\n             */\r\n            this.bvEnd = undefined;\r\n            /**\r\n             * Edge inclusion flag (Flatten.INSIDE, Flatten.OUTSIDE, Flatten.BOUNDARY)\r\n             * @type {*}\r\n             */\r\n            this.bv = undefined;\r\n            /**\r\n             * Overlap flag for boundary edge (Flatten.OVERLAP_SAME/Flatten.OVERLAP_OPPOSITE)\r\n             * @type {*}\r\n             */\r\n            this.overlap = undefined;\r\n        }\r\n\r\n        /**\r\n         * Get edge start point\r\n         */\r\n        get start() {\r\n            return this.shape.start;\r\n        }\r\n\r\n        /**\r\n         * Get edge end point\r\n         */\r\n        get end() {\r\n            return this.shape.end;\r\n        }\r\n\r\n        /**\r\n         * Get edge length\r\n         */\r\n        get length() {\r\n            return this.shape.length;\r\n        }\r\n\r\n        /**\r\n         * Get bounding box of the edge\r\n         * @returns {Box}\r\n         */\r\n        get box() {\r\n            return this.shape.box;\r\n        }\r\n\r\n        isSegment() {\r\n            return this.shape instanceof Flatten.Segment;\r\n        }\r\n\r\n        isArc() {\r\n            return this.shape instanceof Flatten.Arc;\r\n        }\r\n        /**\r\n         * Get middle point of the edge\r\n         * @returns {Point}\r\n         */\r\n        middle() {\r\n            return this.shape.middle();\r\n        }\r\n\r\n        /**\r\n         * Returns true if point belongs to the edge, false otherwise\r\n         * @param {Point} pt - test point\r\n         */\r\n        contains(pt) {\r\n            return this.shape.contains(pt);\r\n        }\r\n\r\n        /**\r\n         * Set inclusion flag of the edge with respect to another polygon\r\n         * Inclusion flag is one of Flatten.INSIDE, Flatten.OUTSIDE, Flatten.BOUNDARY\r\n         * @param polygon\r\n         */\r\n        setInclusion(polygon) {\r\n            if (this.bv !== undefined) return this.bv;\r\n\r\n            if (this.bvStart === undefined) {\r\n                this.bvStart = Flatten.ray_shoot(polygon, this.start);\r\n            }\r\n            if (this.bvEnd === undefined) {\r\n                this.bvEnd = Flatten.ray_shoot(polygon, this.end);\r\n            }\r\n            /* At least one end outside - the whole edge outside */\r\n            if (this.bvStart === Flatten.OUTSIDE || this.bvEnd == Flatten.OUTSIDE) {\r\n                this.bv = Flatten.OUTSIDE;\r\n            }\r\n            /* At least one end inside - the whole edge inside */\r\n            else if (this.bvStart === Flatten.INSIDE || this.bvEnd == Flatten.INSIDE) {\r\n                this.bv = Flatten.INSIDE;\r\n            }\r\n            /* Both are boundary - check the middle point */\r\n            else {\r\n                let bvMiddle = Flatten.ray_shoot(polygon, this.middle());\r\n                this.bv = bvMiddle;\r\n            }\r\n            return this.bv;\r\n        }\r\n\r\n        /**\r\n         * Set overlapping between two coincident boundary edges\r\n         * Overlapping flag is one of Flatten.OVERLAP_SAME or Flatten.OVERLAP_OPPOSITE\r\n         * @param edge\r\n         */\r\n        setOverlap(edge) {\r\n            let flag = undefined;\r\n            let shape1 = this.shape;\r\n            let shape2 = edge.shape;\r\n\r\n            if (shape1 instanceof Flatten.Segment && shape2 instanceof Flatten.Segment) {\r\n                if (shape1.start.equalTo(shape2.start) && shape1.end.equalTo(shape2.end)) {\r\n                    flag = Flatten.OVERLAP_SAME;\r\n                }\r\n                else if (shape1.start.equalTo(shape2.end) && shape1.end.equalTo(shape2.start)) {\r\n                    flag = Flatten.OVERLAP_OPPOSITE;\r\n                }\r\n            }\r\n            else if (shape1 instanceof Flatten.Arc && shape2 instanceof Flatten.Arc) {\r\n                if (shape1.start.equalTo(shape2.start) && shape1.end.equalTo(shape2.end) && /*shape1.counterClockwise === shape2.counterClockwise &&*/\r\n                    shape1.middle().equalTo(shape2.middle())) {\r\n                    flag = Flatten.OVERLAP_SAME;\r\n                }\r\n                else if (shape1.start.equalTo(shape2.end) && shape1.end.equalTo(shape2.start) && /*shape1.counterClockwise !== shape2.counterClockwise &&*/\r\n                    shape1.middle().equalTo(shape2.middle())) {\r\n                    flag = Flatten.OVERLAP_OPPOSITE;\r\n                }\r\n            }\r\n            else if (shape1 instanceof Flatten.Segment && shape2 instanceof Flatten.Arc ||\r\n                shape1 instanceof Flatten.Arc && shape2 instanceof Flatten.Segment) {\r\n                if (shape1.start.equalTo(shape2.start) && shape1.end.equalTo(shape2.end) && shape1.middle().equalTo(shape2.middle())) {\r\n                    flag = Flatten.OVERLAP_SAME;\r\n                }\r\n                else if (shape1.start.equalTo(shape2.end) && shape1.end.equalTo(shape2.start) && shape1.middle().equalTo(shape2.middle())) {\r\n                    flag = Flatten.OVERLAP_OPPOSITE;\r\n                }\r\n            }\r\n\r\n            /* Do not update overlap flag if already set on previous chain */\r\n            if (this.overlap === undefined) this.overlap = flag;\r\n            if (edge.overlap === undefined) edge.overlap = flag;\r\n        }\r\n\r\n        svg() {\r\n            if (this.shape instanceof Flatten.Segment) {\r\n                return ` L${this.shape.end.x},${this.shape.end.y}`;\r\n            }\r\n            else if (this.shape instanceof  Flatten.Arc) {\r\n                let arc = this.shape;\r\n                let largeArcFlag;\r\n                let sweepFlag = arc.counterClockwise ? \"1\" : \"0\";\r\n\r\n                // Draw full circe arc as special case: split it into two half-circles\r\n                if (Flatten.Utils.EQ(arc.sweep, 2*Math.PI)) {\r\n                    let sign = arc.counterClockwise ? 1 : -1;\r\n                    let halfArc1 = new Flatten.Arc(arc.pc, arc.r, arc.startAngle, arc.startAngle + sign*Math.PI, arc.counterClockwise);\r\n                    let halfArc2 = new Flatten.Arc(arc.pc, arc.r, arc.startAngle + sign*Math.PI, arc.endAngle, arc.counterClockwise);\r\n\r\n                    largeArcFlag = \"0\";\r\n\r\n                    return ` A${halfArc1.r},${halfArc1.r} 0 ${largeArcFlag},${sweepFlag} ${halfArc1.end.x},${halfArc1.end.y}\r\n                    A${halfArc2.r},${halfArc2.r} 0 ${largeArcFlag},${sweepFlag} ${halfArc2.end.x},${halfArc2.end.y}`\r\n                }\r\n                else {\r\n                    largeArcFlag = arc.sweep <= Math.PI ? \"0\" : \"1\";\r\n\r\n                    return ` A${arc.r},${arc.r} 0 ${largeArcFlag},${sweepFlag} ${arc.end.x},${arc.end.y}`;\r\n                }\r\n            }\r\n        }\r\n\r\n        toJSON() {\r\n            return this.shape.toJSON();\r\n        }\r\n    };\r\n};","/**\r\n * Created by Alex Bol on 3/17/2017.\r\n */\r\n\r\n\r\n\"use strict\";\r\n\r\nmodule.exports = function (Flatten) {\r\n    let {Point, point, Segment, segment, Arc, Box, Edge, Circle} = Flatten;\r\n\r\n    /**\r\n     * Class representing a face (closed loop) in a [polygon]{@link Flatten.Polygon} object.\r\n     * Face is a circular bidirectional linked list of [edges]{@link Flatten.Edge}.\r\n     * Face object cannot be instantiated with a constructor.\r\n     * Instead, use [polygon.addFace()]{@link Flatten.Polygon#addFace} method.\r\n     * <br/>\r\n     * Note, that face only set entry point to the linked list of edges but does not contain edges by itself.\r\n     * Container of edges is a property of the polygon object. <br/>\r\n     *\r\n     * @example\r\n     * // Face implements \"next\" iterator which enables to iterate edges in for loop:\r\n     * for (let edge of face) {\r\n     *      console.log(edge.shape.length)     // do something\r\n     * }\r\n     *\r\n     * // Instead, it is possible to iterate edges as linked list, starting from face.first:\r\n     * let edge = face.first;\r\n     * do {\r\n     *   console.log(edge.shape.length);   // do something\r\n     *   edge = edge.next;\r\n     * } while (edge != face.first)\r\n     */\r\n    Flatten.Face = class Face {\r\n        constructor(polygon, ...args) {\r\n            /**\r\n             * Reference to the first edge in face\r\n             */\r\n            this.first;\r\n            /**\r\n             * Reference to the last edge in face\r\n             */\r\n            this.last;\r\n\r\n            this._box = undefined;  // new Box();\r\n            this._orientation = undefined;\r\n\r\n            if (args.length == 0) {\r\n                return;\r\n            }\r\n\r\n            /* If passed an array it supposed to be:\r\n             1) array of shapes that performs close loop or\r\n             2) array of points that performs set of vertices\r\n             */\r\n            if (args.length == 1) {\r\n                if (args[0] instanceof Array) {\r\n                    // let argsArray = args[0];\r\n                    let shapes = args[0];  // argsArray[0];\r\n                    if (shapes.length == 0)\r\n                        return;\r\n\r\n                    if (shapes.every((shape) => {\r\n                            return shape instanceof Point\r\n                        })) {\r\n                        let segments = Face.points2segments(shapes);\r\n                        this.shapes2face(polygon.edges, segments);\r\n                    }\r\n                    else if (shapes.every((shape) => {\r\n                            return (shape instanceof Segment || shape instanceof Arc)\r\n                        })) {\r\n                        this.shapes2face(polygon.edges, shapes);\r\n                    }\r\n                    // this is from JSON.parse object\r\n                    else if (shapes.every((shape) => {\r\n                            return (shape.name === \"segment\" || shape.name === \"arc\")\r\n                        })) {\r\n                        let flattenShapes = [];\r\n                        for (let shape of shapes) {\r\n                            let flattenShape;\r\n                            if (shape.name === \"segment\") {\r\n                                flattenShape = new Segment(shape);\r\n                            }\r\n                            else {\r\n                                flattenShape = new Arc(shape);\r\n                            }\r\n                            flattenShapes.push(flattenShape);\r\n                        }\r\n                        this.shapes2face(polygon.edges, flattenShapes);\r\n                    }\r\n                }\r\n                /* Create new face and copy edges into polygon.edges set */\r\n                else if (args[0] instanceof Face) {\r\n                    let face = args[0];\r\n                    this.first = face.first;\r\n                    this.last = face.last;\r\n                    for (let edge of face) {\r\n                        polygon.edges.add(edge);\r\n                    }\r\n                }\r\n                /* Instantiate face from circle circle in CCW orientation */\r\n                else if (args[0] instanceof Circle) {\r\n                    this.shapes2face(polygon.edges, [args[0].toArc(Flatten.CCW)]);\r\n                }\r\n                /* Instantiate face from a box in CCW orientation */\r\n                else if (args[0] instanceof Box) {\r\n                    let box = args[0];\r\n                    this.shapes2face(polygon.edges, [\r\n                        segment(point(box.xmin, box.ymin), point(box.xmax, box.ymin)),\r\n                        segment(point(box.xmax, box.ymin), point(box.xmax, box.ymax)),\r\n                        segment(point(box.xmax, box.ymax), point(box.xmin, box.ymax)),\r\n                        segment(point(box.xmin, box.ymax), point(box.xmin, box.ymin))\r\n                    ]);\r\n                }\r\n            }\r\n            /* If passed two edges, consider them as start and end of the face loop */\r\n            /* THIS METHOD WILL BE USED BY BOOLEAN OPERATIONS */\r\n            /* Assume that edges already copied to polygon.edges set in the clip algorithm !!! */\r\n            if (args.length == 2 && args[0] instanceof Edge && args[1] instanceof Edge) {\r\n                this.first = args[0];                          // first edge in face or undefined\r\n                this.last = args[1];                           // last edge in face or undefined\r\n                this.last.next = this.first;\r\n                this.first.prev = this.last;\r\n\r\n                // set arc length\r\n                this.setArcLength();\r\n                /*\r\n                 let edge = this.first;\r\n                 edge.arc_length = 0;\r\n                 edge = edge.next;\r\n                 while (edge !== this.first) {\r\n                 edge.arc_length = edge.prev.arc_length + edge.prev.length;\r\n                 edge = edge.next;\r\n                 }\r\n                 */\r\n\r\n                // this.box = this.getBox();\r\n                // this.orientation = this.getOrientation();      // face direction cw or ccw\r\n            }\r\n        }\r\n\r\n        [Symbol.iterator]() {\r\n            let edge = undefined;\r\n            return {\r\n                next: () => {\r\n                    let value = edge ? edge : this.first;\r\n                    let done = this.first ? (edge ? edge === this.first : false) : true;\r\n                    edge = value ? value.next : undefined;\r\n                    return {value: value, done: done};\r\n                }\r\n            };\r\n        };\r\n\r\n        /**\r\n         * Return array of edges from first to last\r\n         * @returns {Array}\r\n         */\r\n        get edges() {\r\n            let face_edges = [];\r\n            for (let edge of this) {\r\n                face_edges.push(edge);\r\n            }\r\n            return face_edges;\r\n        }\r\n\r\n        /**\r\n         * Return number of edges in the face\r\n         * @returns {number}\r\n         */\r\n        get size() {\r\n            let counter = 0;\r\n            for (let edge of this) {\r\n                counter++;\r\n            }\r\n            return counter;\r\n        }\r\n\r\n        /**\r\n         * Return bounding box of the face\r\n         * @returns {Box}\r\n         */\r\n        get box() {\r\n            if (this._box === undefined) {\r\n                let box = new Flatten.Box();\r\n                for (let edge of this) {\r\n                    box = box.merge(edge.box);\r\n                }\r\n                this._box = box;\r\n            }\r\n            return this._box;\r\n        }\r\n\r\n        static points2segments(points) {\r\n            let segments = [];\r\n            for (let i = 0; i < points.length; i++) {\r\n                segments.push(new Segment(points[i], points[(i + 1) % points.length]));\r\n            }\r\n            return segments;\r\n        }\r\n\r\n        shapes2face(edges, shapes) {\r\n            for (let shape of shapes) {\r\n                let edge = new Edge(shape);\r\n                this.append(edges, edge);\r\n                // this.box = this.box.merge(shape.box);\r\n                // edges.add(edge);\r\n            }\r\n            // this.orientation = this.getOrientation();              // face direction cw or ccw\r\n        }\r\n\r\n        /**\r\n         * Returns true if face is empty, false otherwise\r\n         * @returns {boolean}\r\n         */\r\n        isEmpty() {\r\n            return (this.first === undefined && this.last === undefined)\r\n        }\r\n\r\n        /**\r\n         * Append given edge after the last edge (and before the first edge). <br/>\r\n         * This method mutates current object and does not return any value\r\n         * @param {PlanarSet} edges - Container of edges\r\n         * @param {Edge} edge - Edge to be appended to the linked list\r\n         */\r\n        append(edges, edge) {\r\n            if (this.first === undefined) {\r\n                edge.prev = edge;\r\n                edge.next = edge;\r\n                this.first = edge;\r\n                this.last = edge;\r\n                edge.arc_length = 0;\r\n            }\r\n            else {\r\n                // append to end\r\n                edge.prev = this.last;\r\n                this.last.next = edge;\r\n\r\n                // update edge to be last\r\n                this.last = edge;\r\n\r\n                // restore circular links\r\n                this.last.next = this.first;\r\n                this.first.prev = this.last;\r\n\r\n                // set arc length\r\n                edge.arc_length = edge.prev.arc_length + edge.prev.length;\r\n            }\r\n            edge.face = this;\r\n\r\n            edges.add(edge);      // Add new edges into edges container\r\n        }\r\n\r\n        /**\r\n         * Insert edge newEdge into the linked list after the edge edgeBefore <br/>\r\n         * This method mutates current object and does not return any value\r\n         * @param {PlanarSet} edges - Container of edges\r\n         * @param {Edge} newEdge - Edge to be inserted into linked list\r\n         * @param {Edge} edgeBefore - Edge to insert newEdge after it\r\n         */\r\n        insert(edges, newEdge, edgeBefore) {\r\n            if (this.first === undefined) {\r\n                newEdge.prev = newEdge;\r\n                newEdge.next = newEdge;\r\n                this.first = newEdge;\r\n                this.last = newEdge;\r\n            }\r\n            else {\r\n                /* set links to new edge */\r\n                let edgeAfter = edgeBefore.next;\r\n                edgeBefore.next = newEdge;\r\n                edgeAfter.prev = newEdge;\r\n\r\n                /* set links from new edge */\r\n                newEdge.prev = edgeBefore;\r\n                newEdge.next = edgeAfter;\r\n\r\n                /* extend chain if new edge added after last edge */\r\n                if (this.last === edgeBefore)\r\n                    this.first = newEdge;\r\n            }\r\n            newEdge.face = this;\r\n\r\n            // set arc length\r\n            if (newEdge.prev === this.last) {\r\n                newEdge.arc_length = 0;\r\n            }\r\n            else {\r\n                newEdge.arc_length = newEdge.prev.arc_length + newEdge.prev.length;\r\n            }\r\n\r\n            edges.add(newEdge);      // Add new edges into edges container\r\n        }\r\n\r\n        /**\r\n         * Remove the given edge from the linked list of the face <br/>\r\n         * This method mutates current object and does not return any value\r\n         * @param {PlanarSet} edges - Container of edges\r\n         * @param {Edge} edge - Edge to be removed\r\n         */\r\n        remove(edges, edge) {\r\n            // special case if last edge removed\r\n            if (edge === this.first && edge === this.last) {\r\n                this.first = undefined;\r\n                this.last = undefined;\r\n            }\r\n            else {\r\n                // update linked list\r\n                edge.prev.next = edge.next;\r\n                edge.next.prev = edge.prev;\r\n                // update first if need\r\n                if (edge === this.first) {\r\n                    this.first = edge.next;\r\n                }\r\n                // update last if need\r\n                if (edge === this.last) {\r\n                    this.last = edge.prev;\r\n                }\r\n            }\r\n            edges.delete(edge);      // delete from PlanarSet of edges and update index\r\n        }\r\n\r\n        /**\r\n         * Reverse orientation of the face: first edge become last and vice a verse,\r\n         * all edges starts and ends swapped, direction of arcs inverted.\r\n         */\r\n        reverse() {\r\n            // collect edges in revert order with reverted shapes\r\n            let edges = [];\r\n            let edge_tmp = this.last;\r\n            do {\r\n                // reverse shape\r\n                edge_tmp.shape = edge_tmp.shape.reverse();\r\n                edges.push(edge_tmp);\r\n                edge_tmp = edge_tmp.prev;\r\n            } while (edge_tmp !== this.last);\r\n\r\n            // restore linked list\r\n            this.first = undefined;\r\n            this.last = undefined;\r\n            for (let edge of edges) {\r\n                if (this.first === undefined) {\r\n                    edge.prev = edge;\r\n                    edge.next = edge;\r\n                    this.first = edge;\r\n                    this.last = edge;\r\n                    edge.arc_length = 0;\r\n                }\r\n                else {\r\n                    // append to end\r\n                    edge.prev = this.last;\r\n                    this.last.next = edge;\r\n\r\n                    // update edge to be last\r\n                    this.last = edge;\r\n\r\n                    // restore circular links\r\n                    this.last.next = this.first;\r\n                    this.first.prev = this.last;\r\n\r\n                    // set arc length\r\n                    edge.arc_length = edge.prev.arc_length + edge.prev.length;\r\n                }\r\n            }\r\n\r\n            // Recalculate orientation, if set\r\n            if (this._orientation !== undefined) {\r\n                this._orientation = undefined;\r\n                this._orientation = this.orientation();\r\n            }\r\n        }\r\n\r\n\r\n        /**\r\n         * Set arc_length property for each of the edges in the face.\r\n         * Arc_length of the edge it the arc length from the first edge of the face\r\n         */\r\n        setArcLength() {\r\n            for (let edge of this) {\r\n                if (edge === this.first) {\r\n                    edge.arc_length = 0.0;\r\n                }\r\n                else {\r\n                    edge.arc_length = edge.prev.arc_length + edge.prev.length;\r\n                }\r\n                edge.face = this;\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Returns the absolute value of the area of the face\r\n         * @returns {number}\r\n         */\r\n        area() {\r\n            return Math.abs(this.signedArea());\r\n        }\r\n\r\n        /**\r\n         * Returns signed area of the simple face.\r\n         * Face is simple if it has no self intersections that change its orientation.\r\n         * Then the area will be positive if the orientation of the face is clockwise,\r\n         * and negative if orientation is counterclockwise.\r\n         * It may be zero if polygon is degenerated.\r\n         * @returns {number}\r\n         */\r\n        signedArea() {\r\n            let sArea = 0;\r\n            let ymin = this.box.ymin;\r\n            for (let edge of this) {\r\n                sArea += edge.shape.definiteIntegral(ymin);\r\n            }\r\n            return sArea;\r\n        }\r\n\r\n        /**\r\n         * Return face orientation: one of Flatten.ORIENTATION.CCW, Flatten.ORIENTATION.CW, Flatten.ORIENTATION.NOT_ORIENTABLE <br/>\r\n         * According to Green theorem the area of a closed curve may be calculated as double integral,\r\n         * and the sign of the integral will be defined by the direction of the curve.\r\n         * When the integral (\"signed area\") will be negative, direction is counter clockwise,\r\n         * when positive - clockwise and when it is zero, polygon is not orientable.\r\n         * See {@link https://mathinsight.org/greens_theorem_find_area}\r\n         * @returns {number}\r\n         */\r\n        orientation() {\r\n            if (this._orientation === undefined) {\r\n                let area = this.signedArea();\r\n                if (Flatten.Utils.EQ_0(area)) {\r\n                    this._orientation = Flatten.ORIENTATION.NOT_ORIENTABLE;\r\n                }\r\n                else if (Flatten.Utils.LT(area, 0)) {\r\n                    this._orientation = Flatten.ORIENTATION.CCW;\r\n                }\r\n                else {\r\n                    this._orientation = Flatten.ORIENTATION.CW;\r\n                }\r\n            }\r\n            return this._orientation;\r\n        }\r\n\r\n        /**\r\n         * Returns true if face of the polygon is simple (no self-intersection points found)\r\n         * NOTE: this method is incomplete because it doe not exclude touching points\r\n         * Real self intersection inverts orientation of the polygon.\r\n         * But this is also good enough for the demonstration of the idea\r\n         * @param {Edges} edges - reference to polygon.edges to provide search index\r\n         * @returns {boolean}\r\n         */\r\n        isSimple(edges) {\r\n            let ip = Face.getSelfIntersections(this, edges, true);\r\n            return ip.length == 0;\r\n        }\r\n\r\n        static getSelfIntersections(face, edges, exitOnFirst = false) {\r\n            let int_points = [];\r\n\r\n            // calculate intersections\r\n            for (let edge1 of face) {\r\n\r\n                // request edges of polygon in the box of edge1\r\n                let resp = edges.search(edge1.box);\r\n\r\n                // for each edge2 in response\r\n                for (let edge2 of resp) {\r\n\r\n                    // Skip itself\r\n                    if (edge1 === edge2)\r\n                        continue;\r\n\r\n                    // Skip next and previous edge if both are segment (if one of them arc - calc intersection)\r\n                    if (edge1.shape instanceof Flatten.Segment && edge2.shape instanceof Flatten.Segment &&\r\n                        (edge1.next === edge2 || edge1.prev === edge2))\r\n                        continue;\r\n\r\n                    // calculate intersections between edge1 and edge2\r\n                    let ip = edge1.shape.intersect(edge2.shape);\r\n\r\n                    // for each intersection point\r\n                    for (let pt of ip) {\r\n\r\n                        // skip start-end connections\r\n                        if (pt.equalTo(edge1.start) && pt.equalTo(edge2.end) && edge2 === edge1.prev)\r\n                            continue;\r\n                        if (pt.equalTo(edge1.end) && pt.equalTo(edge2.start) && edge2 === edge1.next)\r\n                            continue;\r\n\r\n                        int_points.push(pt);\r\n\r\n                        if (exitOnFirst)\r\n                            break;\r\n                    }\r\n\r\n                    if (int_points.length > 0 && exitOnFirst)\r\n                        break;\r\n                }\r\n\r\n                if (int_points.length > 0 && exitOnFirst)\r\n                    break;\r\n\r\n            }\r\n            return int_points;\r\n        }\r\n\r\n        toJSON() {\r\n            return this.edges.map(edge => edge.toJSON());\r\n        }\r\n\r\n        /**\r\n         * Returns string to be assigned to \"d\" attribute inside defined \"path\"\r\n         * @returns {string}\r\n         */\r\n        svg() {\r\n            let svgStr = `\\nM${this.first.start.x},${this.first.start.y}`;\r\n            for (let edge of this) {\r\n                svgStr += edge.svg();\r\n            }\r\n            svgStr += ` z`;\r\n            return svgStr;\r\n        }\r\n\r\n    };\r\n};","\"use strict\";\r\n\r\nmodule.exports = function(Flatten) {\r\n    let {Point, Segment, Line, Circle, Arc, Box, Vector} = Flatten;\r\n    /**\r\n     * Class representing a horizontal ray, used by ray shooting algorithm\r\n     * @type {Ray}\r\n     */\r\n    Flatten.Ray = class Ray {\r\n        /**\r\n         * Construct ray by setting start point\r\n         * @param {Point} pt - start point\r\n         */\r\n        constructor(...args) {\r\n            this.pt = new Point();\r\n\r\n            if (args.length == 0) {\r\n                return;\r\n            }\r\n\r\n            if (args.length == 1 && args[0] instanceof Point) {\r\n                this.pt = args[0].clone();\r\n                return;\r\n            }\r\n\r\n            if (args.length == 2 && typeof(args[0]) == \"number\" && typeof(args[1]) == \"number\") {\r\n                this.pt = new Point(args[0], args[1]);\r\n                return;\r\n            }\r\n\r\n            throw Flatten.Errors.ILLEGAL_PARAMETERS;\r\n        }\r\n\r\n        /**\r\n         * Returns copied instance of the ray object\r\n         * @returns {Ray}\r\n         */\r\n        clone() {\r\n            return new Ray(this.pt);\r\n        }\r\n\r\n        /**\r\n         * Returns half-infinite bounding box of the ray\r\n         * @returns {Box} - bounding box\r\n         */\r\n        get box() {\r\n            return new Box(\r\n                this.pt.x,\r\n                this.pt.y,\r\n                Number.POSITIVE_INFINITY,\r\n                this.pt.y\r\n            )\r\n        }\r\n\r\n        /**\r\n         * Return ray start point\r\n         * @returns {Point} - ray start point\r\n         */\r\n        get start() {\r\n            return this.pt;\r\n        }\r\n\r\n        /**\r\n         * Return ray normal vector (0,1) - horizontal ray\r\n         * @returns {Vector} - ray normal vector\r\n         */\r\n        get norm() {\r\n            return new Vector(0,1);\r\n        }\r\n\r\n        /**\r\n         * Returns array of intersection points between ray and segment or arc\r\n         * @param {Segment|Arc} - Shape to intersect with ray\r\n         * @returns {Array} array of intersection points\r\n         */\r\n        intersect(shape) {\r\n            if (shape instanceof Segment) {\r\n                return this.intersectRay2Segment(this, shape);\r\n            }\r\n\r\n            if (shape instanceof Arc) {\r\n                return this.intersectRay2Arc(this, shape);\r\n            }\r\n        }\r\n\r\n        intersectRay2Segment(ray, segment) {\r\n            let ip = [];\r\n\r\n            if (ray.box.not_intersect(segment.box)) {\r\n                return ip;\r\n            }\r\n\r\n            let line = new Line(ray.start, ray.norm);\r\n            let ip_tmp = line.intersect(segment);\r\n\r\n            for (let pt of ip_tmp) {\r\n                if (Flatten.Utils.GE(pt.x, ray.start.x)) {\r\n                    ip.push(pt);\r\n                }\r\n            }\r\n\r\n            /* If there were two intersection points between line and ray,\r\n            and now there is exactly one left, it means ray starts between these points\r\n            and there is another intersection point - start of the ray */\r\n            if (ip_tmp.length == 2 && ip.length == 1 && ray.start.on(line)) {\r\n                ip.push(ray.start);\r\n            }\r\n\r\n            return ip;\r\n        }\r\n\r\n        intersectRay2Arc(ray, arc) {\r\n            let ip = [];\r\n\r\n            if (ray.box.not_intersect(arc.box)) {\r\n                return ip;\r\n            }\r\n\r\n            let line = new Line(ray.start, ray.norm);\r\n            let ip_tmp = line.intersect(arc);\r\n\r\n            for (let pt of ip_tmp) {\r\n                if (Flatten.Utils.GE(pt.x, ray.start.x)) {\r\n                    ip.push(pt);\r\n                }\r\n            }\r\n            return ip;\r\n        }\r\n    };\r\n\r\n    Flatten.ray = (...args) => new Flatten.Ray(...args);\r\n};","\r\n\"use strict\";\r\n\r\nmodule.exports = function(Flatten) {\r\n    let {Polygon, Point, Segment, Arc, Line, Ray} = Flatten;\r\n\r\n    Flatten.ray_shoot = function(polygon, point) {\r\n        let contains = undefined;\r\n\r\n        // if (!(polygon instanceof Polygon && point instanceof Point)) {\r\n        //     throw Flatten.Errors.ILLEGAL_PARAMETERS;\r\n        // }\r\n\r\n        // 1. Quick reject\r\n        if (polygon.box.not_intersect(point.box)) {\r\n            return Flatten.OUTSIDE;\r\n        }\r\n\r\n        let ray = new Ray(point);\r\n        let line = new Line(ray.pt, ray.norm);\r\n\r\n        // 2. Locate relevant edges of the polygon\r\n        let resp_edges = polygon.edges.search(ray.box);\r\n\r\n        if (resp_edges.length == 0) {\r\n            return Flatten.OUTSIDE;\r\n        }\r\n\r\n        // 3. Calculate intersections\r\n        let intersections = [];\r\n        for (let edge of resp_edges) {\r\n            for (let ip of ray.intersect(edge.shape)) {\r\n\r\n                // If intersection is equal to query point then point lays on boundary\r\n                if (ip.equalTo(point)) {\r\n                    return Flatten.BOUNDARY;\r\n                }\r\n\r\n                intersections.push({\r\n                    pt: ip,\r\n                    edge: edge\r\n                });\r\n            }\r\n        }\r\n\r\n        // 4. Sort intersection in x-ascending order\r\n        intersections.sort( (i1, i2) => {\r\n            if (Flatten.Utils.LT(i1.pt.x, i2.pt.x)) {\r\n                return -1;\r\n            }\r\n            if (Flatten.Utils.GT(i1.pt.x, i2.pt.x)) {\r\n                return 1;\r\n            }\r\n            return 0;\r\n        });\r\n\r\n        // 5. Count real intersections, exclude touching\r\n        let counter = 0;\r\n\r\n        for (let i=0; i < intersections.length; i++) {\r\n            let intersection = intersections[i];\r\n            if (intersection.pt.equalTo(intersection.edge.shape.start)) {\r\n                /* skip same point between same edges if already counted */\r\n                if (i > 0 && intersection.pt.equalTo(intersections[i-1].pt) &&\r\n                    intersection.edge.prev === intersections[i-1].edge) {\r\n                    continue;\r\n                }\r\n                let prev_edge = intersection.edge.prev;\r\n                while (Flatten.Utils.EQ_0(prev_edge.length)) {\r\n                    prev_edge = prev_edge.prev;\r\n                }\r\n                let prev_tangent = prev_edge.shape.tangentInEnd();\r\n                let prev_point = intersection.pt.translate(prev_tangent);\r\n\r\n                let cur_tangent = intersection.edge.shape.tangentInStart();\r\n                let cur_point = intersection.pt.translate(cur_tangent);\r\n\r\n                let prev_on_the_left = prev_point.leftTo(line);\r\n                let cur_on_the_left = cur_point.leftTo(line);\r\n\r\n                if ( (prev_on_the_left && !cur_on_the_left) || (!prev_on_the_left && cur_on_the_left) ) {\r\n                    counter++;\r\n                }\r\n            }\r\n            else if (intersection.pt.equalTo(intersection.edge.shape.end)) {\r\n                /* skip same point between same edges if already counted */\r\n                if (i > 0 && intersection.pt.equalTo(intersections[i-1].pt) &&\r\n                    intersection.edge.next === intersections[i-1].edge) {\r\n                    continue;\r\n                }\r\n                let next_edge = intersection.edge.next;\r\n                while (Flatten.Utils.EQ_0(next_edge.length)) {\r\n                    next_edge = next_edge.next;\r\n                }\r\n                let next_tangent = next_edge.shape.tangentInStart();\r\n                let next_point = intersection.pt.translate(next_tangent);\r\n\r\n                let cur_tangent = intersection.edge.shape.tangentInEnd();\r\n                let cur_point = intersection.pt.translate(cur_tangent);\r\n\r\n                let next_on_the_left = next_point.leftTo(line);\r\n                let cur_on_the_left = cur_point.leftTo(line);\r\n\r\n                if ( (next_on_the_left && !cur_on_the_left) || (!next_on_the_left && cur_on_the_left) ) {\r\n                    counter++;\r\n                }\r\n            }\r\n            else {        /* intersection point is not a coincident with a vertex */\r\n                if (intersection.edge.shape instanceof Segment) {\r\n                    counter++;\r\n                }\r\n                else {\r\n                    /* Check if ray does not touch the curve in the extremal (top or bottom) point */\r\n                    let box = intersection.edge.shape.box;\r\n                    if ( !(Flatten.Utils.EQ(intersection.pt.y, box.ymin) ||\r\n                            Flatten.Utils.EQ(intersection.pt.y, box.ymax)) ) {\r\n                        counter++;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        // 6. Odd or even?\r\n        contains = counter % 2 == 1 ? Flatten.INSIDE : Flatten.OUTSIDE;\r\n\r\n        return contains;\r\n    };\r\n};","/**\r\n * Created by Alex Bol on 3/15/2017.\r\n */\r\n\r\n\"use strict\";\r\n\r\nmodule.exports = function(Flatten) {\r\n    let {Edge, Face, PlanarSet, Box} = Flatten;\r\n    let {ray_shoot} = Flatten;\r\n    /**\r\n     * Class representing a polygon.<br/>\r\n     * Polygon in FlattenJS is a multipolygon comprised from a set of [faces]{@link Flatten.Face}. <br/>\r\n     * Face, in turn, is a closed loop of [edges]{@link Flatten.Edge}, where edge may be segment or circular arc<br/>\r\n     * @type {Polygon}\r\n     */\r\n    Flatten.Polygon = class Polygon {\r\n        /**\r\n         * Constructor creates new instance of polygon.<br/>\r\n         * New polygon is empty. Add face to the polygon using method <br/>\r\n         * <code>\r\n         *     polygon.addFace(Points[]|Segments[]|Arcs[])\r\n         * </code>\r\n         */\r\n        constructor() {\r\n            /**\r\n             * Container of faces (closed loops), may be empty\r\n             * @type {PlanarSet}\r\n             */\r\n            this.faces = new PlanarSet();\r\n            /**\r\n             * Container of edges\r\n             * @type {PlanarSet}\r\n             */\r\n            this.edges = new PlanarSet();\r\n        }\r\n\r\n        /**\r\n         * (Getter) Returns bounding box of the polygon\r\n         * @returns {Box}\r\n         */\r\n        get box() {\r\n            return [...this.faces].reduce( (acc, face) => acc.merge(face.box), new Box() );\r\n        }\r\n\r\n        /**\r\n         * (Getter) Returns array of vertices\r\n         * @returns {Array}\r\n         */\r\n        get vertices() {\r\n            return [...this.edges].map( edge => edge.start);\r\n        }\r\n\r\n        /**\r\n         * Return true is polygon has no edges\r\n         * @returns {boolean}\r\n         */\r\n        isEmpty() {\r\n            return this.edges.size === 0;\r\n        }\r\n\r\n        /**\r\n         * Add new face to polygon. Returns added face\r\n         * @param {Points[]|Segments[]|Arcs[]|Circle|Box} args -  new face may be create with one of the following ways: <br/>\r\n         * 1) array of points that describe closed path (edges are segments) <br/>\r\n         * 2) array of shapes (segments and arcs) which describe closed path <br/>\r\n         * 3) circle - will be added as counterclockwise arc <br/>\r\n         * 4) box - will be added as counterclockwise rectangle <br/>\r\n         * You can chain method face.reverse() is you need to change direction of the creates face\r\n         * @returns {Face}\r\n         */\r\n        addFace(...args) {\r\n            let face = new Face(this, ...args);\r\n            this.faces.add(face);\r\n            return face;\r\n        }\r\n\r\n        /**\r\n         * Delete existing face from polygon\r\n         * @param {Face} face Face to be deleted\r\n         * @returns {boolean}\r\n         */\r\n        deleteFace(face) {\r\n            for (let edge of face) {\r\n                let deleted = this.edges.delete(edge);\r\n            }\r\n            let deleted = this.faces.delete(face);\r\n            return deleted;\r\n        }\r\n\r\n        /**\r\n         * Delete chain of edges from the face.\r\n         * @param {Face} face Face to remove chain\r\n         * @param {Edge} edgeFrom Start of the chain of edges to be removed\r\n         * @param {Edge} edgeTo End of the chain of edges to be removed\r\n         */\r\n        removeChain(face, edgeFrom, edgeTo) {\r\n            // Special case: all edges removed\r\n            if (edgeTo.next === edgeFrom) {\r\n                this.deleteFace(face);\r\n                return;\r\n            }\r\n            for (let edge = edgeFrom; edge !== edgeTo.next; edge = edge.next ) {\r\n                face.remove(this.edges, edge);\r\n                // this.edges.delete(edge);      // delete from PlanarSet of edges and update index\r\n                if (face.isEmpty()) {\r\n                    this.deleteFace(face);    // delete from PlanarSet of faces and update index\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Add point as a new vertex and split edge. Point supposed to belong to an edge.\r\n         * When edge is split, new edge created from the start of the edge to the new vertex\r\n         * and inserted before current edge.\r\n         * Current edge is trimmed and updated. Method returns new edge added.\r\n         * @param {Edge} edge Edge to be split with new vertex and then trimmed from start\r\n         * @param {Point} pt Point to be added as a new vertex\r\n         * @returns {Edge}\r\n         */\r\n        addVertex(pt, edge) {\r\n            let shapes = edge.shape.split(pt);\r\n            if (shapes.length < 2) return;\r\n            let newEdge = new Flatten.Edge(shapes[0]);\r\n            let edgeBefore = edge.prev;\r\n\r\n            /* Insert first split edge into linked list after edgeBefore */\r\n            edge.face.insert(this.edges, newEdge, edgeBefore);\r\n\r\n            // Remove old edge from edges container and 2d index\r\n            this.edges.delete(edge);\r\n\r\n            // Update edge shape with second split edge keeping links\r\n            edge.shape = shapes[1];\r\n\r\n            // Add updated edge to the edges container and 2d index\r\n            this.edges.add(edge);\r\n\r\n            return newEdge;\r\n        }\r\n\r\n        reverse() {\r\n            for (let face of this.faces) {\r\n                face.reverse();\r\n            }\r\n            return this;\r\n        }\r\n\r\n        /**\r\n         * Create new copied instance of the polygon\r\n         * @returns {Polygon}\r\n         */\r\n        clone() {\r\n            let polygon = new Polygon();\r\n            for (let face of this.faces) {\r\n                let shapes = [];\r\n                for (let edge of face) {\r\n                    shapes.push(edge.shape.clone());\r\n                }\r\n                polygon.addFace(shapes);\r\n            }\r\n            return polygon;\r\n        }\r\n\r\n        /**\r\n         * Returns area of the polygon. Area of an island will be added, area of a hole will be subtracted\r\n         * @returns {number}\r\n         */\r\n        area() {\r\n            let signedArea = [...this.faces].reduce((acc,face) => acc + face.signedArea(), 0);\r\n            return Math.abs(signedArea);\r\n        }\r\n\r\n        /**\r\n         * Returns true if polygon contains point, including polygon boundary, false otherwise\r\n         * Point in polygon test based on ray shooting algorithm\r\n         * @param {Point} point - test point\r\n         * @returns {boolean}\r\n         */\r\n        contains(point) {\r\n            let rel = ray_shoot(this, point);\r\n            return (rel == Flatten.INSIDE || rel == Flatten.BOUNDARY) ? true : false;\r\n        }\r\n\r\n        /**\r\n         * Return distance and shortest segment between polygon and other shape as array [distance, shortest_segment]\r\n         * @param {Shape} shape Shape of one of the types Point, Circle, Line, Segment, Arc or Polygon\r\n         * @returns {Number | Segment}\r\n         */\r\n        distanceTo(shape) {\r\n            let {Distance} = Flatten;\r\n\r\n            if (shape instanceof Flatten.Point) {\r\n                let [dist, shortest_segment] = Distance.point2polygon(shape, this);\r\n                shortest_segment = shortest_segment.reverse();\r\n                return [dist, shortest_segment];\r\n            }\r\n\r\n            if (shape instanceof Flatten.Circle ||\r\n            shape instanceof Flatten.Line ||\r\n            shape instanceof Flatten.Segment ||\r\n            shape instanceof Flatten.Arc) {\r\n                let [dist, shortest_segment] = Distance.shape2polygon(shape, this);\r\n                shortest_segment = shortest_segment.reverse();\r\n                return [dist, shortest_segment];\r\n            }\r\n\r\n            /* this method is bit faster */\r\n            if (shape instanceof  Flatten.Polygon) {\r\n                let min_dist_and_segment = [Number.POSITIVE_INFINITY, new Flatten.Segment()];\r\n                let dist, shortest_segment;\r\n\r\n                for (let edge of this.edges) {\r\n                    // let [dist, shortest_segment] = Distance.shape2polygon(edge.shape, shape);\r\n                    let min_stop = min_dist_and_segment[0];\r\n                    [dist, shortest_segment] = Distance.shape2planarSet(edge.shape, shape.edges, min_stop);\r\n                    if (Flatten.Utils.LT(dist, min_stop)) {\r\n                        min_dist_and_segment = [dist, shortest_segment];\r\n                    }\r\n                }\r\n                return min_dist_and_segment;\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Return array of intersection points between polygon and other shape\r\n         * @param shape Shape of the one of supported types <br/>\r\n         * @returns {Point[]}\r\n         */\r\n        intersect(shape) {\r\n            if (shape instanceof Flatten.Point) {\r\n                return this.contains(shape) ? [shape] : [];\r\n            }\r\n\r\n            if (shape instanceof Flatten.Line) {\r\n                return Polygon.intersectLine2Polygon(shape, this);\r\n            }\r\n\r\n            if (shape instanceof Flatten.Circle ||\r\n                shape instanceof Flatten.Segment ||\r\n                shape instanceof Flatten.Arc) {\r\n                return Polygon.intersectShape2Polygon(shape, this);\r\n            }\r\n\r\n            if (shape instanceof Flatten.Polygon) {\r\n                return Polygon.intersectPolygon2Polygon(shape, this);\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Return true if polygon is valid for boolean operations\r\n         * Polygon is valid if <br/>\r\n         * 1. All faces are simple polygons (there are no self-intersected polygons) <br/>\r\n         * 2. All faces are orientable and there is no island inside island or hole inside hole - TODO <br/>\r\n         * 3. There is no intersections between faces (excluding touching) - TODO <br/>\r\n         * @returns {boolean}\r\n         */\r\n        isValid() {\r\n            let valid = true;\r\n            // 1. Polygon is invalid if at least one face is not simple\r\n            for (let face of this.faces) {\r\n                if (!face.isSimple(this.edges)) {\r\n                    valid = false;\r\n                    break;\r\n                }\r\n            }\r\n            // 2. TODO: check if no island inside island and no hole inside hole\r\n            // 3. TODO: check the there is no intersection between faces\r\n            return valid;\r\n        }\r\n\r\n        /**\r\n         * Returns new polygon translated by vector vec\r\n         * @param {Vector} vec\r\n         * @returns {Polygon}\r\n         */\r\n        translate(vec) {\r\n            let newPolygon = new Polygon();\r\n            for (let face of this.faces) {\r\n                let shapes = [];\r\n                for (let edge of face) {\r\n                    shapes.push(edge.shape.translate(vec));\r\n                }\r\n                newPolygon.addFace(shapes);\r\n            }\r\n            return newPolygon;\r\n        }\r\n\r\n        /**\r\n         * Return new polygon rotated by given angle around given point\r\n         * If point omitted, rotate around origin (0,0)\r\n         * Positive value of angle defines rotation counter clockwise, negative - clockwise\r\n         * @param {number} angle - rotation angle in radians\r\n         * @param {Point} center - rotation center, default is (0,0)\r\n         * @returns {Polygon} - new rotated polygon\r\n         */\r\n        rotate(angle=0, center=new Flatten.Point()) {\r\n            let newPolygon = new Polygon();\r\n            for (let face of this.faces) {\r\n                let shapes = [];\r\n                for (let edge of face) {\r\n                    shapes.push(edge.shape.rotate(angle, center));\r\n                }\r\n                newPolygon.addFace(shapes);\r\n            }\r\n            return newPolygon;\r\n        }\r\n\r\n        /**\r\n         * Return new polygon transformed using affine transformation matrix\r\n         * @param {Matrix} matrix - affine transformation matrix\r\n         * @returns {Polygon} - new polygon\r\n         */\r\n        transform(matrix = new Flatten.Matrix()) {\r\n            let newPolygon = new Polygon();\r\n            for (let face of this.faces) {\r\n                let shapes = [];\r\n                for (let edge of face) {\r\n                    shapes.push(edge.shape.transform(matrix));\r\n                }\r\n                newPolygon.addFace(shapes);\r\n            }\r\n            return newPolygon;\r\n        }\r\n\r\n        static intersectShape2Polygon(shape, polygon) {\r\n            let ip = [];\r\n\r\n            if ( polygon.isEmpty() || shape.box.not_intersect(polygon.box) ) {\r\n                return ip;\r\n            }\r\n\r\n            let resp_edges = polygon.edges.search(shape.box);\r\n\r\n            for (let edge of resp_edges) {\r\n                for (let pt of shape.intersect(edge.shape)) {\r\n                    ip.push(pt);\r\n                }\r\n            }\r\n\r\n            return ip;\r\n        }\r\n\r\n        static intersectLine2Polygon(line, polygon) {\r\n            let ip = [];\r\n\r\n            if ( polygon.isEmpty() ) {\r\n                return ip;\r\n            }\r\n\r\n            for (let edge of polygon.edges) {\r\n                for (let pt of line.intersect(edge.shape)) {\r\n                    ip.push(pt);\r\n                }\r\n            }\r\n\r\n            return ip;\r\n        }\r\n\r\n        static intersectPolygon2Polygon(polygon1, polygon2) {\r\n            let ip = [];\r\n\r\n            if (polygon1.isEmpty() || polygon2.isEmpty()) {\r\n                return ip;\r\n            }\r\n\r\n            if (polygon1.box.not_intersect(polygon2.box)) {\r\n                return ip;\r\n            }\r\n\r\n            for (let edge1 of polygon1.edges) {\r\n                for (let pt of Polygon.intersectShape2Polygon(edge1.shape, polygon2)) {\r\n                    ip.push(pt);\r\n                }\r\n            }\r\n\r\n            return ip;\r\n        }\r\n\r\n        /**\r\n         * Return string to draw polygon in svg\r\n         * @param attrs  - an object with attributes for svg path element,\r\n         * like \"stroke\", \"strokeWidth\", \"fill\", \"fillRule\", \"fillOpacity\"\r\n         * Defaults are stroke:\"black\", strokeWidth:\"1\", fill:\"lightcyan\", fillRule:\"evenodd\", fillOpacity: \"1\"\r\n         * @returns {string}\r\n         */\r\n        svg(attrs = {}) {\r\n            let {stroke, strokeWidth, fill, fillRule, fillOpacity, id, className} = attrs;\r\n            // let restStr = Object.keys(rest).reduce( (acc, key) => acc += ` ${key}=\"${rest[key]}\"`, \"\");\r\n            let id_str = (id && id.length > 0) ? `id=\"${id}\"` : \"\";\r\n            let class_str = (className && className.length > 0) ? `class=\"${className}\"` : \"\";\r\n\r\n            let svgStr = `\\n<path stroke=\"${stroke || \"black\"}\" stroke-width=\"${strokeWidth || 1}\" fill=\"${fill || \"lightcyan\"}\" fill-rule=\"${fillRule || \"evenodd\"}\" fill-opacity=\"${fillOpacity || 1.0}\" ${id_str} ${class_str} d=\"`;\r\n            for (let face of this.faces) {\r\n                svgStr += face.svg();\r\n            }\r\n            svgStr += `\" >\\n</path>`;\r\n            return svgStr;\r\n        }\r\n\r\n        /**\r\n         * This method returns an object that defines how data will be\r\n         * serialized when called JSON.stringify() method\r\n         * @returns {Object}\r\n         */\r\n        toJSON() {\r\n            return [...this.faces].map(face => face.toJSON());\r\n        }\r\n    }\r\n};","\"use strict\";\r\n\r\nlet IntervalTree = require('flatten-interval-tree');\r\n\r\nmodule.exports = function(Flatten) {\r\n    let {Polygon, Point, Segment, Arc, Circle, Line, Ray, Vector} = Flatten;\r\n\r\n    let {vector} = Flatten;\r\n\r\n    Flatten.Distance = class Distance {\r\n        /**\r\n         * Calculate distance and shortest segment between points\r\n         * @param pt1\r\n         * @param pt2\r\n         * @returns {Number | Segment} - distance and shortest segment\r\n         */\r\n        static point2point(pt1, pt2) {\r\n            return pt1.distanceTo(pt2);\r\n        }\r\n\r\n        /**\r\n         * Calculate distance and shortest segment between point and line\r\n         * @param pt\r\n         * @param line\r\n         * @returns {Number | Segment} - distance and shortest segment\r\n         */\r\n        static point2line(pt, line) {\r\n            let closest_point = pt.projectionOn(line);\r\n            let vec = vector(pt, closest_point);\r\n            return [vec.length, new Segment(pt, closest_point)];\r\n        }\r\n\r\n        /**\r\n         * Calculate distance and shortest segment between point and circle\r\n         * @param pt\r\n         * @param circle\r\n         * @returns {Number | Segment} - distance and shortest segment\r\n         */\r\n        static point2circle(pt, circle) {\r\n            let [dist2center, shortest_dist] = pt.distanceTo(circle.center);\r\n            if (Flatten.Utils.EQ_0(dist2center)) {\r\n                return [circle.r, new Segment(pt, circle.toArc().start)];\r\n            }\r\n            else {\r\n                let dist = Math.abs(dist2center - circle.r);\r\n                let v = vector(circle.pc, pt).normalize().multiply(circle.r);\r\n                let closest_point = circle.pc.translate(v);\r\n                return [dist, new Segment(pt, closest_point)];\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Calculate distance and shortest segment between point and segment\r\n         * @param pt\r\n         * @param segment\r\n         * @returns {Number | Segment} - distance and shortest segment\r\n         */\r\n        static point2segment(pt, segment) {\r\n            /* Degenerated case of zero-length segment */\r\n            if (segment.start.equalTo(segment.end)) {\r\n                return  Distance.point2point(pt, segment.start);\r\n            }\r\n\r\n            let v_seg = new Flatten.Vector(segment.start, segment.end);\r\n            let v_ps2pt = new Flatten.Vector(segment.start, pt);\r\n            let v_pe2pt = new Flatten.Vector(segment.end, pt);\r\n            let start_sp = v_seg.dot(v_ps2pt);\r\n            /* dot product v_seg * v_ps2pt */\r\n            let end_sp = -v_seg.dot(v_pe2pt);\r\n            /* minus dot product v_seg * v_pe2pt */\r\n\r\n            let dist;\r\n            let closest_point;\r\n            if (Flatten.Utils.GE(start_sp, 0) && Flatten.Utils.GE(end_sp, 0)) {    /* point inside segment scope */\r\n                let v_unit = segment.tangentInStart(); // new Flatten.Vector(v_seg.x / this.length, v_seg.y / this.length);\r\n                /* unit vector ||v_unit|| = 1 */\r\n                dist = Math.abs(v_unit.cross(v_ps2pt));\r\n                /* dist = abs(v_unit x v_ps2pt) */\r\n                closest_point = segment.start.translate(v_unit.multiply(v_unit.dot(v_ps2pt)));\r\n                return [dist, new Segment(pt, closest_point)];\r\n            }\r\n            else if (start_sp < 0) {                             /* point is out of scope closer to ps */\r\n                return pt.distanceTo(segment.start);\r\n            }\r\n            else {                                               /* point is out of scope closer to pe */\r\n                return pt.distanceTo(segment.end);\r\n            }\r\n        };\r\n\r\n        /**\r\n         * Calculate distance and shortest segment between point and arc\r\n         * @param pt\r\n         * @param arc\r\n         * @returns {Number | Segment} - distance and shortest segment\r\n         */\r\n        static point2arc(pt, arc) {\r\n            let circle = new Flatten.Circle(arc.pc, arc.r);\r\n            let dist_and_segment = [];\r\n            let dist, shortest_segment;\r\n            [dist, shortest_segment] = Distance.point2circle(pt, circle);\r\n            if (shortest_segment.end.on(arc)) {\r\n                dist_and_segment.push(Distance.point2circle(pt, circle));\r\n            }\r\n            dist_and_segment.push( Distance.point2point(pt, arc.start) );\r\n            dist_and_segment.push( Distance.point2point(pt, arc.end) );\r\n\r\n            Distance.sort(dist_and_segment);\r\n\r\n            return dist_and_segment[0];\r\n        }\r\n\r\n        /**\r\n         * Calculate distance and shortest segment between segment and line\r\n         * @param seg\r\n         * @param line\r\n         * @returns {Number | Segment}\r\n         */\r\n        static segment2line(seg, line) {\r\n            let ip = seg.intersect(line);\r\n            if (ip.length > 0) {\r\n                return [0, new Segment(ip[0],ip[0])];   // distance = 0, closest point is the first point\r\n            }\r\n            let dist_and_segment = [];\r\n            dist_and_segment.push(Distance.point2line(seg.start, line));\r\n            dist_and_segment.push(Distance.point2line(seg.end, line));\r\n\r\n            Distance.sort( dist_and_segment );\r\n            return dist_and_segment[0];\r\n\r\n        }\r\n\r\n        /**\r\n         * Calculate distance and shortest segment between two segments\r\n         * @param seg1\r\n         * @param seg2\r\n         * @returns {Number | Segment} - distance and shortest segment\r\n         */\r\n        static segment2segment(seg1, seg2) {\r\n            let ip = Segment.intersectSegment2Segment(seg1, seg2);\r\n            if (ip.length > 0) {\r\n                return [0, new Segment(ip[0],ip[0])];   // distance = 0, closest point is the first point\r\n            }\r\n\r\n            // Seg1 and seg2 not intersected\r\n            let dist_and_segment = [];\r\n\r\n            dist_and_segment.push(Distance.point2segment(seg2.start, seg1));\r\n            dist_and_segment.push(Distance.point2segment(seg2.end, seg1));\r\n            dist_and_segment.push(Distance.point2segment(seg1.start, seg2));\r\n            dist_and_segment.push(Distance.point2segment(seg1.end, seg2));\r\n\r\n            Distance.sort( dist_and_segment );\r\n            return dist_and_segment[0];\r\n        }\r\n\r\n        /**\r\n         * Calculate distance and shortest segment between segment and circle\r\n         * @param seg\r\n         * @param circle\r\n         * @returns {Number | Segment} - distance and shortest segment\r\n         */\r\n        static segment2circle(seg, circle) {\r\n            /* Case 1 Segment and circle intersected. Return the first point and zero distance */\r\n            let ip = seg.intersect(circle);\r\n            if (ip.length > 0) {\r\n                return [0, new Segment(ip[0], ip[0])];\r\n            }\r\n\r\n            // No intersection between segment and circle\r\n\r\n            /* Case 2. Distance to projection of center point to line bigger than radius\r\n             * And projection point belong to segment\r\n              * Then measure again distance from projection to circle and return it */\r\n            let line = new Flatten.Line(seg.ps, seg.pe);\r\n            let [dist, shortest_segment] = Distance.point2line(circle.center, line);\r\n            if (Flatten.Utils.GE(dist, circle.r) && shortest_segment.end.on(seg)) {\r\n                return Distance.point2circle(shortest_segment.end, circle);\r\n            }\r\n            /* Case 3. Otherwise closest point is one of the end points of the segment */\r\n            else {\r\n                let [dist_from_start, shortest_segment_from_start] = Distance.point2circle(seg.start, circle);\r\n                let [dist_from_end, shortest_segment_from_end] = Distance.point2circle(seg.end, circle);\r\n                return Flatten.Utils.LT(dist_from_start, dist_from_end) ?\r\n                    [dist_from_start, shortest_segment_from_start] :\r\n                    [dist_from_end, shortest_segment_from_end];\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Calculate distance and shortest segment between segment and arc\r\n         * @param seg\r\n         * @param arc\r\n         * @returns {Number | Segment} - distance and shortest segment\r\n         */\r\n        static segment2arc(seg, arc) {\r\n            /* Case 1 Segment and arc intersected. Return the first point and zero distance */\r\n            let ip = seg.intersect(arc);\r\n            if (ip.length > 0) {\r\n                return [0, new Segment(ip[0], ip[0])];\r\n            }\r\n\r\n            // No intersection between segment and arc\r\n            let line = new Flatten.Line(seg.ps, seg.pe);\r\n            let circle = new Flatten.Circle(arc.pc, arc.r);\r\n\r\n            /* Case 2. Distance to projection of center point to line bigger than radius AND\r\n             * projection point belongs to segment AND\r\n               * distance from projection point to circle belongs to arc  =>\r\n               * return this distance from projection to circle */\r\n            let [dist_from_center, shortest_segment_from_center] = Distance.point2line(circle.center, line);\r\n            if (Flatten.Utils.GE(dist_from_center, circle.r) && shortest_segment_from_center.end.on(seg)) {\r\n                let [dist_from_projection, shortest_segment_from_projection] =\r\n                    Distance.point2circle(shortest_segment_from_center.end, circle);\r\n                if (shortest_segment_from_projection.end.on(arc)) {\r\n                    return [dist_from_projection, shortest_segment_from_projection];\r\n                }\r\n            }\r\n            /* Case 3. Otherwise closest point is one of the end points of the segment */\r\n            let dist_and_segment = [];\r\n            dist_and_segment.push(Distance.point2arc(seg.start, arc));\r\n            dist_and_segment.push(Distance.point2arc(seg.end, arc));\r\n\r\n            let dist_tmp, segment_tmp;\r\n            [dist_tmp, segment_tmp] = Distance.point2segment(arc.start, seg);\r\n            dist_and_segment.push([dist_tmp, segment_tmp.reverse()]);\r\n\r\n            [dist_tmp, segment_tmp] = Distance.point2segment(arc.end, seg);\r\n            dist_and_segment.push([dist_tmp, segment_tmp.reverse()]);\r\n\r\n            Distance.sort(dist_and_segment);\r\n            return dist_and_segment[0];\r\n        }\r\n\r\n        /**\r\n         * Calculate distance and shortest segment between two circles\r\n         * @param circle1\r\n         * @param circle2\r\n         * @returns {Number | Segment} - distance and shortest segment\r\n         */\r\n        static circle2circle(circle1, circle2) {\r\n            let ip = circle1.intersect(circle2);\r\n            if (ip.length > 0) {\r\n                return [0, new Segment(ip[0], ip[0])];\r\n            }\r\n\r\n            // Case 1. Concentric circles. Convert to arcs and take distance between two arc starts\r\n            if (circle1.center.equalTo(circle2.center)) {\r\n                let arc1 = circle1.toArc();\r\n                let arc2 = circle2.toArc();\r\n                return Distance.point2point(arc1.start, arc2.start);\r\n            }\r\n            else {\r\n                // Case 2. Not concentric circles\r\n                let line = new Line(circle1.center, circle2.center);\r\n                let ip1 = line.intersect(circle1);\r\n                let ip2 = line.intersect(circle2);\r\n\r\n                let dist_and_segment = [];\r\n\r\n                dist_and_segment.push(Distance.point2point(ip1[0], ip2[0]));\r\n                dist_and_segment.push(Distance.point2point(ip1[0], ip2[1]));\r\n                dist_and_segment.push(Distance.point2point(ip1[1], ip2[0]));\r\n                dist_and_segment.push(Distance.point2point(ip1[1], ip2[1]));\r\n\r\n                Distance.sort(dist_and_segment);\r\n                return dist_and_segment[0];\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Calculate distance and shortest segment between two circles\r\n         * @param circle\r\n         * @param line\r\n         * @returns {Number | Segment} - distance and shortest segment\r\n         */\r\n        static circle2line(circle, line) {\r\n            let ip = circle.intersect(line);\r\n            if (ip.length > 0) {\r\n                return [0, new Segment(ip[0], ip[0])];\r\n            }\r\n\r\n            let [dist_from_center, shortest_segment_from_center] = Distance.point2line(circle.center, line);\r\n            let [dist, shortest_segment] = Distance.point2circle(shortest_segment_from_center.end, circle);\r\n            shortest_segment = shortest_segment.reverse();\r\n            return [dist, shortest_segment];\r\n        }\r\n\r\n        /**\r\n         * Calculate distance and shortest segment between arc and line\r\n         * @param arc\r\n         * @param line\r\n         * @returns {Number | Segment} - distance and shortest segment\r\n         */\r\n        static arc2line(arc, line) {\r\n            /* Case 1 Line and arc intersected. Return the first point and zero distance */\r\n            let ip = line.intersect(arc);\r\n            if (ip.length > 0) {\r\n                return [0, new Segment(ip[0], ip[0])];\r\n            }\r\n\r\n            let circle = new Flatten.Circle(arc.center, arc.r);\r\n\r\n            /* Case 2. Distance to projection of center point to line bigger than radius AND\r\n             * projection point belongs to segment AND\r\n               * distance from projection point to circle belongs to arc  =>\r\n               * return this distance from projection to circle */\r\n            let [dist_from_center, shortest_segment_from_center] = Distance.point2line(circle.center, line);\r\n            if (Flatten.Utils.GE(dist_from_center, circle.r)) {\r\n                let [dist_from_projection, shortest_segment_from_projection] =\r\n                    Distance.point2circle(shortest_segment_from_center.end, circle);\r\n                if (shortest_segment_from_projection.end.on(arc)) {\r\n                    return [dist_from_projection, shortest_segment_from_projection];\r\n                }\r\n            }\r\n            else {\r\n                let dist_and_segment = [];\r\n                dist_and_segment.push( Distance.point2line(arc.start, line) );\r\n                dist_and_segment.push( Distance.point2line(arc.end, line) );\r\n\r\n                Distance.sort(dist_and_segment);\r\n                return dist_and_segment[0];\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Calculate distance and shortest segment between arc and circle\r\n         * @param arc\r\n         * @param circle2\r\n         * @returns {Number | Segment} - distance and shortest segment\r\n         */\r\n        static arc2circle(arc, circle2) {\r\n            let ip = arc.intersect(circle2);\r\n            if (ip.length > 0) {\r\n                return [0, new Segment(ip[0], ip[0])];\r\n            }\r\n\r\n            let circle1 = new Flatten.Circle(arc.center, arc.r);\r\n\r\n            let [dist, shortest_segment] = Distance.circle2circle(circle1, circle2);\r\n            if (shortest_segment.start.on(arc)) {\r\n                return [dist, shortest_segment];\r\n            }\r\n            else {\r\n                let dist_and_segment = [];\r\n\r\n                dist_and_segment.push(Distance.point2circle(arc.start, circle2));\r\n                dist_and_segment.push(Distance.point2circle(arc.end, circle2));\r\n\r\n                Distance.sort(dist_and_segment);\r\n\r\n                return dist_and_segment[0];\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Calculate distance and shortest segment between two arcs\r\n         * @param arc1\r\n         * @param arc2\r\n         * @returns {Number | Segment} - distance and shortest segment\r\n         */\r\n        static arc2arc(arc1, arc2) {\r\n            let ip = arc1.intersect(arc2);\r\n            if (ip.length > 0) {\r\n                return [0, new Segment(ip[0], ip[0])];\r\n            }\r\n\r\n            let circle1 = new Flatten.Circle(arc1.center, arc1.r);\r\n            let circle2 = new Flatten.Circle(arc2.center, arc2.r);\r\n\r\n            let [dist, shortest_segment] = Distance.circle2circle(circle1, circle2);\r\n            if (shortest_segment.start.on(arc1) && shortest_segment.end.on(arc2)) {\r\n                return [dist, shortest_segment];\r\n            }\r\n            else {\r\n                let dist_and_segment = [];\r\n\r\n                let dist_tmp, segment_tmp;\r\n\r\n                [dist_tmp, segment_tmp] = Distance.point2arc(arc1.start, arc2);\r\n                if (segment_tmp.end.on(arc2)) {\r\n                    dist_and_segment.push([dist_tmp, segment_tmp]);\r\n                }\r\n\r\n                [dist_tmp, segment_tmp] = Distance.point2arc(arc1.end, arc2);\r\n                if (segment_tmp.end.on(arc2)) {\r\n                    dist_and_segment.push([dist_tmp, segment_tmp]);\r\n                }\r\n\r\n                [dist_tmp, segment_tmp] = Distance.point2arc(arc2.start, arc1);\r\n                if (segment_tmp.end.on(arc1)) {\r\n                    dist_and_segment.push([dist_tmp, segment_tmp.reverse()]);\r\n                }\r\n\r\n                [dist_tmp, segment_tmp] = Distance.point2arc(arc2.end, arc1);\r\n                if (segment_tmp.end.on(arc1)) {\r\n                    dist_and_segment.push([dist_tmp, segment_tmp.reverse()]);\r\n                }\r\n\r\n                [dist_tmp, segment_tmp] = Distance.point2point(arc1.start, arc2.start);\r\n                dist_and_segment.push([dist_tmp, segment_tmp]);\r\n\r\n                [dist_tmp, segment_tmp] = Distance.point2point(arc1.start, arc2.end);\r\n                dist_and_segment.push([dist_tmp, segment_tmp]);\r\n\r\n                [dist_tmp, segment_tmp] = Distance.point2point(arc1.end, arc2.start);\r\n                dist_and_segment.push([dist_tmp, segment_tmp]);\r\n\r\n                [dist_tmp, segment_tmp] = Distance.point2point(arc1.end, arc2.end);\r\n                dist_and_segment.push([dist_tmp, segment_tmp]);\r\n\r\n                Distance.sort(dist_and_segment);\r\n\r\n                return dist_and_segment[0];\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Calculate distance and shortest segment between point and polygon\r\n         * @param point\r\n         * @param polygon\r\n         * @returns {Number | Segment} - distance and shortest segment\r\n         */\r\n        static point2polygon(point, polygon) {\r\n            let min_dist_and_segment = [Number.POSITIVE_INFINITY, new Segment()];\r\n            for (let edge of polygon.edges) {\r\n                let [dist, shortest_segment] = (edge.shape instanceof Segment) ?\r\n                    Distance.point2segment(point, edge.shape) : Distance.point2arc(point, edge.shape);\r\n                if (Flatten.Utils.LT(dist, min_dist_and_segment[0])) {\r\n                    min_dist_and_segment = [dist, shortest_segment];\r\n                }\r\n            }\r\n            return min_dist_and_segment;\r\n        }\r\n\r\n        static shape2polygon(shape, polygon) {\r\n            let min_dist_and_segment = [Number.POSITIVE_INFINITY, new Segment()];\r\n            for (let edge of polygon.edges) {\r\n                let [dist, shortest_segment] = shape.distanceTo(edge.shape);\r\n                if (Flatten.Utils.LT(dist, min_dist_and_segment[0])) {\r\n                    min_dist_and_segment = [dist, shortest_segment];\r\n                }\r\n            }\r\n            return min_dist_and_segment;\r\n        }\r\n\r\n/*\r\n        static arc2polygon(arc, polygon) {\r\n            let ip = arc.intersect(polygon);\r\n            if (ip.length > 0) {\r\n                return [0, new Segment(ip[0], ip[0])];\r\n            }\r\n\r\n            let min_dist_and_segment = [Number.POSITIVE_INFINITY, new Segment()];\r\n            for (let edge of polygon.edges) {\r\n                let [dist, shortest_segment] = arc.distanceTo(edge.shape);\r\n                if (Flatten.Utils.LT(dist, min_dist_and_segment[0])) {\r\n                    min_dist_and_segment = [dist, shortest_segment];\r\n                }\r\n            }\r\n            return min_dist_and_segment;\r\n        }\r\n\r\n        static line2polygon(line, polygon) {\r\n            let ip = line.intersect(polygon);\r\n            if (ip.length > 0) {\r\n                return [0, new Segment(ip[0], ip[0])];\r\n            }\r\n\r\n            let min_dist_and_segment = [Number.POSITIVE_INFINITY, new Segment()];\r\n            for (let edge of polygon.edges) {\r\n                let [dist, shortest_segment] = line.distanceTo(edge.shape);\r\n                if (Flatten.Utils.LT(dist, min_dist_and_segment[0])) {\r\n                    min_dist_and_segment = [dist, shortest_segment];\r\n                }\r\n            }\r\n            return min_dist_and_segment;\r\n        }\r\n\r\n        static circle2polygon(circle, polygon) {\r\n            let ip = circle.intersect(polygon);\r\n            if (ip.length > 0) {\r\n                return [0, new Segment(ip[0], ip[0])];\r\n            }\r\n\r\n            let min_dist_and_segment = [Number.POSITIVE_INFINITY, new Segment()];\r\n            for (let edge of polygon.edges) {\r\n                let [dist, shortest_segment] = circle.distanceTo(edge.shape);\r\n                if (Flatten.Utils.LT(dist, min_dist_and_segment[0])) {\r\n                    min_dist_and_segment = [dist, shortest_segment];\r\n                }\r\n            }\r\n            return min_dist_and_segment;\r\n        }\r\n*/\r\n\r\n        /**\r\n         * Calculate distance and shortest segment between two polygons\r\n         * @param polygon1\r\n         * @param polygon2\r\n         * @returns {Number | Segment} - distance and shortest segment\r\n         */\r\n        static polygon2polygon(polygon1, polygon2) {\r\n            let min_dist_and_segment = [Number.POSITIVE_INFINITY, new Flatten.Segment()];\r\n            for (let edge1 of polygon1.edges) {\r\n                for (let edge2 of polygon2.edges) {\r\n                    let [dist, shortest_segment] = edge1.shape.distanceTo(edge2.shape);\r\n                    if (Flatten.Utils.LT(dist, min_dist_and_segment[0])) {\r\n                        min_dist_and_segment = [dist, shortest_segment];\r\n                    }\r\n                }\r\n            }\r\n            return min_dist_and_segment;\r\n        }\r\n\r\n        /**\r\n         * Returns [mindist, maxdist] array of squared minimal and maximal distance between boxes\r\n         * Minimal distance by x is\r\n         *    (box2.xmin - box1.xmax), if box1 is left to box2\r\n         *    (box1.xmin - box2.xmax), if box2 is left to box1\r\n         *    0,                       if box1 and box2 are intersected by x\r\n         * Minimal distance by y is defined in the same way\r\n         *\r\n         * Maximal distance is estimated as a sum of squared dimensions of the merged box\r\n         *\r\n         * @param box1\r\n         * @param box2\r\n         * @returns {Number | Number} - minimal and maximal distance\r\n         */\r\n        static box2box_minmax(box1, box2) {\r\n            let mindist_x = Math.max( Math.max(box1.xmin - box2.xmax, 0), Math.max(box2.xmin - box1.xmax, 0) );\r\n            let mindist_y = Math.max( Math.max(box1.ymin - box2.ymax, 0), Math.max(box2.ymin - box1.ymax, 0) );\r\n            let mindist = mindist_x*mindist_x + mindist_y*mindist_y;\r\n\r\n            let box = box1.merge(box2);\r\n            let dx = box.xmax - box.xmin;\r\n            let dy = box.ymax - box.ymin;\r\n            let maxdist = dx*dx + dy*dy;\r\n\r\n            return [mindist, maxdist];\r\n        }\r\n\r\n        static minmax_tree_process_level(shape, level, min_stop, tree) {\r\n            // Calculate minmax distance to each shape in current level\r\n            // Insert result into the interval tree for further processing\r\n            // update min_stop with maxdist, it will be the new stop distance\r\n            let mindist, maxdist;\r\n            for (let node of level) {\r\n\r\n                // [mindist, maxdist] = Distance.box2box_minmax(shape.box, node.max);\r\n                // if (Flatten.Utils.GT(mindist, min_stop))\r\n                //     continue;\r\n\r\n                // Estimate min-max dist to the shape stored in the node.item, using node.item.key which is shape's box\r\n                [mindist, maxdist] = Distance.box2box_minmax(shape.box, node.item.key);\r\n                if (node.item.value instanceof Flatten.Edge) {\r\n                    tree.insert([mindist, maxdist], node.item.value.shape);\r\n                }\r\n                else {\r\n                    tree.insert([mindist, maxdist], node.item.value);\r\n                }\r\n                if (Flatten.Utils.LT(maxdist, min_stop)) {\r\n                    min_stop = maxdist;                       // this will be the new distance estimation\r\n                }\r\n            }\r\n\r\n            if (level.length === 0)\r\n                return min_stop;\r\n\r\n            // Calculate new level from left and right children of the current\r\n            let new_level_left = level.map(node => node.left.isNil() ? undefined : node.left ).filter(node => node !== undefined);\r\n            let new_level_right = level.map(node => node.right.isNil() ? undefined : node.right).filter(node => node !== undefined);\r\n            // Merge left and right subtrees and leave only relevant subtrees\r\n            let new_level = [...new_level_left, ...new_level_right].filter( node => {\r\n                // Node subtree quick reject, node.max is a subtree box\r\n                let [mindist, maxdist] = Distance.box2box_minmax(shape.box, node.max);\r\n                return (Flatten.Utils.LE(mindist, min_stop));\r\n            });\r\n\r\n            min_stop = Distance.minmax_tree_process_level(shape, new_level, min_stop, tree);\r\n            return min_stop;\r\n        }\r\n\r\n        /**\r\n         * Calculates sorted tree of [mindist, maxdist] intervals between query shape\r\n         * and shapes of the planar set.\r\n         * @param shape\r\n         * @param set\r\n         */\r\n        static minmax_tree(shape, set, min_stop) {\r\n            let tree = new IntervalTree();\r\n            let level = [set.index.root];\r\n            let squared_min_stop = min_stop < Number.POSITIVE_INFINITY ? min_stop*min_stop : Number.POSITIVE_INFINITY;\r\n            squared_min_stop = Distance.minmax_tree_process_level(shape, level, squared_min_stop, tree);\r\n            return tree;\r\n        }\r\n\r\n        static minmax_tree_calc_distance(shape, node, min_dist_and_segment) {\r\n            let min_dist_and_segment_new, stop;\r\n            if (node != null && !node.isNil()) {\r\n                [min_dist_and_segment_new, stop] = Distance.minmax_tree_calc_distance(shape, node.left, min_dist_and_segment);\r\n\r\n                if (stop) {\r\n                    return [min_dist_and_segment_new, stop];\r\n                }\r\n\r\n                if (Flatten.Utils.LT(min_dist_and_segment_new[0], Math.sqrt(node.item.key.low))) {\r\n                    return [min_dist_and_segment_new, true];   // stop condition\r\n                }\r\n\r\n                let [dist, shortest_segment] = Distance.distance(shape, node.item.value);\r\n                // console.log(dist)\r\n                if (Flatten.Utils.LT(dist, min_dist_and_segment_new[0])) {\r\n                    min_dist_and_segment_new = [dist, shortest_segment];\r\n                }\r\n\r\n                [min_dist_and_segment_new, stop] = Distance.minmax_tree_calc_distance(shape, node.right, min_dist_and_segment_new);\r\n\r\n                return [min_dist_and_segment_new, stop];\r\n            }\r\n\r\n            return [min_dist_and_segment, false];\r\n        }\r\n\r\n        /**\r\n         * Calculates distance between shape and Planar Set of shapes\r\n         * @param shape\r\n         * @param {PlanarSet} set\r\n         * @param {Number} min_stop\r\n         * @returns {*}\r\n         */\r\n        static shape2planarSet(shape, set, min_stop = Number.POSITIVE_INFINITY) {\r\n            let min_dist_and_segment = [min_stop, new Flatten.Segment()];\r\n            let stop = false;\r\n            if (set instanceof Flatten.PlanarSet) {\r\n                let tree = Distance.minmax_tree(shape, set, min_stop);\r\n                [min_dist_and_segment, stop] = Distance.minmax_tree_calc_distance(shape, tree.root, min_dist_and_segment);\r\n            }\r\n            return min_dist_and_segment;\r\n        }\r\n\r\n        static sort(dist_and_segment) {\r\n            dist_and_segment.sort((d1, d2) => {\r\n                if (Flatten.Utils.LT(d1[0], d2[0])) {\r\n                    return -1;\r\n                }\r\n                if (Flatten.Utils.GT(d1[0], d2[0])) {\r\n                    return 1;\r\n                }\r\n                return 0;\r\n            });\r\n        }\r\n\r\n        static distance(shape1, shape2) {\r\n            return shape1.distanceTo(shape2);\r\n        }\r\n    }\r\n};","/**\r\n * Created by Alex Bol on 2/18/2017.\r\n */\r\n'use strict';\r\n\r\nlet Utils = require(\"./utils/utils\");\r\nlet Errors = require(\"./utils/errors\");\r\n\r\n/**\r\n * FlattenJS - library for 2d geometry\r\n * @type {Flatten}\r\n */\r\nlet Flatten = class Flatten {\r\n    constructor() {\r\n        this.DP_TOL = Utils.DP_TOL;\r\n        this.CCW = true;\r\n        this.CW = false;\r\n        this.ORIENTATION = {CCW:-1, CW:1, NOT_ORIENTABLE: 0};\r\n        this.PIx2 = 2 * Math.PI;\r\n        // this.PI_2 = 0.5 * Math.PI;\r\n        this.INSIDE = 1;\r\n        this.OUTSIDE = 0;\r\n        this.BOUNDARY = 2;\r\n        this.CONTAINS = 3;\r\n        this.INTERLACE = 4;\r\n        this.OVERLAP_SAME = 1;\r\n        this.OVERLAP_OPPOSITE = 2;\r\n        this.Utils = Utils;\r\n        this.Errors = Errors;\r\n    }\r\n};\r\n\r\nlet f = new Flatten();\r\n\r\nrequire(\"./classes/matrix\")(f);\r\nrequire(\"./data_structures/planar_set\")(f);\r\nrequire(\"./classes/point\")(f);\r\nrequire(\"./classes/vector\")(f);\r\nrequire(\"./classes/line\")(f);\r\nrequire(\"./classes/circle\")(f);\r\nrequire(\"./classes/segment\")(f);\r\nrequire(\"./classes/arc\")(f);\r\nrequire(\"./classes/box\")(f);\r\nrequire(\"./classes/edge\")(f);\r\nrequire(\"./classes/face\")(f);\r\nrequire(\"./classes/ray\")(f);\r\nrequire(\"./algorithms/ray_shooting\")(f);\r\nrequire(\"./classes/polygon\")(f);\r\nrequire(\"./algorithms/distance\")(f);\r\n\r\nmodule.exports = f;\r\n","import Flatten from 'flatten-js';\nconst {point, polygon} = Flatten;\nconst { unify } = Flatten.BooleanOperations;\n\nfunction getNumLayers(path0, path1){\n  //return larger number of layers\n  const layers0 = new Set();\n  const layers1 = new Set();\n  layers0.forEach(p => path0.add(p[2]));\n  layers1.forEach(p => path1.add(p[2]));\n  return Math.max(layers0.size, layers1.size);\n}\n\n\nfunction union(path0, path1, radius){ //revise\n  //assuming path0 is an array of points [x, y, z] -> [[1, 2, 3], [4, 5, 6], ...]\n  //Flattenjs doesn't take in a tolerance\n  layers0 = getNumLayers(path0);\n  // let path = [];\n  let path = [43.0];\n\n  for(let layer = 0; layer < layers0.length; layer++){\n    let points0 = path0.filter(p => p[2] == layer).map(p => point([p[0], p[1]]));\n    let points1 = path1.filter(p => p[2] == layer).map(p => point([p[0], p[1]]));\n\n    let polygon0 = new polygon(points0);\n    let polygon1 = new polygon(points1);\n    \n    let combinedPolygon = unify(polygon0, polygon1);\n    let filletedPolygon = combinedPolygon.fillet(radius); \n    let combinedLayerPoints = filletedPolygon.vertices.map(vertex => [vertex.x, vertex.y]);\n    path.push(combinedLayerPoints);\n    path.push(3.0); //test\n  }\n  console.log(\"Union path\", path);\n  return path;\n}\n\n\n\n\n\n\n\n//test:\n/*\n{\n  let { point, segment, circle, arc, Polygon } = Flatten;\n  const { unify } = Flatten.BooleanOperations;\n  let pw = width / 48;\n  let ph = height / 48;\n\n  // Create new instance of polygon\n  let polygon = new Polygon();\n  let polygon1 = new Polygon();\n \nconst p1 = new Polygon([[0, 30], [30, 30], [30, 0], [0, 0]]);\nconst p2 = new Polygon([[20, 5], [20, 25], [40, 15]]);\nconst p3 = unify(p1, p2);\nlet combinedPolygonPoints = p3.vertices.map(vertex => [vertex.x, vertex.y]);\n\n\n  let stage = d3.select(DOM.svg(width, height));\n\n  // Add svg element to svg stage container\n  stage.html(p3.svg());\n\n  // return stage.node();\n  return combinedPolygonPoints;\n  // return JSON.stringify(combinedPolygonPoints);\n}\n*/","var OVERLAY_ID = '__parcel__error__overlay__';\n\nvar OldModule = module.bundle.Module;\n\nfunction Module(moduleName) {\n  OldModule.call(this, moduleName);\n  this.hot = {\n    data: module.bundle.hotData,\n    _acceptCallbacks: [],\n    _disposeCallbacks: [],\n    accept: function (fn) {\n      this._acceptCallbacks.push(fn || function () {});\n    },\n    dispose: function (fn) {\n      this._disposeCallbacks.push(fn);\n    }\n  };\n\n  module.bundle.hotData = null;\n}\n\nmodule.bundle.Module = Module;\nvar checkedAssets, assetsToAccept;\n\nvar parent = module.bundle.parent;\nif ((!parent || !parent.isParcelRequire) && typeof WebSocket !== 'undefined') {\n  var hostname = process.env.HMR_HOSTNAME || location.hostname;\n  var protocol = location.protocol === 'https:' ? 'wss' : 'ws';\n  var ws = new WebSocket(protocol + '://' + hostname + ':' + process.env.HMR_PORT + '/');\n  ws.onmessage = function(event) {\n    checkedAssets = {};\n    assetsToAccept = [];\n\n    var data = JSON.parse(event.data);\n\n    if (data.type === 'update') {\n      var handled = false;\n      data.assets.forEach(function(asset) {\n        if (!asset.isNew) {\n          var didAccept = hmrAcceptCheck(global.parcelRequire, asset.id);\n          if (didAccept) {\n            handled = true;\n          }\n        }\n      });\n\n      // Enable HMR for CSS by default.\n      handled = handled || data.assets.every(function(asset) {\n        return asset.type === 'css' && asset.generated.js;\n      });\n\n      if (handled) {\n        console.clear();\n\n        data.assets.forEach(function (asset) {\n          hmrApply(global.parcelRequire, asset);\n        });\n\n        assetsToAccept.forEach(function (v) {\n          hmrAcceptRun(v[0], v[1]);\n        });\n      } else if (location.reload) { // `location` global exists in a web worker context but lacks `.reload()` function.\n        location.reload();\n      }\n    }\n\n    if (data.type === 'reload') {\n      ws.close();\n      ws.onclose = function () {\n        location.reload();\n      }\n    }\n\n    if (data.type === 'error-resolved') {\n      console.log('[parcel]  Error resolved');\n\n      removeErrorOverlay();\n    }\n\n    if (data.type === 'error') {\n      console.error('[parcel]   ' + data.error.message + '\\n' + data.error.stack);\n\n      removeErrorOverlay();\n\n      var overlay = createErrorOverlay(data);\n      document.body.appendChild(overlay);\n    }\n  };\n}\n\nfunction removeErrorOverlay() {\n  var overlay = document.getElementById(OVERLAY_ID);\n  if (overlay) {\n    overlay.remove();\n  }\n}\n\nfunction createErrorOverlay(data) {\n  var overlay = document.createElement('div');\n  overlay.id = OVERLAY_ID;\n\n  // html encode message and stack trace\n  var message = document.createElement('div');\n  var stackTrace = document.createElement('pre');\n  message.innerText = data.error.message;\n  stackTrace.innerText = data.error.stack;\n\n  overlay.innerHTML = (\n    '<div style=\"background: black; font-size: 16px; color: white; position: fixed; height: 100%; width: 100%; top: 0px; left: 0px; padding: 30px; opacity: 0.85; font-family: Menlo, Consolas, monospace; z-index: 9999;\">' +\n      '<span style=\"background: red; padding: 2px 4px; border-radius: 2px;\">ERROR</span>' +\n      '<span style=\"top: 2px; margin-left: 5px; position: relative;\"></span>' +\n      '<div style=\"font-size: 18px; font-weight: bold; margin-top: 20px;\">' + message.innerHTML + '</div>' +\n      '<pre>' + stackTrace.innerHTML + '</pre>' +\n    '</div>'\n  );\n\n  return overlay;\n\n}\n\nfunction getParents(bundle, id) {\n  var modules = bundle.modules;\n  if (!modules) {\n    return [];\n  }\n\n  var parents = [];\n  var k, d, dep;\n\n  for (k in modules) {\n    for (d in modules[k][1]) {\n      dep = modules[k][1][d];\n      if (dep === id || (Array.isArray(dep) && dep[dep.length - 1] === id)) {\n        parents.push(k);\n      }\n    }\n  }\n\n  if (bundle.parent) {\n    parents = parents.concat(getParents(bundle.parent, id));\n  }\n\n  return parents;\n}\n\nfunction hmrApply(bundle, asset) {\n  var modules = bundle.modules;\n  if (!modules) {\n    return;\n  }\n\n  if (modules[asset.id] || !bundle.parent) {\n    var fn = new Function('require', 'module', 'exports', asset.generated.js);\n    asset.isNew = !modules[asset.id];\n    modules[asset.id] = [fn, asset.deps];\n  } else if (bundle.parent) {\n    hmrApply(bundle.parent, asset);\n  }\n}\n\nfunction hmrAcceptCheck(bundle, id) {\n  var modules = bundle.modules;\n  if (!modules) {\n    return;\n  }\n\n  if (!modules[id] && bundle.parent) {\n    return hmrAcceptCheck(bundle.parent, id);\n  }\n\n  if (checkedAssets[id]) {\n    return;\n  }\n  checkedAssets[id] = true;\n\n  var cached = bundle.cache[id];\n\n  assetsToAccept.push([bundle, id]);\n\n  if (cached && cached.hot && cached.hot._acceptCallbacks.length) {\n    return true;\n  }\n\n  return getParents(global.parcelRequire, id).some(function (id) {\n    return hmrAcceptCheck(global.parcelRequire, id)\n  });\n}\n\nfunction hmrAcceptRun(bundle, id) {\n  var cached = bundle.cache[id];\n  bundle.hotData = {};\n  if (cached) {\n    cached.hot.data = bundle.hotData;\n  }\n\n  if (cached && cached.hot && cached.hot._disposeCallbacks.length) {\n    cached.hot._disposeCallbacks.forEach(function (cb) {\n      cb(bundle.hotData);\n    });\n  }\n\n  delete bundle.cache[id];\n  bundle(id);\n\n  cached = bundle.cache[id];\n  if (cached && cached.hot && cached.hot._acceptCallbacks.length) {\n    cached.hot._acceptCallbacks.forEach(function (cb) {\n      cb();\n    });\n    return true;\n  }\n}\n"]}